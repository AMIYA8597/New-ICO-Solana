use anchor_lang::prelude::*;
use anchor_spl::{
    associated_token::AssociatedToken,
    token::{self, Mint, TokenAccount, Transfer},
};

declare_id!("G2abrCjb3pZDdwUWEN1vsAr3mPBFWrMAgA26LfvNWk8D");

#[program]
pub mod advanced_ico_program {
    use super::*;

    // Initialize the ICO
    pub fn initialize(
        ctx: Context<Initialize>,
        total_supply: u64,
        token_price: u64,
        start_time: i64,
        duration: i64,
        round_type: RoundType,
    ) -> Result<()> {
        let ico = &mut ctx.accounts.ico_account;
        ico.authority = ctx.accounts.authority.key();
        ico.token_mint = ctx.accounts.token_mint.key();
        ico.total_supply = total_supply;
        ico.token_price = token_price;
        ico.start_time = start_time;
        ico.duration = duration;
        ico.tokens_sold = 0;
        ico.is_active = true;
        ico.round_type = round_type;
        ico.seed_investors = Vec::new(); // Initialize empty seed investors list

        Ok(())
    }

    // Update ICO parameters
    pub fn update_ico_parameters(
        ctx: Context<UpdateIcoParameters>,
        total_supply: Option<u64>,
        token_price: Option<u64>,
        start_time: Option<i64>,
        duration: Option<i64>,
        round_type: Option<RoundType>,
    ) -> Result<()> {
        let ico = &mut ctx.accounts.ico_account;

        // Ensure only the ICO authority can update parameters
        require!(
            ctx.accounts.authority.key() == ico.authority,
            IcoError::Unauthorized
        );

        // Update parameters if provided
        if let Some(supply) = total_supply {
            ico.total_supply = supply;
        }

        if let Some(price) = token_price {
            ico.token_price = price;
        }

        if let Some(start) = start_time {
            ico.start_time = start;
        }

        if let Some(dur) = duration {
            ico.duration = dur;
        }

        if let Some(round) = round_type {
            ico.round_type = round;
        }

        Ok(())
    }

    // Add a seed investor to the whitelist
    pub fn add_seed_investor(ctx: Context<AddSeedInvestor>, investor: Pubkey) -> Result<()> {
        let ico = &mut ctx.accounts.ico_account;

        // Ensure only the ICO authority can add seed investors
        require!(
            ctx.accounts.authority.key() == ico.authority,
            IcoError::Unauthorized
        );

        // Add the investor to the whitelist
        ico.seed_investors.push(investor);

        Ok(())
    }

    // Remove a seed investor from the whitelist
    pub fn remove_seed_investor(ctx: Context<RemoveSeedInvestor>, investor: Pubkey) -> Result<()> {
        let ico = &mut ctx.accounts.ico_account;

        // Ensure only the ICO authority can remove seed investors
        require!(
            ctx.accounts.authority.key() == ico.authority,
            IcoError::Unauthorized
        );

        // Find and remove the investor from the whitelist
        if let Some(index) = ico.seed_investors.iter().position(|&x| x == investor) {
            ico.seed_investors.remove(index);
        }

        Ok(())
    }

    // Buy tokens during the ICO
    pub fn buy_tokens(ctx: Context<BuyTokens>, amount: u64) -> Result<()> {
        let current_time = Clock::get()?.unix_timestamp;
        let ico = &mut ctx.accounts.ico_account;

        // Validate ICO status and token availability
        require!(
            ico.is_active
                && current_time >= ico.start_time
                && current_time < ico.start_time + ico.duration,
            IcoError::IcoNotActive
        );

        // Special whitelist check for Seed Round
        if ico.round_type == RoundType::SeedRound {
            require!(
                ico.seed_investors.contains(&ctx.accounts.buyer.key()),
                IcoError::NotWhitelisted
            );
        }

        require!(
            ico.tokens_sold + amount <= ico.total_supply,
            IcoError::InsufficientTokens
        );

        // Calculate total cost
        let total_cost = amount
            .checked_mul(ico.token_price)
            .ok_or(IcoError::MathOverflow)?;

        // Transfer SOL to treasury
        let transfer_context = CpiContext::new(
            ctx.accounts.system_program.to_account_info(),
            anchor_lang::system_program::Transfer {
                from: ctx.accounts.buyer.to_account_info(),
                to: ctx.accounts.treasury_wallet.to_account_info(),
            },
        );
        anchor_lang::system_program::transfer(transfer_context, total_cost)?;

        // Update purchase tracking
        let purchase = &mut ctx.accounts.purchase_account;
        purchase.buyer = ctx.accounts.buyer.key();
        purchase.amount = purchase
            .amount
            .checked_add(amount)
            .ok_or(IcoError::MathOverflow)?;
        purchase.is_distributed = false;

        // Update ICO tracking
        ico.tokens_sold = ico
            .tokens_sold
            .checked_add(amount)
            .ok_or(IcoError::MathOverflow)?;

        // Emit purchase event
        emit!(TokenPurchaseEvent {
            buyer: ctx.accounts.buyer.key(),
            amount,
            price: ico.token_price,
            round_type: ico.round_type.clone(),
        });

        Ok(())
    }

    // Distribute tokens to buyers
    pub fn distribute_tokens(ctx: Context<DistributeTokens>) -> Result<()> {
        let ico = &mut ctx.accounts.ico_account;

        // Ensure ICO is not active and tokens have been sold
        require!(!ico.is_active, IcoError::IcoStillActive);
        require!(ico.tokens_sold > 0, IcoError::InsufficientTokens);

        // Validate caller is ICO authority
        require!(
            ctx.accounts.authority.key() == ico.authority,
            IcoError::Unauthorized
        );

        // Perform token transfer from treasury to buyer's token account
        let transfer_context = CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            Transfer {
                from: ctx.accounts.treasury_token_account.to_account_info(),
                to: ctx.accounts.buyer_token_account.to_account_info(),
                authority: ctx.accounts.authority.to_account_info(),
            },
        );

        // Transfer tokens equal to purchase amount
        token::transfer(transfer_context, ctx.accounts.purchase_account.amount)?;

        // Mark purchase as distributed
        let purchase = &mut ctx.accounts.purchase_account;
        purchase.is_distributed = true;

        // Emit distribution event
        emit!(PurchaseEvent {
            buyer: purchase.buyer,
            amount: purchase.amount,
            is_distributed: true,
        });

        Ok(())
    }

    // End the ICO
    pub fn end_ico(ctx: Context<EndIco>) -> Result<()> {
        let ico = &mut ctx.accounts.ico_account;
        let current_time = Clock::get()?.unix_timestamp;

        require!(
            current_time >= ico.start_time + ico.duration,
            IcoError::IcoStillActive
        );

        ico.is_active = false;
        Ok(())
    }

    // Get seed investors (utility function)
    pub fn get_seed_investors(ctx: Context<GetSeedInvestors>) -> Result<()> {
        let ico = &ctx.accounts.ico_account;
        msg!("Number of seed investors: {}", ico.seed_investors.len());
        for (index, investor) in ico.seed_investors.iter().enumerate() {
            msg!("Seed Investor {}: {}", index + 1, investor);
        }

        Ok(())
    }
}

// Fundraising Round Types
#[derive(AnchorSerialize, AnchorDeserialize, Clone, PartialEq)]
pub enum RoundType {
    SeedRound,
    PreICO,
    PublicICO,
}

impl Default for RoundType {
    fn default() -> Self {
        RoundType::SeedRound
    }
}

// Events
#[event]
pub struct TokenPurchaseEvent {
    pub buyer: Pubkey,
    pub amount: u64,
    pub price: u64,
    pub round_type: RoundType,
}

#[event]
pub struct PurchaseEvent {
    pub buyer: Pubkey,
    pub amount: u64,
    pub is_distributed: bool,
}

// Purchase Account
#[account]
#[derive(Default)]
pub struct PurchaseAccount {
    pub buyer: Pubkey,
    pub amount: u64,
    pub is_distributed: bool,
}

// ICO Account
#[account]
#[derive(Default)]
pub struct IcoAccount {
    pub authority: Pubkey,
    pub token_mint: Pubkey,
    pub total_supply: u64,
    pub token_price: u64,
    pub tokens_sold: u64,
    pub start_time: i64,
    pub duration: i64,
    pub is_active: bool,
    pub round_type: RoundType,
    pub seed_investors: Vec<Pubkey>,
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,
    #[account(
        init, 
        payer = authority, 
        space = 8 + 32 + 2 + 8 + 6 + 1 + 1 + 4 + (32 * 100),
        seeds = [b"ico"],
        bump
    )]
    pub ico_account: Account<'info, IcoAccount>,
    #[account(mut)]
    pub token_mint: Account<'info, Mint>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct UpdateIcoParameters<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,
    #[account(
        mut,
        seeds = [b"ico"],
        bump
    )]
    pub ico_account: Account<'info, IcoAccount>,
}

#[derive(Accounts)]
pub struct BuyTokens<'info> {
    #[account(mut)]
    pub buyer: Signer<'info>,
    #[account(
        mut,
        seeds = [b"ico"],
        bump
    )]
    pub ico_account: Account<'info, IcoAccount>,
    #[account(
        init_if_needed,
        payer = buyer, 
        space = 8 + 32 + 8 + 1,
        seeds = [b"purchase", buyer.key().as_ref()],
        bump
    )]
    pub purchase_account: Account<'info, PurchaseAccount>,
    #[account(mut)]
    pub treasury_wallet: SystemAccount<'info>,
    pub token_program: Program<'info, token::Token>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct DistributeTokens<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,
    #[account(
        mut,
        seeds = [b"ico"],
        bump
    )]
    pub ico_account: Account<'info, IcoAccount>,
    #[account(mut)]
    pub treasury_token_account: Account<'info, TokenAccount>,
    #[account(mut)]
    pub buyer_token_account: Account<'info, TokenAccount>,
    #[account(
        mut,
        seeds = [b"purchase", purchase_account.buyer.as_ref()],
        bump
    )]
    pub purchase_account: Account<'info, PurchaseAccount>,
    pub token_program: Program<'info, token::Token>,
}

#[derive(Accounts)]
pub struct EndIco<'info> {
    #[account(
        mut,
        seeds = [b"ico"],
        bump
    )]
    pub ico_account: Account<'info, IcoAccount>,
}

#[derive(Accounts)]
pub struct AddSeedInvestor<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,
    #[account(
        mut,
        seeds = [b"ico"],
        bump
    )]
    pub ico_account: Account<'info, IcoAccount>,
}

#[derive(Accounts)]
pub struct RemoveSeedInvestor<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,
    #[account(
        mut,
        seeds = [b"ico"],
        bump
    )]
    pub ico_account: Account<'info, IcoAccount>,
}

#[derive(Accounts)]
pub struct GetSeedInvestors<'info> {
    #[account(
        seeds = [b"ico"],
        bump
    )]
    pub ico_account: Account<'info, IcoAccount>,
}

#[error_code]
pub enum IcoError {
    #[msg("ICO is not currently active")]
    IcoNotActive,
    #[msg("Insufficient tokens remaining")]
    InsufficientTokens,
    #[msg("ICO is still active")]
    IcoStillActive,
    #[msg("You are not authorized to perform this action")]
    Unauthorized,
    #[msg("Purchase account not found")]
    PurchaseAccountNotFound,
    #[msg("Buyer token account not found")]
    BuyerTokenAccountNotFound,
    #[msg("Mathematical overflow occurred")]
    MathOverflow,
    #[msg("Investor is not whitelisted for the seed round")]
    NotWhitelisted,
}















BTW my current owner wallet address is    "DYkCAokwibanNxMvixmoZFQDwayGDJWfJ9moZjDRpUvW"


and base on the smart contract i create this files in my reactjs project










src/pages/BuyTokens.js


import React, { useState, useEffect } from 'react';
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { PublicKey, Transaction, SystemProgram, LAMPORTS_PER_SOL } from '@solana/web3.js';
import { getProgram } from '../utils/anchor-connection';
import * as anchor from '@project-serum/anchor';
import { 
  TOKEN_PROGRAM_ID, 
  getAssociatedTokenAddress, 
  createAssociatedTokenAccountInstruction,
  getAccount
} from '@solana/spl-token';

const TREASURY_WALLET = new PublicKey('FoScPhAv3DcAwdxNbo4U47cJRhihL3mUSQKfZu3f6SJM');

const BuyTokens = () => {
  const { connection } = useConnection();
  const wallet = useWallet();
  const [amount, setAmount] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');
  const [isWhitelisted, setIsWhitelisted] = useState(false);
  const [roundType, setRoundType] = useState(null);

  useEffect(() => {
    if (wallet.publicKey) {
      checkWhitelistStatus();
      checkRoundType();
    }
  }, [wallet.publicKey, connection]);

  const checkWhitelistStatus = async () => {
    if (!wallet.publicKey) return;

    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from("ico")],
        program.programId
      );
      const icoData = await program.account.icoAccount.fetch(icoAccount);
      setIsWhitelisted(icoData.seedInvestors.some(investor => investor.equals(wallet.publicKey)));
    } catch (err) {
      console.error('Error checking whitelist status:', err);
      setError('Failed to check whitelist status. Please try again.');
    }
  };

  const checkRoundType = async () => {
    if (!wallet.publicKey) return;

    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from("ico")],
        program.programId
      );
      const icoData = await program.account.icoAccount.fetch(icoAccount);
      setRoundType(Object.keys(icoData.roundType)[0]);
    } catch (err) {
      console.error('Error checking round type:', err);
      setError('Failed to check ICO round type. Please try again.');
    }
  };

  const handleBuyTokens = async (e) => {
    e.preventDefault();
    if (!wallet.publicKey || !wallet.signTransaction) {
      setError('Please connect your wallet');
      return;
    }

    
    if (roundType === 'SeedRound' && !isWhitelisted) {
      setError('You are not whitelisted for the Seed Round. Please contact the ICO administrator.');
      return;
    }

    setLoading(true);
    setError('');
    setSuccess('');

    try {
      const program = getProgram(connection, wallet);
      
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from("ico")],
        program.programId
      );

      const icoData = await program.account.icoAccount.fetch(icoAccount);
      const totalCost = new anchor.BN(amount).mul(icoData.tokenPrice);
      
      const balance = await connection.getBalance(wallet.publicKey);
      if (balance < totalCost.toNumber()) {
        throw new Error('Insufficient SOL balance');
      }

      const mint = new PublicKey(process.env.REACT_APP_TOKEN_MINT_ADDRESS);
      const buyerTokenAccount = await getAssociatedTokenAddress(mint, wallet.publicKey);

      let transaction = new Transaction();
      
      let buyerTokenAccountInfo;
      try {
        buyerTokenAccountInfo = await getAccount(connection, buyerTokenAccount);
      } catch (err) {
        transaction.add(
          createAssociatedTokenAccountInstruction(
            wallet.publicKey,
            buyerTokenAccount,
            wallet.publicKey,
            mint
          )
        );
      }

      const [purchaseAccount] = await PublicKey.findProgramAddress(
        [Buffer.from("purchase"), wallet.publicKey.toBuffer()],
        program.programId
      );

      const buyInstruction = await program.methods
        .buyTokens(new anchor.BN(amount))
        .accounts({
          buyer: wallet.publicKey,
          icoAccount: icoAccount,
          purchaseAccount: purchaseAccount,
          treasuryWallet: TREASURY_WALLET,
          tokenProgram: TOKEN_PROGRAM_ID,
          systemProgram: SystemProgram.programId,
        })
        .instruction();

      transaction.add(buyInstruction);

      const { blockhash } = await connection.getLatestBlockhash();
      transaction.recentBlockhash = blockhash;
      transaction.feePayer = wallet.publicKey;

      const signed = await wallet.signTransaction(transaction);
      const signature = await connection.sendRawTransaction(signed.serialize());
      
      const confirmation = await connection.confirmTransaction(signature, 'confirmed');
      
      if (confirmation.value.err) {
        throw new Error('Transaction failed to confirm');
      }

      setSuccess(`Transaction successful! Signature: ${signature}`);
      setAmount('');
    } catch (err) {
      console.error('Error buying tokens:', err);
      if (err.message.includes('0x1777') || err.message.includes('NotWhitelisted')) {
        setError('You are not whitelisted for the current round. Please contact the ICO administrator.');
      } else {
        setError(err.message || 'Failed to buy tokens. Please try again.');
      }
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="buy-tokens p-6 max-w-lg mx-auto">
      <h2 className="text-2xl font-bold mb-6">Buy Tokens</h2>
      {!wallet.connected ? (
        <div className="bg-yellow-50 border border-yellow-200 rounded p-4 text-yellow-800">
          Please connect your wallet to buy tokens
        </div>
      ) : (
        <>
          <div className="mb-4">
            <p>Current Round: {roundType || 'Loading...'}</p>
            <p>Whitelist Status: {isWhitelisted ? 'Whitelisted' : 'Not Whitelisted'}</p>
          </div>
          {roundType === 'SeedRound' && !isWhitelisted && (
            <div className="bg-yellow-50 border border-yellow-200 rounded p-4 text-yellow-800 mb-4">
              You are not whitelisted for the Seed Round. Please contact the ICO administrator to be added to the whitelist.
            </div>
          )}
          <form onSubmit={handleBuyTokens} className="space-y-4">
            <div className="space-y-2">
              <label htmlFor="amount" className="block text-sm font-medium">
                Amount of tokens:
              </label>
              <input
                type="number"
                id="amount"
                value={amount}
                onChange={(e) => setAmount(e.target.value)}
                placeholder="Enter number of tokens to buy"
                min="1"
                className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-purple-500"
                required
              />
            </div>
            <button
              type="submit"
              disabled={loading || !amount || Number(amount) <= 0 || (roundType === 'SeedRound' && !isWhitelisted)}
              className="w-full bg-purple-600 text-white py-2 px-4 rounded-md hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {loading ? 'Processing...' : 'Buy Tokens'}
            </button>
          </form>
        </>
      )}
      {error && (
        <div className="mt-4 p-4 bg-red-50 border border-red-200 rounded text-red-800">
          {error}
        </div>
      )}
      {success && (
        <div className="mt-4 p-4 bg-green-50 border border-green-200 rounded text-green-800">
          {success}
        </div>
      )}
    </div>
  );
};

export default BuyTokens;






src/pages/Dashboard.js



import React from 'react';
import IcoDetails from '../components/Icodetails';
import { Link } from 'react-router-dom';

import { Buffer } from "buffer";
window.Buffer = window.Buffer || Buffer;

const Dashboard = () => {
  return (
    <div className="dashboard">
      <h1>ICO Dashboard</h1>
      <IcoDetails />
      <div className="dashboard-actions">
        <Link to="/buy" className="button">Buy Tokens</Link>
        <Link to="/balance" className="button">Check Balance</Link>
      </div>
    </div>
  );
};

export default Dashboard;







src/pages/InitializeIco.js


import React, { useState } from 'react';
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { PublicKey } from '@solana/web3.js';
import { getProgram } from '../utils/anchor-connection';
import * as anchor from '@project-serum/anchor';

import { Buffer } from "buffer";
window.Buffer = window.Buffer || Buffer;

const InitializeIco = () => {
  const { connection } = useConnection();
  const wallet = useWallet();
  const [totalSupply, setTotalSupply] = useState('');
  const [tokenPrice, setTokenPrice] = useState('');
  const [startTime, setStartTime] = useState('');
  const [duration, setDuration] = useState('');
  const [roundType, setRoundType] = useState('SeedRound');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');

  const handleInitialize = async (e) => {
    e.preventDefault();
    if (!wallet.publicKey || !wallet.signTransaction) return;

    setLoading(true);
    setError('');
    setSuccess('');

    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from('ico')],
        program.programId
      );

      const mint = new PublicKey(process.env.REACT_APP_TOKEN_MINT_ADDRESS);

      const tx = await program.methods
        .initialize(
          new anchor.BN(totalSupply),
          new anchor.BN(tokenPrice),
          new anchor.BN(Math.floor(new Date(startTime).getTime() / 1000)),
          new anchor.BN(parseInt(duration) * 24 * 60 * 60),
          { [roundType]: {} }
        )
        .accounts({
          authority: wallet.publicKey,
          icoAccount,
          tokenMint: mint,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .rpc();

      setSuccess(`ICO initialized successfully! TxID: ${tx}`);
    } catch (err) {
      console.error('Error initializing ICO:', err);
      setError(`Error: ${err.message}`);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="initialize-ico">
      <h2>Initialize ICO</h2>
      <form onSubmit={handleInitialize}>
        <div className="form-group">
          <label htmlFor="totalSupply">Total Supply:</label>
          <input
            type="number"
            id="totalSupply"
            value={totalSupply}
            onChange={(e) => setTotalSupply(e.target.value)}
            required
          />
        </div>
        <div className="form-group">
          <label htmlFor="tokenPrice">Token Price (in lamports):</label>
          <input
            type="number"
            id="tokenPrice"
            value={tokenPrice}
            onChange={(e) => setTokenPrice(e.target.value)}
            required
          />
        </div>
        <div className="form-group">
          <label htmlFor="startTime">Start Time:</label>
          <input
            type="datetime-local"
            id="startTime"
            value={startTime}
            onChange={(e) => setStartTime(e.target.value)}
            required
          />
        </div>
        <div className="form-group">
          <label htmlFor="duration">Duration (in days):</label>
          <input
            type="number"
            id="duration"
            value={duration}
            onChange={(e) => setDuration(e.target.value)}
            required
          />
        </div>
        <div className="form-group">
          <label htmlFor="roundType">Round Type:</label>
          <select
            id="roundType"
            value={roundType}
            onChange={(e) => setRoundType(e.target.value)}
            required
          >
            <option value="SeedRound">Seed Round</option>
            <option value="PreICO">Pre-ICO</option>
            <option value="PublicICO">Public ICO</option>
          </select>
        </div>
        <button type="submit" disabled={loading}>
          {loading ? 'Initializing...' : 'Initialize ICO'}
        </button>
      </form>
      {error && <div className="error-message">{error}</div>}
      {success && <div className="success-message">{success}</div>}
    </div>
  );
};

export default InitializeIco;






src/pages/ManageInvestors.js



import React, { useState, useEffect } from 'react';
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { PublicKey } from '@solana/web3.js';
import { getProgram } from '../utils/anchor-connection';

import { Buffer } from "buffer";
window.Buffer = window.Buffer || Buffer;

const ManageInvestors = () => {
  const { connection } = useConnection();
  const wallet = useWallet();
  const [investors, setInvestors] = useState([]);
  const [newInvestor, setNewInvestor] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');

  useEffect(() => {
    fetchSeedInvestors();
  }, [connection, wallet.publicKey]);

  const fetchSeedInvestors = async () => {
    if (!wallet.publicKey) return;
    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from("ico")],
        program.programId
      );
      const icoData = await program.account.icoAccount.fetch(icoAccount);
      setInvestors(icoData.seedInvestors.map(investor => investor.toBase58()));
    } catch (err) {
      console.error('Error fetching seed investors:', err);
      setError('Failed to fetch seed investors');
    }
  };

  const handleAddInvestor = async (e) => {
    e.preventDefault();
    if (!wallet.publicKey || !wallet.signTransaction) return;

    setLoading(true);
    setError('');
    setSuccess('');

    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from("ico")],
        program.programId
      );

      await program.methods
        .addSeedInvestor(new PublicKey(newInvestor))
        .accounts({
          authority: wallet.publicKey,
          icoAccount,
        })
        .rpc();

      setSuccess(`Investor ${newInvestor} added successfully!`);
      setNewInvestor('');
      fetchSeedInvestors();
    } catch (err) {
      console.error('Error adding seed investor:', err);
      setError(`Error: ${err.message}`);
    } finally {
      setLoading(false);
    }
  };

  const handleRemoveInvestor = async (investorToRemove) => {
    if (!wallet.publicKey || !wallet.signTransaction) return;

    setLoading(true);
    setError('');
    setSuccess('');

    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from("ico")],
        program.programId
      );

      await program.methods
        .removeSeedInvestor(new PublicKey(investorToRemove))
        .accounts({
          authority: wallet.publicKey,
          icoAccount,
        })
        .rpc();

      setSuccess(`Investor ${investorToRemove} removed successfully!`);
      fetchSeedInvestors();
    } catch (err) {
      console.error('Error removing seed investor:', err);
      setError(`Error: ${err.message}`);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="manage-investors">
      <h2>Manage Seed Investors</h2>
      <form onSubmit={handleAddInvestor}>
        <div className="form-group">
          <label htmlFor="newInvestor">New Investor Address:</label>
          <input
            type="text"
            id="newInvestor"
            value={newInvestor}
            onChange={(e) => setNewInvestor(e.target.value)}
            placeholder="Enter Solana address"
            required
          />
        </div>
        <button type="submit" disabled={loading}>
          {loading ? 'Adding...' : 'Add Investor'}
        </button>
      </form>
      {error && <div className="error-message">{error}</div>}
      {success && <div className="success-message">{success}</div>}
      <h3>Current Seed Investors</h3>
      <ul className="investor-list">
        {investors.map((investor, index) => (
          <li key={index}>
            {investor}
            <button onClick={() => handleRemoveInvestor(investor)} disabled={loading}>
              Remove
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
};

export default ManageInvestors;







src/pages/TokenBalance.js




import React, { useState, useEffect } from 'react';
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { PublicKey } from '@solana/web3.js';
import {
  TOKEN_PROGRAM_ID,
  getAssociatedTokenAddress,
  getAccount,
} from '@solana/spl-token';
import { formatLamports } from '../utils/formatters';

import { Buffer } from "buffer";
window.Buffer = window.Buffer || Buffer;

const TokenBalance = () => {
  const { connection } = useConnection();
  const wallet = useWallet();
  const [balance, setBalance] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');

  useEffect(() => {
    const fetchTokenBalance = async () => {
      if (!wallet.publicKey) return;
      try {
        const mint = new PublicKey(process.env.REACT_APP_TOKEN_MINT_ADDRESS);
        const tokenAccount = await getAssociatedTokenAddress(mint, wallet.publicKey);
        const accountInfo = await getAccount(connection, tokenAccount);
        setBalance(accountInfo.amount.toString());
      } catch (err) {
        console.error('Error fetching token balance:', err);
        setError('Failed to fetch token balance');
      } finally {
        setLoading(false);
      }
    };

    fetchTokenBalance();
  }, [connection, wallet.publicKey]);

  if (loading) return <div>Loading token balance...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <div className="token-balance">
      <h2>Your Token Balance</h2>
      {balance !== null ? (
        <p>{formatLamports(balance)} tokens</p>
      ) : (
        <p>No balance available</p>
      )}
    </div>
  );
};

export default TokenBalance;







src/component/Footer.js

import React from 'react';

const Footer = () => {
  return (
    <footer className="footer">
      <p>&copy; 2024 Solana ICO. All rights reserved.</p>
    </footer>
  );
};

export default Footer;






src/component/Header.js


import React from 'react';
import { Link } from 'react-router-dom';
import { WalletMultiButton } from '@solana/wallet-adapter-react-ui';

const Header = () => {
  return (
    <header className="header">
      <div className="logo">
        <Link to="/">Solana ICO</Link>
      </div>
      <nav className="nav-links">
        <Link to="/">Dashboard</Link>
        <Link to="/initialize">Initialize ICO</Link>
        <Link to="/buy">Buy Tokens</Link>
        <Link to="/balance">Token Balance</Link>
        <Link to="/manage-whitelist">Manage Whitelist</Link>
      </nav>
      <WalletMultiButton />
    </header>
  );
};

export default Header;





src/components/IcoDetails.js



import React, { useState, useEffect } from 'react';
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { PublicKey } from '@solana/web3.js';
import { getProgram } from '../utils/anchor-connection';
import { formatUnixTimestamp, formatLamports } from '../utils/formatters';

const IcoDetails = () => {
  const { connection } = useConnection();
  const wallet = useWallet();
  const [icoDetails, setIcoDetails] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');

  useEffect(() => {
    const fetchIcoDetails = async () => {
      if (!wallet.publicKey) return;
      try {
        const program = getProgram(connection, wallet);
        const [icoAccount] = await PublicKey.findProgramAddress(
          [Buffer.from("ico")],
          program.programId
        );
        const icoData = await program.account.icoAccount.fetch(icoAccount);
        setIcoDetails({
          totalSupply: icoData.totalSupply.toString(),
          tokenPrice: icoData.tokenPrice.toString(),
          startTime: formatUnixTimestamp(icoData.startTime),
          endTime: formatUnixTimestamp(icoData.startTime.add(icoData.duration)),
          isActive: icoData.isActive,
          roundType: Object.keys(icoData.roundType)[0],
          tokensSold: icoData.tokensSold.toString(),
        });
      } catch (err) {
        console.error('Error fetching ICO details:', err);
        setError('Failed to fetch ICO details');
      } finally {
        setLoading(false);
      }
    };

    fetchIcoDetails();
  }, [connection, wallet.publicKey]);

  if (loading) return <div>Loading ICO details...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <div className="ico-details">
      <h2>ICO Details</h2>
      {icoDetails ? (
        <>
          <p>Total Supply: {formatLamports(icoDetails.totalSupply)} tokens</p>
          <p>Token Price: {formatLamports(icoDetails.tokenPrice)} SOL</p>
          <p>Start Time: {icoDetails.startTime}</p>
          <p>End Time: {icoDetails.endTime}</p>
          <p>Status: {icoDetails.isActive ? 'Active' : 'Inactive'}</p>
          <p>Round Type: {icoDetails.roundType}</p>
          <p>Tokens Sold: {formatLamports(icoDetails.tokensSold)}</p>
        </>
      ) : (
        <p>No ICO details available</p>
      )}
    </div>
  );
};

export default IcoDetails;




src/utils/anchor-connection.js


import { Connection, PublicKey } from '@solana/web3.js';
import { Program, AnchorProvider } from '@project-serum/anchor';
import idl from './ico-idl.json';

import { Buffer } from "buffer";
window.Buffer = window.Buffer || Buffer;

const programID = new PublicKey(process.env.REACT_APP_PROGRAM_ID);

export const getProgram = (connection, wallet) => {
  const provider = new AnchorProvider(connection, wallet, AnchorProvider.defaultOptions());
  return new Program(idl, programID, provider);
};




src/utils/formatters.js



import { LAMPORTS_PER_SOL } from '@solana/web3.js';

import { Buffer } from "buffer";
window.Buffer = window.Buffer || Buffer;

export const formatUnixTimestamp = (timestamp) => {
  return new Date(timestamp * 1000).toLocaleString();
};

export const formatLamports = (lamports) => {
  return (lamports / LAMPORTS_PER_SOL).toFixed(9);
};




src/App.js


import React from 'react';
import { BrowserRouter as Router, Route, Routes } from 'react-router-dom';
import { ConnectionProvider, WalletProvider } from '@solana/wallet-adapter-react';
import { WalletModalProvider } from '@solana/wallet-adapter-react-ui';
import { PhantomWalletAdapter } from '@solana/wallet-adapter-wallets';
import { clusterApiUrl } from '@solana/web3.js';
import Header from './components/Header';
import Footer from './components/Footer';
import Dashboard from './pages/Dashboard';
import InitializeIco from './pages/InitializeIco';
import BuyTokens from './pages/BuyTokens';
import TokenBalance from './pages/TokenBalance';
import ManageWhitelist from './pages/ManageWhitelist';
import '@solana/wallet-adapter-react-ui/styles.css';
import './App.css';

const network = clusterApiUrl('devnet');
const wallets = [new PhantomWalletAdapter()];

function App() {
  return (
    <ConnectionProvider endpoint={network}>
      <WalletProvider wallets={wallets} autoConnect>
        <WalletModalProvider>
          <Router>
            <div className="app">
              <Header />
              <main className="main-content">
                <Routes>
                  <Route path="/" element={<Dashboard />} />
                  <Route path="/initialize" element={<InitializeIco />} />
                  <Route path="/buy" element={<BuyTokens />} />
                  <Route path="/balance" element={<TokenBalance />} />
                  <Route path="/manage-whitelist" element={<ManageWhitelist />} />
                </Routes>
              </main>
              <Footer />
            </div>
          </Router>
        </WalletModalProvider>
      </WalletProvider>
    </ConnectionProvider>
  );
}

export default App;









So this are my all major files i created currently, and I also provide smart contract, now read the smart contract fully first then manage my entire reactjs files fully with maintaining the path,

and regenerate the full files and tell me the smart contract changes process also if needed (like what is buyer field should be in buytoken, IcoAccount, authority, treasureWallet, tokenAccount, buyerTokenAccount,tokenProgram and systemProgram in the input field)

after carefully read the smart contract modify the current reactJs files and regenerate the full files all without any missing (I also changes some functionality in my current smart contract and paste fully here, base on this smart contract create a full reactjs ICO project with standard UI and without errro and also tell me where should i add programID, contract Address, Token address, token Account and other things)

BTW i already deployed the smart contract fully in solpg(a browzer IDE) and have programID and idl.json file, so no need to generate that files just tell me the location

and remember base on the smart contract generate the all files fully and maintain in .js instead of .tsx and generate all files fully with the proper structure maintain



pub enum RoundType {
    SeedRound,
    PreICO,
    PublicICO,
}

and here total smart contract has 3 phase, so maintain the phase by first for "SeedRound", then complete "PreIco", and after that complete publicICO" phase and then generate the code fully











So this are my all major files and I also provide smart contract also, now read the smart contract and all react js file carefully and then solve the BuyTokenPage error and others files also if needed changes the others files also

and regenerate the full files and tell me the smart contract changes process also if needed (like what is buyer field should be in buytoken, IcoAccount, authority, treasureWallet, tokenAccount, buyerTokenAccount,tokenProgram and systemProgram in the input field)


after carefully read the smart contract modify the current reactJs files and regenerate the full files all without any missing (I also changes some functionality in my current smart contract and paste fully here, base on this smart contract create a full reactjs ICO project with standard UI and without errro and also tell me where should i add programID, contract Address, Token address, token Account and other things)
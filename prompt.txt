use anchor_lang::prelude::*;
use anchor_spl::{
    associated_token::AssociatedToken,
    token::{self, Mint, TokenAccount, Transfer},
};

declare_id!("56TcuGYiK1kU1iTr1XLCYV6a4PYT8o4rqzmqvQHdEFNE");

#[program]
pub mod advanced_ico_program {
    use super::*;

    // Initialize the ICO
    pub fn initialize(
        ctx: Context<Initialize>,
        total_supply: u64,
        token_price: u64,
        start_time: i64,
        duration: i64,
        round_type: RoundType,
    ) -> Result<()> {
        let ico = &mut ctx.accounts.ico_account;
        ico.authority = ctx.accounts.authority.key();
        ico.token_mint = ctx.accounts.token_mint.key();
        ico.total_supply = total_supply;
        ico.token_price = token_price;
        ico.start_time = start_time;
        ico.duration = duration;
        ico.tokens_sold = 0;
        ico.is_active = true;
        ico.round_type = round_type;
        ico.seed_investors = Vec::new();

        Ok(())
    }

    // Update ICO parameters
    pub fn update_ico_parameters(
        ctx: Context<UpdateIcoParameters>,
        total_supply: Option<u64>,
        token_price: Option<u64>,
        start_time: Option<i64>,
        duration: Option<i64>,
        round_type: Option<RoundType>,
    ) -> Result<()> {
        let ico = &mut ctx.accounts.ico_account;

        require!(
            ctx.accounts.authority.key() == ico.authority,
            IcoError::Unauthorized
        );

        if let Some(supply) = total_supply {
            ico.total_supply = supply;
        }

        if let Some(price) = token_price {
            ico.token_price = price;
        }

        if let Some(start) = start_time {
            ico.start_time = start;
        }

        if let Some(dur) = duration {
            ico.duration = dur;
        }

        if let Some(round) = round_type {
            ico.round_type = round;
        }

        Ok(())
    }

    // Add a seed investor to the whitelist
    pub fn add_seed_investor(ctx: Context<AddSeedInvestor>, investor: Pubkey) -> Result<()> {
        let ico = &mut ctx.accounts.ico_account;

        require!(
            ctx.accounts.authority.key() == ico.authority,
            IcoError::Unauthorized
        );

        ico.seed_investors.push(investor);

        Ok(())
    }

    // Remove a seed investor from the whitelist
    pub fn remove_seed_investor(ctx: Context<RemoveSeedInvestor>, investor: Pubkey) -> Result<()> {
        let ico = &mut ctx.accounts.ico_account;

        require!(
            ctx.accounts.authority.key() == ico.authority,
            IcoError::Unauthorized
        );

        if let Some(index) = ico.seed_investors.iter().position(|&x| x == investor) {
            ico.seed_investors.remove(index);
        }

        Ok(())
    }

    // Buy tokens during the ICO
    pub fn buy_tokens(ctx: Context<BuyTokens>, amount: u64) -> Result<()> {
        let current_time = Clock::get()?.unix_timestamp;
        let ico = &mut ctx.accounts.ico_account;

        require!(
            ico.is_active
                && current_time >= ico.start_time
                && current_time < ico.start_time + ico.duration,
            IcoError::IcoNotActive
        );

        if ico.round_type == RoundType::SeedRound {
            require!(
                ico.seed_investors.contains(&ctx.accounts.buyer.key()),
                IcoError::NotWhitelisted
            );
        }

        require!(
            ico.tokens_sold + amount <= ico.total_supply,
            IcoError::InsufficientTokens
        );

        let total_cost = amount
            .checked_mul(ico.token_price)
            .ok_or(IcoError::MathOverflow)?;

        let transfer_context = CpiContext::new(
            ctx.accounts.system_program.to_account_info(),
            anchor_lang::system_program::Transfer {
                from: ctx.accounts.buyer.to_account_info(),
                to: ctx.accounts.treasury_wallet.to_account_info(),
            },
        );
        anchor_lang::system_program::transfer(transfer_context, total_cost)?;

        let purchase = &mut ctx.accounts.purchase_account;
        purchase.buyer = ctx.accounts.buyer.key();
        purchase.amount = purchase
            .amount
            .checked_add(amount)
            .ok_or(IcoError::MathOverflow)?;
        purchase.is_distributed = false;

        ico.tokens_sold = ico
            .tokens_sold
            .checked_add(amount)
            .ok_or(IcoError::MathOverflow)?;

        emit!(TokenPurchaseEvent {
            buyer: ctx.accounts.buyer.key(),
            amount,
            price: ico.token_price,
            round_type: ico.round_type.clone(),
        });

        Ok(())
    }

    // Distribute tokens to buyers
    pub fn distribute_tokens(ctx: Context<DistributeTokens>) -> Result<()> {
        let ico = &mut ctx.accounts.ico_account;

        require!(!ico.is_active, IcoError::IcoStillActive);
        require!(ico.tokens_sold > 0, IcoError::InsufficientTokens);

        require!(
            ctx.accounts.authority.key() == ico.authority,
            IcoError::Unauthorized
        );

        let transfer_context = CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            Transfer {
                from: ctx.accounts.treasury_token_account.to_account_info(),
                to: ctx.accounts.buyer_token_account.to_account_info(),
                authority: ctx.accounts.authority.to_account_info(),
            },
        );

        token::transfer(transfer_context, ctx.accounts.purchase_account.amount)?;

        let purchase = &mut ctx.accounts.purchase_account;
        purchase.is_distributed = true;

        emit!(PurchaseEvent {
            buyer: purchase.buyer,
            amount: purchase.amount,
            is_distributed: true,
        });

        Ok(())
    }

    // End the ICO
    pub fn end_ico(ctx: Context<EndIco>) -> Result<()> {
        let ico = &mut ctx.accounts.ico_account;
        let current_time = Clock::get()?.unix_timestamp;

        require!(
            current_time >= ico.start_time + ico.duration,
            IcoError::IcoStillActive
        );

        ico.is_active = false;
        Ok(())
    }

    // Get seed investors (utility function)
    pub fn get_seed_investors(ctx: Context<GetSeedInvestors>) -> Result<()> {
        let ico = &ctx.accounts.ico_account;
        msg!("Number of seed investors: {}", ico.seed_investors.len());
        for (index, investor) in ico.seed_investors.iter().enumerate() {
            msg!("Seed Investor {}: {}", index + 1, investor);
        }

        Ok(())
    }
}
// Fundraising Round Types
#[derive(AnchorSerialize, AnchorDeserialize, Clone, PartialEq)]
pub enum RoundType {
    SeedRound,
    PreICO,
    PublicICO,
}

impl Default for RoundType {
    fn default() -> Self {
        RoundType::SeedRound
    }
}

// Events
#[event]
pub struct TokenPurchaseEvent {
    pub buyer: Pubkey,
    pub amount: u64,
    pub price: u64,
    pub round_type: RoundType,
}

#[event]
pub struct PurchaseEvent {
    pub buyer: Pubkey,
    pub amount: u64,
    pub is_distributed: bool,
}

// Purchase Account
#[account]
#[derive(Default)]
pub struct PurchaseAccount {
    pub buyer: Pubkey,
    pub amount: u64,
    pub is_distributed: bool,
}

// ICO Account
#[account]
#[derive(Default)]
pub struct IcoAccount {
    pub authority: Pubkey,
    pub token_mint: Pubkey,
    pub total_supply: u64,
    pub token_price: u64,
    pub tokens_sold: u64,
    pub start_time: i64,
    pub duration: i64,
    pub is_active: bool,
    pub round_type: RoundType,
    pub seed_investors: Vec<Pubkey>,
}

// Account Structs
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,
    #[account(
        init, 
        payer = authority, 
        space = 8 + 32 + 2 + 8 + 6 + 1 + 1 + 4 + (32 * 100),
        seeds = [b"ico"],
        bump
    )]
    pub ico_account: Account<'info, IcoAccount>,
    #[account(mut)]
    pub token_mint: Account<'info, Mint>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct UpdateIcoParameters<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,
    #[account(
        mut,
        seeds = [b"ico"],
        bump
    )]
    pub ico_account: Account<'info, IcoAccount>,
}

#[derive(Accounts)]
pub struct BuyTokens<'info> {
    #[account(mut)]
    pub buyer: Signer<'info>,
    #[account(
        mut,
        seeds = [b"ico"],
        bump
    )]
    pub ico_account: Account<'info, IcoAccount>,
    #[account(
        init_if_needed,
        payer = buyer, 
        space = 8 + 32 + 8 + 1,
        seeds = [b"purchase", buyer.key().as_ref()],
        bump
    )]
    pub purchase_account: Account<'info, PurchaseAccount>,
    #[account(mut)]
    pub treasury_wallet: SystemAccount<'info>,
    pub token_program: Program<'info, token::Token>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct DistributeTokens<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,
    #[account(
        mut,
        seeds = [b"ico"],
        bump
    )]
    pub ico_account: Account<'info, IcoAccount>,
    #[account(mut)]
    pub treasury_token_account: Account<'info, TokenAccount>,
    #[account(mut)]
    pub buyer_token_account: Account<'info, TokenAccount>,
    #[account(
        mut,
        seeds = [b"purchase", purchase_account.buyer.as_ref()],
        bump
    )]
    pub purchase_account: Account<'info, PurchaseAccount>,
    pub token_program: Program<'info, token::Token>,
}
#[derive(Accounts)]
pub struct EndIco<'info> {
    #[account(
        mut,
        seeds = [b"ico"],
        bump
    )]
    pub ico_account: Account<'info, IcoAccount>,
}

#[derive(Accounts)]
pub struct AddSeedInvestor<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,
    #[account(
        mut,
        seeds = [b"ico"],
        bump
    )]
    pub ico_account: Account<'info, IcoAccount>,
}

#[derive(Accounts)]
pub struct RemoveSeedInvestor<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,
    #[account(
        mut,
        seeds = [b"ico"],
        bump
    )]
    pub ico_account: Account<'info, IcoAccount>,
}

#[derive(Accounts)]
pub struct GetSeedInvestors<'info> {
    #[account(
        seeds = [b"ico"],
        bump
    )]
    pub ico_account: Account<'info, IcoAccount>,
}
#[error_code]
pub enum IcoError {
    #[msg("ICO is not currently active")]
    IcoNotActive,
    #[msg("Insufficient tokens remaining")]
    InsufficientTokens,
    #[msg("ICO is still active")]
    IcoStillActive,
    #[msg("You are not authorized to perform this action")]
    Unauthorized,
    #[msg("Purchase account not found")]
    PurchaseAccountNotFound,
    #[msg("Buyer token account not found")]
    BuyerTokenAccountNotFound,
    #[msg("Mathematical overflow occurred")]
    MathOverflow,
    #[msg("Investor is not whitelisted for the seed round")]
    NotWhitelisted,
}






Based on the smart contract i create this files in my reactjs project



src/pages/BuyTokens.js


import React, { useState, useEffect } from 'react';
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { PublicKey } from '@solana/web3.js';
import { getProgram } from '../utils/anchor-connection';
import * as anchor from '@project-serum/anchor';
import { TOKEN_PROGRAM_ID, getAssociatedTokenAddress } from '@solana/spl-token';

import { Buffer } from "buffer/"; 
window.Buffer = Buffer;

const BuyTokens = () => {
  const { connection } = useConnection();
  const wallet = useWallet();
  const [amount, setAmount] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');
  const [icoData, setIcoData] = useState(null);

  useEffect(() => {
    fetchIcoData();
  }, [connection, wallet.publicKey]);

  const fetchIcoData = async () => {
    if (!wallet.publicKey) return;
    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from('ico')],
        program.programId
      );
      const data = await program.account.icoAccount.fetch(icoAccount);
      setIcoData(data);
    } catch (err) {
      console.error('Error fetching ICO data:', err);
      setError('Failed to fetch ICO data');
    }
  };

  const handleBuyTokens = async (e) => {
    e.preventDefault();
    if (!wallet.publicKey || !wallet.signTransaction || !icoData) return;

    setLoading(true);
    setError('');
    setSuccess('');

    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from('ico')],
        program.programId
      );

      const mint = icoData.tokenMint;
      const treasuryWallet = icoData.authority;

      const buyerTokenAccount = await getAssociatedTokenAddress(mint, wallet.publicKey);
      const treasuryTokenAccount = await getAssociatedTokenAddress(mint, treasuryWallet);

      const [purchaseAccount] = await PublicKey.findProgramAddress(
        [Buffer.from('purchase'), wallet.publicKey.toBuffer()],
        program.programId
      );

      const tx = await program.methods
        .buyTokens(new anchor.BN(amount))
        .accounts({
          buyer: wallet.publicKey,
          icoAccount,
          purchaseAccount,
          buyerTokenAccount,
          treasuryTokenAccount,
          treasuryWallet,
          tokenMint: mint,
          tokenProgram: TOKEN_PROGRAM_ID,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .rpc();

      setSuccess(`Tokens purchased successfully! TxID: ${tx}`);
    } catch (err) {
      console.error('Error buying tokens:', err);
      setError(`Error: ${err.message}`);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="max-w-lg mx-auto">
      <div className="bg-white p-6 rounded-lg shadow">
        <h2 className="text-2xl font-semibold mb-6">Buy Tokens</h2>
        <form onSubmit={handleBuyTokens} className="space-y-4">
          <div>
            <label htmlFor="amount" className="block text-sm font-medium text-gray-700">
              Amount of tokens to buy:
            </label>
            <input
              type="number"
              id="amount"
              value={amount}
              onChange={(e) => setAmount(e.target.value)}
              className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"
              required
            />
          </div>
          <button
            type="submit"
            disabled={loading}
            className="w-full bg-black hover:bg-gray-800 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline"
          >
            {loading ? 'Buying...' : 'Buy Tokens'}
          </button>
        </form>
        {error && (
          <div className="mt-4 p-4 bg-red-50 border border-red-200 text-red-600 rounded-md text-sm">
            {error}
          </div>
        )}
        {success && (
          <div className="mt-4 p-4 bg-green-50 border border-green-200 text-green-600 rounded-md text-sm">
            {success}
          </div>
        )}
      </div>
    </div>
  );
};

export default BuyTokens;





src/pages/Dashboard.js


import React, { useState, useEffect } from 'react';
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { PublicKey } from '@solana/web3.js';
import { getProgram } from '../utils/anchor-connection';

import { Buffer } from "buffer/";
window.Buffer = Buffer;

const Dashboard = () => {
  const { connection } = useConnection();
  const wallet = useWallet();
  const [icoData, setIcoData] = useState(null);
  const [timeLeft, setTimeLeft] = useState(null);

  useEffect(() => {
    if (wallet.publicKey) {
      fetchIcoData();
    }
  }, [connection, wallet.publicKey]);

  useEffect(() => {
    if (icoData) {
      const timer = setInterval(() => {
        const now = Math.floor(Date.now() / 1000);
        const endTime = Number(icoData.startTime) + Number(icoData.duration);
        const remaining = endTime - now;
        
        if (remaining <= 0) {
          clearInterval(timer);
          setTimeLeft("ICO Ended");
        } else {
          const days = Math.floor(remaining / 86400);
          const hours = Math.floor((remaining % 86400) / 3600);
          const minutes = Math.floor((remaining % 3600) / 60);
          const seconds = remaining % 60;
          setTimeLeft(`${days}d ${hours}h ${minutes}m ${seconds}s`);
        }
      }, 1000);

      return () => clearInterval(timer);
    }
  }, [icoData]);

  const fetchIcoData = async () => {
    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from("ico")],
        program.programId
      );
      const data = await program.account.icoAccount.fetch(icoAccount);
      setIcoData(data);
    } catch (err) {
      console.error('Error:', err);
    }
  };

  if (!wallet.publicKey) {
    return (
      <div className="text-center py-12">
        Please connect your wallet to view ICO details.
      </div>
    );
  }

  if (!icoData) {
    return (
      <div className="text-center py-12">
        Loading ICO details...
      </div>
    );
  }

  const getEndTime = () => {
    try {
      const endTimeStamp = Number(icoData.startTime) + Number(icoData.duration);
      const endDate = new Date(endTimeStamp * 1000);
      return endDate.toLocaleDateString(undefined, {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: false
      });
    } catch (error) {
      console.error('Error calculating end time:', error);
      return 'Calculating...';
    }
  };

  return (
    <div className="space-y-6">
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div className="bg-blue-50/30 p-6 rounded-lg">
          <div className="flex items-center space-x-4">
            <div className="p-2 bg-blue-100/50 rounded-full">
              <svg className="h-10 w-10 text-blue-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
              </svg>
            </div>
            <div>
              <h3 className="text-sm font-medium text-blue-500">Total Supply</h3>
              <p className="text-2xl font-semibold text-gray-800">{icoData.totalSupply.toString()}</p>
              <span className="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-blue-100/50 text-blue-600">
                {Object.keys(icoData.roundType)[0]}
              </span>
            </div>
          </div>
        </div>

        <div className="bg-purple-50/30 p-6 rounded-lg">
          <div className="flex items-center space-x-4">
            <div className="p-2 bg-purple-100/50 rounded-full">
              <svg className="h-10 w-10 text-purple-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 7h6m0 10v-3m-3 3h.01M9 17h.01M9 14h.01M12 14h.01M15 11h.01M12 11h.01M9 11h.01M7 21h10a2 2 0 002-2V5a2 2 0 00-2-2H7a2 2 0 00-2 2v14a2 2 0 002 2z" />
              </svg>
            </div>
            <div>
              <h3 className="text-sm font-medium text-purple-500">Tokens Sold</h3>
              <p className="text-2xl font-semibold text-gray-800">{icoData.tokensSold.toString()}</p>
              <span className="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-purple-100/50 text-purple-600">
                {((Number(icoData.tokensSold) / Number(icoData.totalSupply)) * 100).toFixed(2)}%
              </span>
            </div>
          </div>
        </div>
      </div>

      <div>
        <h2 className="text-lg font-medium mb-4">Sale Progress</h2>
        <div className="bg-green-50/30 p-6 rounded-lg">
          <div className="space-y-4">
            <div>
              <div className="flex justify-between text-sm">
                <span>Tokens Sold</span>
                <span>{icoData.tokensSold.toString()} / {icoData.totalSupply.toString()}</span>
              </div>
              <div className="mt-2 h-2 bg-green-100/50 rounded-full overflow-hidden">
                <div 
                  className="h-full bg-green-500 rounded-full transition-all duration-500 ease-in-out"
                  style={{ 
                    width: `${(Number(icoData.tokensSold) / Number(icoData.totalSupply)) * 100}%`
                  }}
                />
              </div>
            </div>
          </div>
        </div>
      </div>

      <div>
        <h2 className="text-lg font-medium mb-4">ICO Details</h2>
        <div className="bg-amber-50/30 p-6 rounded-lg">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <p className="text-sm font-medium text-amber-600">Token Price</p>
              <p className="text-lg font-semibold text-gray-800">{icoData.tokenPrice.toString()} lamports</p>
            </div>
            <div>
              <p className="text-sm font-medium text-amber-600">Start Time</p>
              <p className="text-lg font-semibold text-gray-800">
                {new Date(Number(icoData.startTime) * 1000).toLocaleDateString(undefined, {
                  year: 'numeric',
                  month: '2-digit',
                  day: '2-digit',
                  hour: '2-digit',
                  minute: '2-digit',
                  second: '2-digit',
                  hour12: false
                })}
              </p>
            </div>
            <div>
              <p className="text-sm font-medium text-amber-600">End Time</p>
              <p className="text-lg font-semibold text-gray-800">
                {getEndTime()}
              </p>
              <p className="text-sm text-amber-600 mt-1">
                Time remaining: {timeLeft}
              </p>
            </div>
            <div>
              <p className="text-sm font-medium text-amber-600">Status</p>
              <p className="text-lg font-semibold">
                {icoData.isActive ? (
                  <span className="text-green-500">Active</span>
                ) : (
                  <span className="text-red-500">Inactive</span>
                )}
              </p>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default Dashboard;




src/pages/DistributeToken.js




import React, { useState, useEffect } from 'react';
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { PublicKey } from '@solana/web3.js';
import { getProgram } from '../utils/anchor-connection';
import { TOKEN_PROGRAM_ID, getAssociatedTokenAddress } from '@solana/spl-token';
// import { Card } from '@/components/ui/Card';
// import { Button } from '@/components/ui/Button';

import { Buffer } from "buffer/"; 
window.Buffer = Buffer;

const DistributeTokens = () => {
  const { connection } = useConnection();
  const wallet = useWallet();
  const [purchases, setPurchases] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');

  useEffect(() => {
    fetchPurchases();
  }, [connection, wallet.publicKey]);

  const fetchPurchases = async () => {
    if (!wallet.publicKey) return;
    try {
      const program = getProgram(connection, wallet);
      // Fetch all purchase accounts
      // This is a simplified example and may need to be adjusted based on your actual implementation
      const purchaseAccounts = await program.account.purchaseAccount.all();
      setPurchases(purchaseAccounts);
    } catch (err) {
      console.error('Error fetching purchases:', err);
      setError('Failed to fetch purchases');
    }
  };

  const handleDistributeTokens = async (purchase) => {
    if (!wallet.publicKey || !wallet.signTransaction) return;

    setLoading(true);
    setError('');
    setSuccess('');

    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from("ico")],
        program.programId
      );

      const icoData = await program.account.icoAccount.fetch(icoAccount);
      const mint = icoData.tokenMint;

      const treasuryTokenAccount = await getAssociatedTokenAddress(mint, wallet.publicKey);
      const buyerTokenAccount = await getAssociatedTokenAddress(mint, purchase.account.buyer);

      await program.methods
        .distributeTokens()
        .accounts({
          authority: wallet.publicKey,
          icoAccount,
          treasuryTokenAccount,
          buyerTokenAccount,
          purchaseAccount: purchase.publicKey,
          tokenProgram: TOKEN_PROGRAM_ID,
        })
        .rpc();

      setSuccess(`Tokens distributed successfully to ${purchase.account.buyer.toBase58()}`);
      fetchPurchases(); // Refresh the purchases list
    } catch (err) {
      console.error('Error distributing tokens:', err);
      setError(`Error: ${err.message}`);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="max-w-2xl mx-auto">
      <div className="p-6">
        <h2 className="text-2xl font-semibold mb-6">Distribute Tokens</h2>
        {error && (
          <div className="mb-4 p-4 bg-red-50 border border-red-200 text-red-600 rounded-md text-sm">
            {error}
          </div>
        )}
        {success && (
          <div className="mb-4 p-4 bg-green-50 border border-green-200 text-green-600 rounded-md text-sm">
            {success}
          </div>
        )}
        <ul className="space-y-4">
          {purchases.map((purchase, index) => (
            <li key={index} className="bg-white shadow-md rounded-lg p-4">
              <p className="font-semibold">Buyer: {purchase.account.buyer.toBase58()}</p>
              <p>Amount: {purchase.account.amount.toString()} tokens</p>
              <p>Distributed: {purchase.account.isDistributed ? 'Yes' : 'No'}</p>
              {!purchase.account.isDistributed && (
                <button
                  onClick={() => handleDistributeTokens(purchase)}
                  disabled={loading}
                  className="mt-2 bg-black hover:bg-gray-800 text-white"
                >
                  {loading ? 'Distributing...' : 'Distribute Tokens'}
                </button>
              )}
            </li>
          ))}
        </ul>
      </div>
    </div>
  );
};

export default DistributeTokens;





src/pages/EndIco.js



import React, { useState } from 'react';
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { PublicKey } from '@solana/web3.js';
import { getProgram } from '../utils/anchor-connection';

import { Buffer } from "buffer/"; 
window.Buffer = Buffer;

const EndIco = () => {
  const { connection } = useConnection();
  const wallet = useWallet();
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');

  const handleEndIco = async () => {
    if (!wallet.publicKey || !wallet.signTransaction) return;

    setLoading(true);
    setError('');
    setSuccess('');

    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from("ico")],
        program.programId
      );

      await program.methods
        .endIco()
        .accounts({
          icoAccount,
          authority: wallet.publicKey,
        })
        .rpc();

      setSuccess('ICO ended successfully!');
    } catch (err) {
      console.error('Error ending ICO:', err);
      setError(`Error: ${err.message}`);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="max-w-lg mx-auto">
      <div className="p-6">
        <h2 className="text-2xl font-semibold mb-6">End ICO</h2>
        <div className="space-y-4">
          <p className="text-red-600">
            Warning: This action will end the ICO and cannot be undone. Make sure all tokens have been distributed before ending the ICO.
          </p>
          <button
            onClick={handleEndIco}
            disabled={loading}
            className="w-full bg-red-600 hover:bg-red-700 text-white"
          >
            {loading ? 'Ending ICO...' : 'End ICO'}
          </button>
          {error && (
            <div className="p-4 bg-red-50 border border-red-200 text-red-600 rounded-md text-sm">
              {error}
            </div>
          )}
          {success && (
            <div className="p-4 bg-green-50 border border-green-200 text-green-600 rounded-md text-sm">
              {success}
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default EndIco;




src/pages/InitializeIco.js


import React, { useState } from 'react';
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { PublicKey } from '@solana/web3.js';
import { getProgram } from '../utils/anchor-connection';
import * as anchor from '@project-serum/anchor';

const InitializeIco = () => {
  const { connection } = useConnection();
  const wallet = useWallet();
  const [totalSupply, setTotalSupply] = useState('');
  const [tokenPrice, setTokenPrice] = useState('');
  const [startTime, setStartTime] = useState('');
  const [duration, setDuration] = useState('');
  const [roundType, setRoundType] = useState('SeedRound');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');

  const handleInitialize = async (e) => {
    e.preventDefault();
    if (!wallet.publicKey || !wallet.signTransaction) return;

    setLoading(true);
    setError('');
    setSuccess('');

    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from('ico')],
        program.programId
      );

      const mint = new PublicKey(process.env.REACT_APP_TOKEN_MINT_ADDRESS);

      const tx = await program.methods
        .initialize(
          new anchor.BN(totalSupply),
          new anchor.BN(tokenPrice),
          new anchor.BN(Math.floor(new Date(startTime).getTime() / 1000)),
          new anchor.BN(parseInt(duration) * 24 * 60 * 60),
          { [roundType]: {} }
        )
        .accounts({
          authority: wallet.publicKey,
          icoAccount,
          tokenMint: mint,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .rpc();

      setSuccess(`ICO initialized successfully! TxID: ${tx}`);
    } catch (err) {
      console.error('Error initializing ICO:', err);
      setError(`Error: ${err.message}`);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="container mx-auto px-4 py-8">
      <h2 className="text-2xl font-bold mb-6">Initialize ICO</h2>
      <form onSubmit={handleInitialize} className="space-y-4">
        <div>
          <label htmlFor="totalSupply" className="block text-sm font-medium text-gray-700">Total Supply:</label>
          <input
            type="number"
            id="totalSupply"
            value={totalSupply}
            onChange={(e) => setTotalSupply(e.target.value)}
            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2"
            required
          />
        </div>
        <div>
          <label htmlFor="tokenPrice" className="block text-sm font-medium text-gray-700">Token Price (in lamports):</label>
          <input
            type="number"
            id="tokenPrice"
            value={tokenPrice}
            onChange={(e) => setTokenPrice(e.target.value)}
            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2"
            required
          />
        </div>
        <div>
          <label htmlFor="startTime" className="block text-sm font-medium text-gray-700">Start Time:</label>
          <input
            type="datetime-local"
            id="startTime"
            value={startTime}
            onChange={(e) => setStartTime(e.target.value)}
            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2"
            required
          />
        </div>
        <div>
          <label htmlFor="duration" className="block text-sm font-medium text-gray-700">Duration (in days):</label>
          <input
            type="number"
            id="duration"
            value={duration}
            onChange={(e) => setDuration(e.target.value)}
            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2"
            required
          />
        </div>
        <div>
          <label htmlFor="roundType" className="block text-sm font-medium text-gray-700">Round Type:</label>
          <select
            id="roundType"
            value={roundType}
            onChange={(e) => setRoundType(e.target.value)}
            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2"
            required
          >
            <option value="SeedRound">Seed Round</option>
            <option value="PreICO">Pre-ICO</option>
            <option value="PublicICO">Public ICO</option>
          </select>
        </div>
        <button
          type="submit"
          disabled={loading}
          className="w-full bg-blue-500 text-white py-2 px-4 rounded-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:opacity-50"
        >
          {loading ? 'Initializing...' : 'Initialize ICO'}
        </button>
      </form>
      {error && <div className="mt-4 p-4 bg-red-100 border border-red-400 text-red-700 rounded">{error}</div>}
      {success && <div className="mt-4 p-4 bg-green-100 border border-green-400 text-green-700 rounded">{success}</div>}
    </div>
  );
};

export default InitializeIco;




src/pages/ManageInvestors.js



import React, { useState, useEffect } from 'react';
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { PublicKey } from '@solana/web3.js';
import { getProgram } from '../utils/anchor-connection';
// import { Card } from '@/components/ui/card';
// import { Input } from '@/components/ui/input';
// import { Button } from '@/components/ui/button';

import { Buffer } from "buffer/"; 
window.Buffer = Buffer;

const ManageInvestors = () => {
  const { connection } = useConnection();
  const wallet = useWallet();
  const [investors, setInvestors] = useState([]);
  const [newInvestor, setNewInvestor] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');

  useEffect(() => {
    fetchSeedInvestors();
  }, [connection, wallet.publicKey]);

  const fetchSeedInvestors = async () => {
    if (!wallet.publicKey) return;
    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from("ico")],
        program.programId
      );
      const icoData = await program.account.icoAccount.fetch(icoAccount);
      setInvestors(icoData.seedInvestors.map(investor => investor.toBase58()));
    } catch (err) {
      console.error('Error fetching seed investors:', err);
      setError('Failed to fetch seed investors');
    }
  };

  const handleAddInvestor = async (e) => {
    e.preventDefault();
    if (!wallet.publicKey || !wallet.signTransaction) return;

    setLoading(true);
    setError('');
    setSuccess('');

    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from("ico")],
        program.programId
      );

      await program.methods
        .addSeedInvestor(new PublicKey(newInvestor))
        .accounts({
          authority: wallet.publicKey,
          icoAccount,
        })
        .rpc();

      setSuccess(`Investor ${newInvestor} added successfully!`);
      setNewInvestor('');
      fetchSeedInvestors();
    } catch (err) {
      console.error('Error adding seed investor:', err);
      setError(`Error: ${err.message}`);
    } finally {
      setLoading(false);
    }
  };

  const handleRemoveInvestor = async (investorToRemove) => {
    if (!wallet.publicKey || !wallet.signTransaction) return;

    setLoading(true);
    setError('');
    setSuccess('');

    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from("ico")],
        program.programId
      );

      await program.methods
        .removeSeedInvestor(new PublicKey(investorToRemove))
        .accounts({
          authority: wallet.publicKey,
          icoAccount,
        })
        .rpc();

      setSuccess(`Investor ${investorToRemove} removed successfully!`);
      fetchSeedInvestors();
    } catch (err) {
      console.error('Error removing seed investor:', err);
      setError(`Error: ${err.message}`);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="max-w-2xl mx-auto">
      <div className="p-6">
        <h2 className="text-2xl font-semibold mb-6">Manage Seed Investors</h2>
        <form onSubmit={handleAddInvestor} className="mb-6">
          <div className="flex space-x-2">
            <input
              type="text"
              value={newInvestor}
              onChange={(e) => setNewInvestor(e.target.value)}
              placeholder="Enter Solana address"
              className="flex-grow"
              required
            />
            <button
              type="submit"
              disabled={loading}
              className="bg-black hover:bg-gray-800 text-white"
            >
              {loading ? 'Adding...' : 'Add Investor'}
            </button>
          </div>
        </form>
        {error && (
          <div className="mb-4 p-4 bg-red-50 border border-red-200 text-red-600 rounded-md text-sm">
            {error}
          </div>
        )}
        {success && (
          <div className="mb-4 p-4 bg-green-50 border border-green-200 text-green-600 rounded-md text-sm">
            {success}
          </div>
        )}
        <h3 className="text-xl font-semibold mb-4">Current Seed Investors</h3>
        <ul className="space-y-2">
          {investors.map((investor, index) => (
            <li key={index} className="flex justify-between items-center bg-gray-100 p-2 rounded">
              <span className="text-sm font-mono">{investor}</span>
              <button
                onClick={() => handleRemoveInvestor(investor)}
                disabled={loading}
                variant="destructive"
                size="sm"
              >
                Remove
              </button>
            </li>
          ))}
        </ul>
      </div>
    </div>
  );
};

export default ManageInvestors;





src/pages/TokenBalance.js



import React, { useState, useEffect } from 'react';
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { PublicKey } from '@solana/web3.js';
import {
  TOKEN_PROGRAM_ID,
  getAssociatedTokenAddress,
  getAccount,
} from '@solana/spl-token';
import { formatLamports } from '../utils/formatters';
import { getProgram } from '../utils/anchor-connection';

import { Buffer } from "buffer/"; 
window.Buffer = Buffer;

const TokenBalance = () => {
  const { connection } = useConnection();
  const wallet = useWallet();
  const [balance, setBalance] = useState(null);
  const [purchaseAmount, setPurchaseAmount] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');

  useEffect(() => {
    fetchTokenBalance();
  }, [connection, wallet.publicKey]);

  const fetchTokenBalance = async () => {
    if (!wallet.publicKey) return;
    setLoading(true);
    setError('');
    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from("ico")],
        program.programId
      );
      const icoData = await program.account.icoAccount.fetch(icoAccount);
      const mint = icoData.tokenMint;

      const tokenAccount = await getAssociatedTokenAddress(mint, wallet.publicKey);
      try {
        const accountInfo = await getAccount(connection, tokenAccount);
        setBalance(accountInfo.amount.toString());
      } catch (err) {
        console.log('No token account found, balance is 0');
        setBalance('0');
      }

      // Fetch purchase amount
      const [purchaseAccount] = await PublicKey.findProgramAddress(
        [Buffer.from("purchase"), wallet.publicKey.toBuffer()],
        program.programId
      );
      try {
        const purchaseData = await program.account.purchaseAccount.fetch(purchaseAccount);
        setPurchaseAmount(purchaseData.amount.toString());
      } catch (err) {
        console.log('No purchase found for this wallet');
        setPurchaseAmount('0');
      }
    } catch (err) {
      console.error('Error fetching token balance:', err);
      setError('Failed to fetch token balance');
    } finally {
      setLoading(false);
    }
  };

  if (loading) return <div className="text-center">Loading token balance...</div>;
  if (error) return <div className="text-center text-red-500">Error: {error}</div>;

  return (
    <div className="max-w-lg mx-auto">
      <div className="bg-white p-6 rounded-lg shadow">
        <h2 className="text-2xl font-semibold mb-6">Your Token Balance</h2>
        <div className="space-y-4">
          <div>
            <p className="text-sm font-medium text-gray-500">Current Balance:</p>
            <p className="text-2xl font-semibold">{formatLamports(balance)} tokens</p>
          </div>
          <div>
            <p className="text-sm font-medium text-gray-500">Total Purchased:</p>
            <p className="text-2xl font-semibold">{formatLamports(purchaseAmount)} tokens</p>
          </div>
          <button
            onClick={fetchTokenBalance}
            className="w-full bg-black hover:bg-gray-800 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline"
          >
            Refresh Balance
          </button>
        </div>
      </div>
    </div>
  );
};

export default TokenBalance;






src/pages/UpdateIcoParameter.js


import React, { useState, useEffect } from 'react';
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { PublicKey } from '@solana/web3.js';
import { getProgram } from '../utils/anchor-connection';
import * as anchor from '@project-serum/anchor';
import { getRoundTypeFromString, getRoundTypeString } from '../utils/enum-helpers';


import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '../components/ui/select'; 

import { Buffer } from "buffer/"; 
window.Buffer = Buffer;


const UpdateIcoParameters = () => {
  const { connection } = useConnection();
  const wallet = useWallet();
  const [totalSupply, setTotalSupply] = useState('');
  const [tokenPrice, setTokenPrice] = useState('');
  const [startTime, setStartTime] = useState('');
  const [duration, setDuration] = useState('');
  const [roundType, setRoundType] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');
  const [currentParameters, setCurrentParameters] = useState(null);

  useEffect(() => {
    fetchCurrentParameters();
  }, [connection, wallet.publicKey]);

  const fetchCurrentParameters = async () => {
    if (!wallet.publicKey) return;
    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from('ico')],
        program.programId
      );
      const icoData = await program.account.icoAccount.fetch(icoAccount);
      setCurrentParameters(icoData);
    } catch (err) {
      console.error('Error fetching current parameters:', err);
      setError('Failed to fetch current parameters');
    }
  };

  const handleUpdateParameters = async (e) => {
    e.preventDefault();
    if (!wallet.publicKey || !wallet.signTransaction) return;

    setLoading(true);
    setError('');
    setSuccess('');

    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from('ico')],
        program.programId
      );

      // Convert values to BN where needed and handle null cases
      const totalSupplyBN = totalSupply ? new anchor.BN(totalSupply) : null;
      const tokenPriceBN = tokenPrice ? new anchor.BN(tokenPrice) : null;
      const startTimeBN = startTime 
        ? new anchor.BN(Math.floor(new Date(startTime).getTime() / 1000))
        : null;
      const durationBN = duration 
        ? new anchor.BN(Math.floor(parseFloat(duration) * 24 * 60 * 60))
        : null;
      const roundTypeEnum = roundType ? getRoundTypeFromString(roundType) : null;

      const tx = await program.methods
        .updateIcoParameters(
          totalSupplyBN,
          tokenPriceBN,
          startTimeBN,
          durationBN,
          roundTypeEnum
        )
        .accounts({
          authority: wallet.publicKey,
          icoAccount,
        })
        .rpc();

      setSuccess(`ICO parameters updated successfully! TxID: ${tx}`);
      await fetchCurrentParameters();
      
      // Clear form after successful update
      setTotalSupply('');
      setTokenPrice('');
      setStartTime('');
      setDuration('');
      setRoundType('');
    } catch (err) {
      console.error('Error updating ICO parameters:', err);
      setError(`Error: ${err.message}`);
    } finally {
      setLoading(false);
    }
  };

  const formatDateTime = (timestamp) => {
    if (!timestamp) return '';
    return new Date(timestamp.toNumber() * 1000).toLocaleString();
  };

  return (
    <div className="max-w-2xl mx-auto">
      <div className="p-6">
        <h2 className="text-2xl font-semibold mb-6">Update ICO Parameters</h2>
        {currentParameters && (
          <div className="mb-6 p-4 bg-gray-100 rounded">
            <h3 className="text-lg font-semibold mb-2">Current Parameters:</h3>
            <p>Total Supply: {currentParameters.totalSupply.toString()}</p>
            <p>Token Price: {currentParameters.tokenPrice.toString()} lamports</p>
            <p>Start Time: {formatDateTime(currentParameters.startTime)}</p>
            <p>Duration: {(currentParameters.duration.toNumber() / (24 * 60 * 60)).toFixed(6)} days</p>
            <p>Round Type: {getRoundTypeString(currentParameters.roundType)}</p>
          </div>
        )}
        <form onSubmit={handleUpdateParameters} className="space-y-4">
          <div>
            <label htmlFor="totalSupply" className="block text-sm font-medium text-gray-700">
              Total Supply:
            </label>
            <input
              type="text"
              id="totalSupply"
              value={totalSupply}
              onChange={(e) => setTotalSupply(e.target.value)}
              placeholder="Leave blank to keep current value"
            />
          </div>
          <div>
            <label htmlFor="tokenPrice" className="block text-sm font-medium text-gray-700">
              Token Price (in lamports):
            </label>
            <input
              type="text"
              id="tokenPrice"
              value={tokenPrice}
              onChange={(e) => setTokenPrice(e.target.value)}
              placeholder="Leave blank to keep current value"
            />
          </div>
          <div>
            <label htmlFor="startTime" className="block text-sm font-medium text-gray-700">
              Start Time:
            </label>
            <input
              type="datetime-local"
              id="startTime"
              value={startTime}
              onChange={(e) => setStartTime(e.target.value)}
            />
          </div>
          <div>
            <label htmlFor="duration" className="block text-sm font-medium text-gray-700">
              Duration (in days):
            </label>
            <input
              type="number"
              id="duration"
              value={duration}
              onChange={(e) => setDuration(e.target.value)}
              step="0.000001"
              placeholder="Leave blank to keep current value"
            />
          </div>
          <div>
            <label htmlFor="roundType" className="block text-sm font-medium text-gray-700">
              Round Type:
            </label>
            <Select value={roundType} onValueChange={setRoundType}>
              <SelectTrigger>
                <SelectValue placeholder="Select to change round type" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="">Select to change round type</SelectItem>
                <SelectItem value="SeedRound">Seed Round</SelectItem>
                <SelectItem value="PreICO">Pre-ICO</SelectItem>
                <SelectItem value="PublicICO">Public ICO</SelectItem>
              </SelectContent>
            </Select>
          </div>
          <button
            type="submit"
            disabled={loading}
            className="w-full bg-black hover:bg-gray-800 text-white"
          >
            {loading ? 'Updating...' : 'Update ICO Parameters'}
          </button>
        </form>
        {error && (
          <div className="mt-4 p-4 bg-red-50 border border-red-200 text-red-600 rounded-md text-sm">
            {error}
          </div>
        )}
        {success && (
          <div className="mt-4 p-4 bg-green-50 border border-green-200 text-green-600 rounded-md text-sm">
            {success}
          </div>
        )}
      </div>
    </div>
  );
};

export default UpdateIcoParameters;


src/component/Footer.js


import React from 'react';

const Footer = () => {
  return (
    <footer className="bg-gray-800 text-white p-4 mt-8">
      <div className="container mx-auto text-center">
        <p>&copy; 2023 Solana ICO. All rights reserved.</p>
      </div>
    </footer>
  );
};

export default Footer;






src/component/Header.js



import React from 'react';
import { Link } from 'react-router-dom';
import { WalletMultiButton } from '@solana/wallet-adapter-react-ui';

const Header = () => {
  return (
    <header className="bg-gray-800 text-white p-4">
      <div className="container mx-auto flex justify-between items-center">
        <div className="text-xl font-bold">
          <Link to="/">Solana ICO</Link>
        </div>
        <nav className="space-x-4">
          <Link to="/" className="hover:text-gray-300">Dashboard</Link>
          <Link to="/buy" className="hover:text-gray-300">Buy Tokens</Link>
          <Link to="/balance" className="hover:text-gray-300">Balance</Link>
          <WalletMultiButton className="bg-blue-500 hover:bg-blue-600" />
        </nav>
      </div>
    </header>
  );
};

export default Header;








src/components/IcoDetails.js



import React, { useState, useEffect } from 'react';
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { PublicKey } from '@solana/web3.js';
import { getProgram } from '../utils/anchor-connection';
import { formatUnixTimestamp, formatLamports } from '../utils/formatters';

const IcoDetails = () => {
  const { connection } = useConnection();
  const wallet = useWallet();
  const [icoDetails, setIcoDetails] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');

  useEffect(() => {
    fetchIcoDetails();
  }, [connection, wallet.publicKey]);

  const fetchIcoDetails = async () => {
    if (!wallet.publicKey) {
      setLoading(false);
      setError('Please connect your wallet to view ICO details.');
      return;
    }
    setLoading(true);
    setError('');
    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from("ico")],
        program.programId
      );
      const icoData = await program.account.icoAccount.fetch(icoAccount);
      setIcoDetails({
        authority: icoData.authority.toString(),
        tokenMint: icoData.tokenMint.toString(),
        totalSupply: icoData.totalSupply.toString(),
        tokenPrice: icoData.tokenPrice.toString(),
        tokensSold: icoData.tokensSold.toString(),
        startTime: formatUnixTimestamp(icoData.startTime),
        duration: icoData.duration.toString(),
        isActive: icoData.isActive,
        roundType: Object.keys(icoData.roundType)[0],
        seedInvestors: icoData.seedInvestors.map(investor => investor.toString()),
      });
    } catch (err) {
      console.error('Error fetching ICO details:', err);
      setError('Failed to fetch ICO details. Please ensure the ICO has been initialized and try again.');
    } finally {
      setLoading(false);
    }
  };

  if (loading) return <div className="text-center">Loading ICO details...</div>;
  if (error) return <div className="text-center text-red-500">{error}</div>;
  if (!icoDetails) return <div className="text-center">No ICO details available. The ICO may not have been initialized yet.</div>;

  return (
    <div className="bg-white shadow-md rounded-lg p-6 mb-8">
      <h2 className="text-2xl font-bold mb-4">ICO Details</h2>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <p><span className="font-semibold">Authority:</span> {icoDetails.authority}</p>
        <p><span className="font-semibold">Token Mint:</span> {icoDetails.tokenMint}</p>
        <p><span className="font-semibold">Total Supply:</span> {formatLamports(icoDetails.totalSupply)} tokens</p>
        <p><span className="font-semibold">Token Price:</span> {formatLamports(icoDetails.tokenPrice)} SOL</p>
        <p><span className="font-semibold">Tokens Sold:</span> {formatLamports(icoDetails.tokensSold)}</p>
        <p><span className="font-semibold">Start Time:</span> {icoDetails.startTime}</p>
        <p><span className="font-semibold">Duration:</span> {icoDetails.duration} seconds</p>
        <p><span className="font-semibold">Status:</span> {icoDetails.isActive ? 'Active' : 'Inactive'}</p>
        <p><span className="font-semibold">Round Type:</span> {icoDetails.roundType}</p>
        <p><span className="font-semibold">Number of Seed Investors:</span> {icoDetails.seedInvestors.length}</p>
      </div>
    </div>
  );
};

export default IcoDetails;


src/components/Layout.js



import React from 'react';
import Navbar from './Navbar';
import Sidebar from './Sidebar';

const Layout = ({ children }) => {
  return (
    <div className="min-h-screen bg-gray-50">
      <Navbar />
      <Sidebar />
      <div className="md:pl-64">
        <main className="py-6">
          <div className="max-w-7xl mx-auto px-4 sm:px-6 md:px-8">{children}</div>
        </main>
      </div>
    </div>
  );
};

export default Layout;






src/components/Navbar.js




import React from 'react';
import { Link } from 'react-router-dom';
import { WalletMultiButton } from '@solana/wallet-adapter-react-ui';

const Navbar = () => {
  return (
    <nav className="bg-white border-b">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="flex justify-between h-16">
          <div className="flex">
            <div className="flex-shrink-0 flex items-center ">
              <img
                className="h-8 w-8 rounded-full"
                src="/placeholder.svg?height=32&width=32"
                alt="Logo"
              />
              <span className="ml-2 text-xl font-semibold ">ICO Dashboard</span>
            </div>
          </div>

          <div className="hidden md:flex md:items-center md:space-x-4">
            <Link
              to="/buy"
              className="text-gray-700 hover:text-gray-900 px-3 py-2 rounded-md text-sm font-medium"
            >
              Buy Tokens
            </Link>
            <Link
              to="/balance"
              className="text-gray-700 hover:text-gray-900 px-3 py-2 rounded-md text-sm font-medium"
            >
              Token Balance
            </Link>
            <div className="relative ml-4">
              <WalletMultiButton className="!bg-purple-600 hover:!bg-purple-700" />
            </div>
          </div>
        </div>
      </div>
    </nav>
  );
};

export default Navbar;







src/components/Sidebar.js






import React from 'react';
import { Link, useLocation } from 'react-router-dom';
import { useWallet } from '@solana/wallet-adapter-react';
import { isAdminWallet } from '../utils/admin-check';

const Sidebar = () => {
  const location = useLocation();
  const { publicKey } = useWallet();

  const navigation = [
    { name: 'Dashboard', href: '/', icon: 'M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6' },
    { name: 'Buy Tokens', href: '/buy', icon: 'M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z' },
    { name: 'Token Balance', href: '/balance', icon: 'M9 7h6m0 10v-3m-3 3h.01M9 17h.01M9 14h.01M12 14h.01M15 11h.01M12 11h.01M9 11h.01M7 21h10a2 2 0 002-2V5a2 2 0 00-2-2H7a2 2 0 00-2 2v14a2 2 0 002 2z' },
  ];

  const adminNavigation = [
    { name: 'Manage Investors', href: '/manage-investors', icon: 'M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z' },
    { name: 'Update ICO Parameters', href: '/update-parameters', icon: 'M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z' },
    { name: 'Distribute Tokens', href: '/distribute-tokens', icon: 'M8 7h12m0 0l-4-4m4 4l-4 4m0 6H4m0 0l4 4m-4-4l4-4' },
    { name: 'End ICO', href: '/end-ico', icon: 'M13 10V3L4 14h7v7l9-11h-7z' },
  ];

  return (
    <div className="hidden md:flex md:flex-col md:w-64 md:fixed md:inset-y-0 bg-white border-r">
      <div className="flex flex-col flex-1 min-h-0 overflow-y-auto">
        <nav className="flex-1 px-2 py-4 space-y-1">
          {navigation.map((item) => (
            <Link
              key={item.name}
              to={item.href}
              className={`${
                location.pathname === item.href
                  ? 'bg-gray-100 text-gray-900'
                  : 'text-gray-600 hover:bg-gray-50 hover:text-gray-900'
              } group flex items-center px-2 py-2 text-sm font-medium rounded-md`}
            >
              <svg
                className={`${
                  location.pathname === item.href ? 'text-gray-500' : 'text-gray-400 group-hover:text-gray-500'
                } mr-3 flex-shrink-0 h-6 w-6`}
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                viewBox="0 0 24 24"
                stroke="currentColor"
                aria-hidden="true"
              >
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d={item.icon} />
              </svg>
              {item.name}
            </Link>
          ))}

          {isAdminWallet(publicKey) && (
            <>
              <div className="mt-8 mb-2 px-2 text-xs font-semibold text-gray-500 uppercase tracking-wider">
                ADMIN
              </div>
              {adminNavigation.map((item) => (
                <Link
                  key={item.name}
                  to={item.href}
                  className={`${
                    location.pathname === item.href
                      ? 'bg-gray-100 text-gray-900'
                      : 'text-gray-600 hover:bg-gray-50 hover:text-gray-900'
                  } group flex items-center px-2 py-2 text-sm font-medium rounded-md`}
                >
                  <svg
                    className={`${
                      location.pathname === item.href ? 'text-gray-500' : 'text-gray-400 group-hover:text-gray-500'
                    } mr-3 flex-shrink-0 h-6 w-6`}
                    xmlns="http://www.w3.org/2000/svg"
                    fill="none"
                    viewBox="0 0 24 24"
                    stroke="currentColor"
                    aria-hidden="true"
                  >
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d={item.icon} />
                  </svg>
                  {item.name}
                </Link>
              ))}
            </>
          )}
        </nav>
      </div>
    </div>
  );
};

export default Sidebar;






src/utils/admin-check.js



export const isAdminWallet = (publicKey) => {
  const adminAddress = process.env.REACT_APP_OWNER_ADDRESS;
  return publicKey && publicKey.toBase58() === adminAddress;
};





src/utils/anchor-connection.js


import { Connection, PublicKey } from '@solana/web3.js';
import { Program, AnchorProvider } from '@project-serum/anchor';
import idl from './ico-idl.json';

const programID = new PublicKey(process.env.REACT_APP_PROGRAM_ID);

export const getProgram = (connection, wallet) => {
  if (!connection || !wallet) {
    throw new Error('Connection and wallet are required to get the program');
  }
  
  const provider = new AnchorProvider(
    connection,
    wallet,
    AnchorProvider.defaultOptions()
  );
  
  return new Program(idl, programID, provider);
};


src/utils/enum-helpers.js


export const RoundType = {
  SeedRound: { seedRound: {} },
  PreICO: { preIco: {} },
  PublicICO: { publicIco: {} }
};

export const getRoundTypeFromString = (roundTypeStr) => {
  switch (roundTypeStr) {
    case 'SeedRound':
      return RoundType.SeedRound;
    case 'PreICO':
      return RoundType.PreICO;
    case 'PublicICO':
      return RoundType.PublicICO;
    default:
      return null;
  }
};

export const getRoundTypeString = (roundType) => {
  if (roundType.seedRound) return 'SeedRound';
  if (roundType.preIco) return 'PreICO';
  if (roundType.publicIco) return 'PublicICO';
  return 'Unknown';
};





src/utils/formatters.js


import { LAMPORTS_PER_SOL } from '@solana/web3.js';

export const formatUnixTimestamp = (timestamp) => {
  return new Date(timestamp * 1000).toLocaleString();
};

export const formatLamports = (lamports) => {
  return (lamports / LAMPORTS_PER_SOL).toFixed(9);
};





src/App.js



import React, { useMemo } from 'react';
import { BrowserRouter as Router, Route, Routes, Navigate } from 'react-router-dom';
import { ConnectionProvider, useWallet, WalletProvider } from '@solana/wallet-adapter-react';
import { WalletAdapterNetwork } from '@solana/wallet-adapter-base';
import { PhantomWalletAdapter } from '@solana/wallet-adapter-wallets';
import { WalletModalProvider } from '@solana/wallet-adapter-react-ui';
import { clusterApiUrl } from '@solana/web3.js';
import Layout from './components/Layout';
import Dashboard from './pages/Dashboard';
import BuyTokens from './pages/BuyTokens';
import TokenBalance from './pages/TokenBalance';
import ManageInvestors from './pages/ManageInvestors';
import UpdateIcoParameters from './pages/UpdateIcoParameters';
import DistributeTokens from './pages/DistributeTokens';
import EndIco from './pages/EndIco';
import { isAdminWallet } from './utils/admin-check';
import '@solana/wallet-adapter-react-ui/styles.css';
import './App.css';

const AdminRoute = ({ children }) => {
  const { publicKey } = useWallet();
  return isAdminWallet(publicKey) ? children : <Navigate to="/" />;
};

function App() {
  const network = WalletAdapterNetwork.Devnet;
  const endpoint = useMemo(() => clusterApiUrl(network), [network]);
  const wallets = useMemo(() => [new PhantomWalletAdapter()], []);

  return (
    <ConnectionProvider endpoint={endpoint}>
      <WalletProvider wallets={wallets} autoConnect>
        <WalletModalProvider>
          <Router>
            <Layout>
              <Routes>
                <Route path="/" element={<Dashboard />} />
                <Route path="/buy" element={<BuyTokens />} />
                <Route path="/balance" element={<TokenBalance />} />
                <Route path="/manage-investors" element={<AdminRoute><ManageInvestors /></AdminRoute>} />
                <Route path="/update-parameters" element={<AdminRoute><UpdateIcoParameters /></AdminRoute>} />
                <Route path="/distribute-tokens" element={<AdminRoute><DistributeTokens /></AdminRoute>} />
                <Route path="/end-ico" element={<AdminRoute><EndIco /></AdminRoute>} />
              </Routes>
            </Layout>
          </Router>
        </WalletModalProvider>
      </WalletProvider>
    </ConnectionProvider>
  );
}

export default App;





src/index.js



import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

reportWebVitals();




.env 



REACT_APP_PROGRAM_ID=56TcuGYiK1kU1iTr1XLCYV6a4PYT8o4rqzmqvQHdEFNE
REACT_APP_TOKEN_MINT_ADDRESS=7GYz5XMx5BQrMtexJZrrJQM1WfhHnWAmf8Snhaqqmf3U
REACT_APP_OWNER_ADDRESS=DYkCAokwibanNxMvixmoZFQDwayGDJWfJ9moZjDRpUvW
REACT_APP_NETWORK=devnet






BTW my current owner wallet address is    "DYkCAokwibanNxMvixmoZFQDwayGDJWfJ9moZjDRpUvW"





So this are my all major files i created currently, and I also provide smart contract, now read the smart contract fully first then manage my entire reactjs files fully with maintaining the path,

and regenerate the full files and tell me the smart contract changes process also if needed (like what is buyer field should be in buytoken, IcoAccount, authority, treasureWallet, tokenAccount, buyerTokenAccount,tokenProgram and systemProgram in the input field)

after carefully read the smart contract modify the current reactJs files and regenerate the full files all without any missing (I also changes some functionality in my current smart contract and paste fully here, base on this smart contract create a full reactjs ICO project with standard UI and without errro and also tell me where should i add programID, contract Address, Token address, token Account and other things)

BTW i already deployed the smart contract fully in solpg(a browzer IDE) and have programID and idl.json file, so no need to generate that files just tell me the location

and remember base on the smart contract generate the all files fully and maintain in .js instead of .tsx and generate all files fully with the proper structure maintain

pub enum RoundType {
    SeedRound,
    PreICO,
    PublicICO,
}

and here total smart contract has 3 phase, so maintain the phase by first for "SeedRound", then complete "PreIco", and after that complete publicICO" phase and then generate the code fully

So this are my all major files and I also provide smart contract also, now read the smart contract and all react js file carefully and then solve the BuyTokenPage error and others files also if needed changes the others files also

and regenerate the full files and tell me the smart contract changes process also if needed (like what is buyer field should be in buytoken, IcoAccount, authority, treasureWallet, tokenAccount, buyerTokenAccount,tokenProgram and systemProgram in the input field)


after carefully read the smart contract modify the current reactJs files and regenerate the full files all without any missing (I also changes some functionality in my current smart contract and paste fully here, base on this smart contract create a full reactjs ICO project with standard UI and without errro and also tell me where should i add programID, contract Address, Token address, token Account and other things)
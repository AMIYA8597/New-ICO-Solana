this is my ICO COntract


use anchor_lang::prelude::*;
use anchor_spl::token::{self, Mint, TokenAccount};

declare_id!("ytBPKYRmAkHitGt6jsiV4jWot19tZzfnXnRud42gzxm");

#[program]
pub mod advanced_ico_program {
    use super::*;

    pub fn initialize(
        ctx: Context<Initialize>,
        total_supply: u64,
        seed_price: u64,
        pre_ico_price: u64,
        public_price: u64,
        start_time: i64,
        duration: i64,
        pre_ico_round_deadline: i64,
    ) -> Result<()> {
        let ico = &mut ctx.accounts.ico_account;
        ico.authority = ctx.accounts.authority.key();
        ico.token_mint = ctx.accounts.token_mint.key();
        ico.total_supply = total_supply;
        ico.seed_price = seed_price;
        ico.pre_ico_price = pre_ico_price;
        ico.public_price = public_price;
        ico.current_public_price = pre_ico_price;
        ico.start_time = start_time;
        ico.duration = duration;
        ico.pre_ico_round_deadline = pre_ico_round_deadline;
        ico.tokens_sold = 0;
        ico.seed_tokens_sold = 0;
        ico.public_tokens_sold = 0;
        ico.is_active = true;
        ico.round_type = RoundType::PreICO;
        ico.seed_investors = Vec::new();
        ico.total_investors = 0;
        ico.purchase_counter = 0;

        ico.seed_round_allocation = total_supply
            .checked_mul(5)
            .ok_or(IcoError::MathOverflow)?
            .checked_div(1000)
            .ok_or(IcoError::MathOverflow)?;

        ico.pre_ico_allocation = total_supply
            .checked_mul(15)
            .ok_or(IcoError::MathOverflow)?
            .checked_div(1000)
            .ok_or(IcoError::MathOverflow)?;

        ico.public_round_allocation = total_supply
            .checked_mul(111)
            .ok_or(IcoError::MathOverflow)?
            .checked_div(10000)
            .ok_or(IcoError::MathOverflow)?;

        Ok(())
    }

    pub fn update_initialize(
        ctx: Context<UpdateInitialize>,
        total_supply: Option<u64>,
        seed_price: Option<u64>,
        pre_ico_price: Option<u64>,
        public_price: Option<u64>,
        start_time: Option<i64>,
        duration: Option<i64>,
        pre_ico_round_deadline: Option<i64>,
    ) -> Result<()> {
        let ico = &mut ctx.accounts.ico_account;
        require!(
            ctx.accounts.authority.key() == ico.authority,
            IcoError::Unauthorized
        );

        if let Some(total_supply) = total_supply {
            ico.total_supply = total_supply;
            ico.seed_round_allocation = total_supply
                .checked_mul(5)
                .ok_or(IcoError::MathOverflow)?
                .checked_div(1000)
                .ok_or(IcoError::MathOverflow)?;

            ico.pre_ico_allocation = total_supply
                .checked_mul(15)
                .ok_or(IcoError::MathOverflow)?
                .checked_div(1000)
                .ok_or(IcoError::MathOverflow)?;

            ico.public_round_allocation = total_supply
                .checked_mul(111)
                .ok_or(IcoError::MathOverflow)?
                .checked_div(10000)
                .ok_or(IcoError::MathOverflow)?;
        }
        if let Some(seed_price) = seed_price {
            ico.seed_price = seed_price;
        }
        if let Some(pre_ico_price) = pre_ico_price {
            ico.pre_ico_price = pre_ico_price;
            ico.current_public_price = pre_ico_price;
        }
        if let Some(public_price) = public_price {
            ico.public_price = public_price;
        }
        if let Some(start_time) = start_time {
            ico.start_time = start_time;
        }
        if let Some(duration) = duration {
            ico.duration = duration;
        }
        if let Some(pre_ico_round_deadline) = pre_ico_round_deadline {
            ico.pre_ico_round_deadline = pre_ico_round_deadline;
        }

        Ok(())
    }

    pub fn add_seed_investor(ctx: Context<AddSeedInvestor>, investor: Pubkey) -> Result<()> {
        let ico = &mut ctx.accounts.ico_account;
        require!(
            ctx.accounts.authority.key() == ico.authority,
            IcoError::Unauthorized
        );
        require!(
            !ico.seed_investors.contains(&investor),
            IcoError::InvestorAlreadyExists
        );

        ico.seed_investors.push(investor);
        Ok(())
    }

    pub fn remove_seed_investor(ctx: Context<RemoveSeedInvestor>, investor: Pubkey) -> Result<()> {
        let ico = &mut ctx.accounts.ico_account;
        require!(
            ctx.accounts.authority.key() == ico.authority,
            IcoError::Unauthorized
        );
        if let Some(index) = ico.seed_investors.iter().position(|&x| x == investor) {
            ico.seed_investors.remove(index);
        }
        Ok(())
    }

    pub fn update_round(ctx: Context<UpdateRound>, new_round: RoundType) -> Result<()> {
        let ico = &mut ctx.accounts.ico_account;
        require!(
            ctx.accounts.authority.key() == ico.authority,
            IcoError::Unauthorized
        );

        match new_round {
            RoundType::PreICO => {
                ico.round_type = RoundType::PreICO;
                ico.current_public_price = ico.pre_ico_price;
            }
            RoundType::PublicICO => {
                ico.round_type = RoundType::PublicICO;
                ico.current_public_price = ico.public_price;
            }
        }

        emit!(RoundUpdateEvent {
            round: new_round,
            timestamp: Clock::get()?.unix_timestamp,
        });

        Ok(())
    }

    pub fn buy_tokens(ctx: Context<BuyTokens>, amount: u64) -> Result<()> {
        let current_time = Clock::get()?.unix_timestamp;
        let ico = &mut ctx.accounts.ico_account;

        require!(
            ico.is_active
                && current_time >= ico.start_time
                && current_time < ico.start_time + ico.duration,
            IcoError::IcoNotActive
        );

        let (price, allocation_limit) = if ico.seed_investors.contains(&ctx.accounts.buyer.key()) {
            (
                ico.seed_price,
                ico.seed_round_allocation
                    .checked_sub(ico.seed_tokens_sold)
                    .ok_or(IcoError::MathOverflow)?,
            )
        } else {
            let pre_ico_round_end_time = ico.start_time + ico.pre_ico_round_deadline;
            let public_ico_round_end_time = pre_ico_round_end_time + ico.duration;

            ico.round_type = if current_time < pre_ico_round_end_time {
                RoundType::PreICO
            } else if current_time >= pre_ico_round_end_time
                && current_time < public_ico_round_end_time
            {
                RoundType::PublicICO
            } else {
                return Err(IcoError::NoMoreRounds.into());
            };

            // Set price and allocation limit based on the round type
            let (price, current_public_allocation) = match ico.round_type {
                RoundType::PreICO => (ico.pre_ico_price, ico.pre_ico_allocation),
                RoundType::PublicICO => (ico.public_price, ico.public_round_allocation),
            };

            let allocation_limit = current_public_allocation
                .checked_sub(ico.public_tokens_sold)
                .ok_or(IcoError::MathOverflow)?;

            (price, allocation_limit)
        };

        require!(
            amount <= allocation_limit,
            IcoError::RoundAllocationExceeded
        );

        let total_cost = amount.checked_mul(price).ok_or(IcoError::MathOverflow)?;

        let transfer_context = CpiContext::new(
            ctx.accounts.system_program.to_account_info(),
            anchor_lang::system_program::Transfer {
                from: ctx.accounts.buyer.to_account_info(),
                to: ctx.accounts.treasury_wallet.to_account_info(),
            },
        );
        anchor_lang::system_program::transfer(transfer_context, total_cost)?;

        let purchase = &mut ctx.accounts.purchase_account;
        purchase.buyer = ctx.accounts.buyer.key();
        purchase.amount = amount;
        purchase.is_distributed = false;
        purchase.timestamp = current_time;
        purchase.ico = ico.key();
        purchase.purchase_price = price;
        purchase.round = ico.round_type;

        // Store the counter value from ico_account before incrementing
        purchase.counter = ico.purchase_counter;

        if ico.seed_investors.contains(&ctx.accounts.buyer.key()) {
            ico.seed_tokens_sold = ico
                .seed_tokens_sold
                .checked_add(amount)
                .ok_or(IcoError::MathOverflow)?;
        } else {
            ico.public_tokens_sold = ico
                .public_tokens_sold
                .checked_add(amount)
                .ok_or(IcoError::MathOverflow)?;
        }

        ico.tokens_sold = ico
            .tokens_sold
            .checked_add(amount)
            .ok_or(IcoError::MathOverflow)?;

        ico.purchase_counter = ico
            .purchase_counter
            .checked_add(1)
            .ok_or(IcoError::MathOverflow)?;

        ico.total_investors = ico
            .total_investors
            .checked_add(1)
            .ok_or(IcoError::MathOverflow)?;

        emit!(TokenPurchaseEvent {
            buyer: ctx.accounts.buyer.key(),
            amount,
            price,
            is_seed_round: ico.seed_investors.contains(&ctx.accounts.buyer.key()),
            round: ico.round_type,
            timestamp: current_time,
        });

        Ok(())
    }

    pub fn distribute_tokens(ctx: Context<DistributeTokens>) -> Result<()> {
        let purchase = &mut ctx.accounts.purchase_account;

        require!(!purchase.is_distributed, IcoError::AlreadyDistributed);

        let transfer_ctx = CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            token::Transfer {
                from: ctx.accounts.treasury_token_account.to_account_info(),
                to: ctx.accounts.buyer_token_account.to_account_info(),
                authority: ctx.accounts.authority.to_account_info(),
            },
        );

        token::transfer(transfer_ctx, purchase.amount)?;

        purchase.is_distributed = true;

        emit!(TokenDistributionEvent {
            buyer: purchase.buyer,
            amount: purchase.amount,
            round: purchase.round,
        });

        Ok(())
    }

    pub fn end_ico(ctx: Context<EndIco>) -> Result<()> {
        let ico = &mut ctx.accounts.ico_account;
        let current_time = Clock::get()?.unix_timestamp;
        require!(
            current_time >= ico.start_time + ico.duration,
            IcoError::IcoStillActive
        );
        ico.is_active = false;
        Ok(())
    }
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, PartialEq, Copy)]
pub enum RoundType {
    PreICO,
    PublicICO,
}

#[event]
pub struct TokenPurchaseEvent {
    pub buyer: Pubkey,
    pub amount: u64,
    pub price: u64,
    pub is_seed_round: bool,
    pub round: RoundType,
    pub timestamp: i64,
}

#[event]
pub struct TokenDistributionEvent {
    pub buyer: Pubkey,
    pub amount: u64,
    pub round: RoundType,
}

#[event]
pub struct RoundUpdateEvent {
    pub round: RoundType,
    pub timestamp: i64,
}

#[account]
#[derive(Default)]
pub struct IcoAccount {
    pub authority: Pubkey,            // 32
    pub token_mint: Pubkey,           // 32
    pub total_supply: u64,            // 8
    pub seed_price: u64,              // 8
    pub pre_ico_price: u64,           // 8
    pub public_price: u64,            // 8
    pub current_public_price: u64,    // 8
    pub tokens_sold: u64,             // 8
    pub seed_tokens_sold: u64,        // 8
    pub public_tokens_sold: u64,      // 8
    pub start_time: i64,              // 8
    pub duration: i64,                // 8
    pub pre_ico_round_deadline: i64,  // 8
    pub is_active: bool,              // 1
    pub round_type: RoundType,        // 1
    pub seed_investors: Vec<Pubkey>,  // 4 + (32 * n)
    pub total_investors: u64,         // 8
    pub purchase_counter: u64,        // 8
    pub seed_round_allocation: u64,   // 8
    pub pre_ico_allocation: u64,      // 8
    pub public_round_allocation: u64, // 8
}

#[account]
pub struct PurchaseAccount {
    pub buyer: Pubkey,        // 32
    pub amount: u64,          // 8
    pub is_distributed: bool, // 1
    pub timestamp: i64,       // 8
    pub ico: Pubkey,          // 32
    pub purchase_price: u64,  // 8
    pub round: RoundType,     // 1
    pub counter: u64,         // 8 (new field)
}

#[derive(Accounts)]
pub struct UpdateRound<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,

    #[account(mut, seeds = [b"ico"], bump)]
    pub ico_account: Account<'info, IcoAccount>,
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,

    #[account(
        init,
        payer = authority,
        space = 8 +    // discriminator
            32 +       // authority
            32 +       // token_mint
            8 +        // total_supply
            8 +        // seed_price
            8 +        // pre_ico_price
            8 +        // public_price
            8 +        // current_public_price
            8 +        // tokens_sold
            8 +        // seed_tokens_sold
            8 +        // public_tokens_sold
            8 +        // start_time
            8 +        // duration
            8 +        // pre_ico_round_deadline
            1 +        // is_active
            1 +        // round_type
            4 + (32 * 100) + // seed_investors vector with max 100 investors
            8 +        // total_investors
            8 +        // purchase_counter
            8 +        // seed_round_allocation
            8 +        // pre_ico_allocation
            8,         // public_round_allocation
        seeds = [b"ico"],
        bump
    )]
    pub ico_account: Account<'info, IcoAccount>,

    #[account(mut)]
    pub token_mint: Account<'info, Mint>,
    pub system_program: Program<'info, System>,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct UpdateInitializeParams {
    pub total_supply: Option<u64>,
    pub seed_price: Option<u64>,
    pub pre_ico_price: Option<u64>,
    pub public_price: Option<u64>,
    pub start_time: Option<i64>,
    pub duration: Option<i64>,
    pub pre_ico_round_deadline: Option<i64>, // New field
}

#[derive(Accounts)]
pub struct UpdateInitialize<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,

    #[account(mut, seeds = [b"ico"], bump)]
    pub ico_account: Account<'info, IcoAccount>,
}

#[derive(Accounts)]
pub struct BuyTokens<'info> {
    #[account(mut)]
    pub buyer: Signer<'info>,

    #[account(mut, seeds = [b"ico"], bump)]
    pub ico_account: Account<'info, IcoAccount>,

    #[account(
        init,
        payer = buyer,
        space = 8 + 32 + 8 + 1 + 8 + 32 + 8 + 1 + 8, // discriminator + fields
        seeds = [b"purchase", buyer.key().as_ref(), &ico_account.purchase_counter.to_le_bytes()],
        bump
    )]
    pub purchase_account: Account<'info, PurchaseAccount>,

    #[account(mut)]
    /// CHECK: This is safe because we only transfer SOL to this account
    pub treasury_wallet: UncheckedAccount<'info>,

    pub token_program: Program<'info, token::Token>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct DistributeTokens<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,

    #[account(
        mut,
        seeds = [b"ico"],
        bump,
        has_one = authority
    )]
    pub ico_account: Account<'info, IcoAccount>,

    #[account(
        mut,
        seeds = [b"purchase", purchase_account.buyer.as_ref(), &purchase_account.counter.to_le_bytes()],
        bump,
        constraint = !purchase_account.is_distributed @ IcoError::AlreadyDistributed,
        constraint = purchase_account.ico == ico_account.key() @ IcoError::InvalidPurchase
    )]
    pub purchase_account: Account<'info, PurchaseAccount>,

    #[account(
        mut,
        constraint = treasury_token_account.owner == authority.key() @ IcoError::Unauthorized,
        constraint = treasury_token_account.mint == ico_account.token_mint @ IcoError::InvalidTokenMint
    )]
    pub treasury_token_account: Account<'info, TokenAccount>,

    #[account(mut)]
    /// CHECK: Account checked in token transfer
    pub buyer_token_account: UncheckedAccount<'info>,

    pub token_program: Program<'info, token::Token>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct EndIco<'info> {
    #[account(mut, seeds = [b"ico"], bump)]
    pub ico_account: Account<'info, IcoAccount>,
}
#[derive(Accounts)]
pub struct AddSeedInvestor<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,
    #[account(mut, seeds = [b"ico"], bump)]
    pub ico_account: Account<'info, IcoAccount>,
}

#[derive(Accounts)]
pub struct RemoveSeedInvestor<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,
    #[account(mut, seeds = [b"ico"], bump)]
    pub ico_account: Account<'info, IcoAccount>,
}

#[error_code]
pub enum IcoError {
    #[msg("ICO is not currently active")]
    IcoNotActive,
    #[msg("Insufficient tokens remaining")]
    InsufficientTokens,
    #[msg("ICO is still active")]
    IcoStillActive,
    #[msg("You are not authorized to perform this action")]
    Unauthorized,
    #[msg("Purchase not found")]
    PurchaseNotFound,
    #[msg("Mathematical overflow occurred")]
    MathOverflow,
    #[msg("Investor is not whitelisted for the seed round")]
    NotWhitelisted,
    #[msg("Tokens already distributed for this purchase")]
    AlreadyDistributed,
    #[msg("Invalid purchase account")]
    InvalidPurchase,
    #[msg("Invalid token mint")]
    InvalidTokenMint,
    #[msg("Investor is already in the seed investors list")]
    InvestorAlreadyExists,
    #[msg("Round allocation exceeded")]
    RoundAllocationExceeded,
    #[msg("No more rounds available")]
    NoMoreRounds,
}

impl Default for RoundType {
    fn default() -> Self {
        RoundType::PreICO
    }
}




















this is my staking contarct :











use anchor_lang::prelude::*;
use anchor_spl::token::{self, Mint, Token, TokenAccount};
declare_id!("C1PMsnWmUQZ4Tcu6K9n5xcWTTyhkpraBzDUWLsgZEShD");

#[program]
pub mod jckp_staking {
    use super::*;

    pub fn initialize(
        ctx: Context<Initialize>,
        lockup_period: u64,
        low_tier_fee: f64,
        mid_tier_fee: f64,
        high_tier_fee: f64,
    ) -> Result<()> {
        let staking_account = &mut ctx.accounts.staking_account;
        staking_account.admin = ctx.accounts.admin.key();
        staking_account.lockup_period = lockup_period;
        staking_account.total_staked = 0;
        staking_account.end_timestamp = Clock::get()?.unix_timestamp as u64 + lockup_period;
        staking_account.token_mint = ctx.accounts.token_mint.key();
        staking_account.low_tier_fee = low_tier_fee;
        staking_account.mid_tier_fee = mid_tier_fee;
        staking_account.high_tier_fee = high_tier_fee;
        Ok(())
    }

    pub fn update(
        ctx: Context<Update>,
        lockup_period: u64,
        low_tier_fee: f64,
        mid_tier_fee: f64,
        high_tier_fee: f64,
    ) -> Result<()> {
        let staking_account = &mut ctx.accounts.staking_account;
        require!(
            low_tier_fee >= 0.0 && mid_tier_fee >= 0.0 && high_tier_fee >= 0.0,
            ErrorCode::InvalidRewardFeePercentages
        );
        require!(
            ctx.accounts.admin.key() == staking_account.admin,
            ErrorCode::Unauthorized
        );
        staking_account.lockup_period = lockup_period;
        staking_account.end_timestamp = Clock::get()?.unix_timestamp as u64 + lockup_period;
        staking_account.low_tier_fee = low_tier_fee;
        staking_account.mid_tier_fee = mid_tier_fee;
        staking_account.high_tier_fee = high_tier_fee;
        msg!("Updated staking account:");
        msg!("  Admin: {}", staking_account.admin);
        msg!("  Lockup period: {}", lockup_period);
        msg!("  Low-tier fee: {}", low_tier_fee);
        msg!("  Mid-tier fee: {}", mid_tier_fee);
        msg!("  High-tier fee: {}", high_tier_fee);
        Ok(())
    }

    pub fn stake_tokens(
        ctx: Context<Stake>,
        amount: u64,
        coupon_code: Option<String>,
    ) -> Result<()> {
        let staking_account = &mut ctx.accounts.staking_account;
        let staker_info = &mut ctx.accounts.staker_info;
        staker_info.owner = ctx.accounts.staker.key();
        let current_time = Clock::get()?.unix_timestamp as u64;
        require!(
            current_time <= staking_account.end_timestamp,
            ErrorCode::StakingPeriodEnded
        );
        require!(
            ctx.accounts.staker_token_account.amount >= amount,
            ErrorCode::InsufficientBalance
        );

        let final_amount = if let Some(code) = coupon_code {
            // Search the vector for a coupon with the matching code
            let coupon = staking_account
                .active_coupons
                .iter_mut()
                .find(|coupon| coupon.code == code)
                .ok_or(ErrorCode::InvalidCouponCode)?;

            require!(
                current_time >= coupon.start_timestamp && current_time <= coupon.end_timestamp,
                ErrorCode::ExpiredCoupon
            );
            require!(
                coupon.current_uses < coupon.max_uses,
                ErrorCode::CouponUsageExceeded
            );
            require!(
                amount >= coupon.min_stake_amount,
                ErrorCode::InsufficientStakeForCoupon
            );
            let bonus = match coupon.bonus_type {
                CouponType::Percentage => (((amount as f64) * coupon.bonus_value) / 100.0) as u64,
                CouponType::FixedAmount => coupon.bonus_value as u64,
                CouponType::SpinBonus => 0,
            };
            coupon.current_uses += 1;
            amount.checked_add(bonus).ok_or(ErrorCode::Overflow)?
        } else {
            amount
        };

        token::transfer(
            CpiContext::new(
                ctx.accounts.token_program.to_account_info(),
                token::Transfer {
                    from: ctx.accounts.staker_token_account.to_account_info(),
                    to: ctx.accounts.admin_staking_wallet.to_account_info(),
                    authority: ctx.accounts.staker.to_account_info(),
                },
            ),
            final_amount,
        )?;

        let (tier, lockup_duration) = if final_amount >= 1000 {
            (3, 180)
        } else if final_amount >= 500 {
            (2, 3)
        } else if final_amount >= 100 {
            (1, 1)
        } else {
            (0, 0)
        };
        // Calculate the end timestamp as current timestamp + lockup_duration.
        let end_timestamp = current_time
            .checked_add(lockup_duration)
            .ok_or(ErrorCode::Overflow)?;
        // let end_timestamp = current_time
        //     .checked_add(lockup_duration)
        //     .ok_or(ErrorCode::Overflow)?;

        let (spin_eligibility, spin_count) = if final_amount >= 1000 {
            (5, 5)
        } else if final_amount >= 500 {
            (3, 3)
        } else if final_amount >= 100 {
            (1, 1)
        } else {
            (0, 0)
        };

        let stake_record = &mut ctx.accounts.stake_record;
        stake_record.owner = ctx.accounts.staker.key();
        stake_record.amount = final_amount;
        stake_record.stake_timestamp = current_time;
        stake_record.end_timestamp = end_timestamp;
        stake_record.tier = tier;
        stake_record.spin_count = spin_count;
        stake_record.spin_eligibility_tier = spin_eligibility;
        stake_record.is_initialized = true;

        staker_info.total_staked = staker_info
            .total_staked
            .checked_add(final_amount)
            .ok_or(ErrorCode::Overflow)?;
        staker_info.staked_amount = staker_info
            .staked_amount
            .checked_add(amount)
            .ok_or(ErrorCode::Overflow)?;
        staking_account.total_staked = staking_account
            .total_staked
            .checked_add(final_amount)
            .ok_or(ErrorCode::Overflow)?;

        staker_info.spin_count = staker_info
            .spin_count
            .checked_add(spin_count)
            .ok_or(ErrorCode::Overflow)?;

        // if staker_info.total_staked >= 1000 {
        //     staker_info.spin_eligibility_tier = 5;
        // } else if staker_info.total_staked >= 500 {
        //     staker_info.spin_eligibility_tier = 3;
        // } else if staker_info.total_staked >= 100 {
        //     staker_info.spin_eligibility_tier = 1;
        // } else {
        //     staker_info.spin_eligibility_tier = 0;
        // }

        emit!(StakeEvent {
            staker_key: stake_record.key(),
            staker: stake_record.owner,
            staked_before: staker_info
                .total_staked
                .checked_sub(final_amount)
                .unwrap_or(0),
            staked_after: staker_info.total_staked,
            staked_amount: final_amount,
            // spin_eligibility_after: staker_info.spin_count,
            reward_fee_percent: if staker_info.total_staked >= 1000 {
                staking_account.high_tier_fee
            } else if staker_info.total_staked >= 500 {
                staking_account.mid_tier_fee
            } else {
                staking_account.low_tier_fee
            },
            spin_count: stake_record.spin_count,
            timestamp: current_time,
        });

        Ok(())
    }

    pub fn unstake_combined(ctx: Context<UnstakeUnified>, amount: u64) -> Result<()> {
        let staking_account = &mut ctx.accounts.staking_account;
        let stake_record = &mut ctx.accounts.stake_record;
        let staker_info = &mut ctx.accounts.staker_info;
        let current_time = Clock::get()?.unix_timestamp as u64;

        require!(
            stake_record.owner == ctx.accounts.staker.key(),
            ErrorCode::Unauthorized
        );

        if current_time < stake_record.end_timestamp {
            // Early (partial) unstake with penalty
            require!(stake_record.amount >= amount, ErrorCode::InsufficientStake);
            let penalty_rate = match staker_info.spin_eligibility_tier {
                3 => 0.05,
                2 => 0.10,
                1 => 0.15,
                _ => 0.20,
            };
            let time_staked = current_time.saturating_sub(staker_info.stake_timestamp);
            let reward_amount = calculate_reward(
                amount,
                staker_info.staked_amount,
                time_staked,
                staking_account.low_tier_fee,
                staking_account.mid_tier_fee,
                staking_account.high_tier_fee,
            )?;
            let final_reward = (reward_amount as f64 * (1.0 - penalty_rate)) as u64;

            token::transfer(
                CpiContext::new(
                    ctx.accounts.token_program.to_account_info(),
                    token::Transfer {
                        from: ctx.accounts.admin_staking_wallet.to_account_info(),
                        to: ctx.accounts.staker_token_account.to_account_info(),
                        authority: ctx.accounts.owner.to_account_info(),
                    },
                ),
                amount,
            )?;

            if final_reward > 0 {
                token::mint_to(
                    CpiContext::new(
                        ctx.accounts.token_program.to_account_info(),
                        token::MintTo {
                            mint: ctx.accounts.token_mint.to_account_info(),
                            to: ctx.accounts.staker_token_account.to_account_info(),
                            authority: ctx.accounts.owner.to_account_info(),
                        },
                    ),
                    final_reward,
                )?;
            }

            staking_account.total_staked = staking_account
                .total_staked
                .checked_sub(amount)
                .ok_or(ErrorCode::Underflow)?;
            staker_info.staked_amount = staker_info
                .staked_amount
                .checked_sub(amount)
                .ok_or(ErrorCode::Underflow)?;
            let previous_stake_amount = stake_record.amount;
            stake_record.amount = stake_record
                .amount
                .checked_sub(amount)
                .ok_or(ErrorCode::Underflow)?;
            staker_info.spin_count = calculate_spin_count(staker_info.staked_amount, time_staked);
            if staker_info.staked_amount >= 1000 {
                staker_info.spin_eligibility_tier = 5;
            } else if staker_info.staked_amount >= 500 {
                staker_info.spin_eligibility_tier = 3;
            } else if staker_info.staked_amount >= 100 {
                staker_info.spin_eligibility_tier = 1;
            } else {
                staker_info.spin_eligibility_tier = 0;
            }

            emit!(PartialUnstakeEvent {
                staker_key: stake_record.key(),
                staker: stake_record.owner,
                staked_before: previous_stake_amount,
                staked_after: stake_record.amount,
                unstaked_amount: amount,
                reward_amount: final_reward,
                early_withdrawal: true,
                penalty_rate,
                timestamp: current_time,
            });
        } else {
            // Full unstake after stake record's end timestamp
            require!(
                amount == stake_record.amount,
                ErrorCode::MustUnstakeFullAmount
            );
            require!(
                is_unstake_allowed(stake_record.tier, stake_record.stake_timestamp),
                ErrorCode::EarlyUnstake
            );

            let staked_before = stake_record.amount;
            let time_staked = current_time.saturating_sub(stake_record.stake_timestamp);
            let reward_amount = calculate_reward(
                amount,
                stake_record.amount,
                time_staked,
                staking_account.low_tier_fee,
                staking_account.mid_tier_fee,
                staking_account.high_tier_fee,
            )?;

            token::transfer(
                CpiContext::new(
                    ctx.accounts.token_program.to_account_info(),
                    token::Transfer {
                        from: ctx.accounts.admin_staking_wallet.to_account_info(),
                        to: ctx.accounts.staker_token_account.to_account_info(),
                        authority: ctx.accounts.owner.to_account_info(),
                    },
                ),
                amount,
            )?;

            if reward_amount > 0 {
                token::mint_to(
                    CpiContext::new(
                        ctx.accounts.token_program.to_account_info(),
                        token::MintTo {
                            mint: ctx.accounts.token_mint.to_account_info(),
                            to: ctx.accounts.staker_token_account.to_account_info(),
                            authority: ctx.accounts.owner.to_account_info(),
                        },
                    ),
                    reward_amount,
                )?;
            }

            staker_info.total_staked = staker_info
                .total_staked
                .checked_sub(amount)
                .ok_or(ErrorCode::Underflow)?;
            staker_info.staked_amount = staker_info
                .staked_amount
                .checked_sub(amount)
                .ok_or(ErrorCode::Underflow)?;
            if staker_info.staked_amount == 0 {
                staker_info.stake_timestamp = 0;
            }
            if staker_info.staked_amount >= 1000 {
                staker_info.spin_eligibility_tier = 5;
            } else if staker_info.staked_amount >= 500 {
                staker_info.spin_eligibility_tier = 3;
            } else if staker_info.staked_amount >= 100 {
                staker_info.spin_eligibility_tier = 1;
            } else {
                staker_info.spin_eligibility_tier = 0;
            }
            staker_info.spin_count = calculate_spin_count(
                staker_info.staked_amount,
                if staker_info.stake_timestamp > 0 {
                    current_time.saturating_sub(staker_info.stake_timestamp)
                } else {
                    0
                },
            );
            staking_account.total_staked = staking_account
                .total_staked
                .checked_sub(amount)
                .ok_or(ErrorCode::Underflow)?;
            stake_record.amount = 0;

            emit!(UnstakeEvent {
                staker_key: stake_record.key(),
                staker: stake_record.owner,
                staked_before,
                staked_after: stake_record.amount,
                unstaked_amount: amount,
                reward_amount,
                spin_eligibility_after: stake_record.spin_eligibility_tier,
                spin_count: stake_record.spin_count,
                timestamp: current_time,
            });
        }
        Ok(())
    }

    pub fn generate_monthly_report(ctx: Context<MonthlyReport>) -> Result<()> {
        let staking_account = &ctx.accounts.staking_account;
        let current_time = Clock::get()?.unix_timestamp as u64;

        msg!("Periodic Staking Report:");
        msg!("Total Staked Amount: {}", staking_account.total_staked);
        msg!("Current Reward Rate is dynamically calculated based on tier.");
        msg!(
            "Time Remaining in Current Period: {} seconds",
            staking_account.end_timestamp.saturating_sub(current_time)
        );
        msg!("Market Conditions: Stable (simulated)");
        msg!("Upcoming Adjustments: Next rate review in 30 days.");

        Ok(())
    }

    pub fn create_coupon(
        ctx: Context<CreateCoupon>,
        code: String,
        bonus_type: CouponType,
        bonus_value: f64,
        duration: u64,
        min_stake_amount: u64,
        max_uses: u64,
        coupon_category: CouponCategory,
    ) -> Result<()> {
        let staking_account = &mut ctx.accounts.staking_account;

        // Only admin can create coupons
        require!(
            ctx.accounts.admin.key() == staking_account.admin,
            ErrorCode::Unauthorized
        );

        // Validate coupon parameters
        require!(bonus_value > 0.0, ErrorCode::InvalidCouponParameters);
        require!(duration > 0, ErrorCode::InvalidCouponParameters);
        require!(max_uses > 0, ErrorCode::InvalidCouponParameters);

        // Additional validation based on bonus type
        match bonus_type {
            CouponType::Percentage => {
                require!(bonus_value <= 50.0, ErrorCode::InvalidCouponParameters);
            }
            CouponType::FixedAmount => {
                require!(bonus_value <= 1000.0, ErrorCode::InvalidCouponParameters);
            }
            CouponType::SpinBonus => {
                require!(bonus_value <= 10.0, ErrorCode::InvalidCouponParameters);
            }
        }

        let current_time = Clock::get()?.unix_timestamp as u64;

        // Remove any expired coupons
        staking_account
            .active_coupons
            .retain(|coupon| coupon.end_timestamp > current_time);

        // Enforce a limit of 10 active coupons
        require!(
            staking_account.active_coupons.len() < 10,
            ErrorCode::CouponArrayLimitExceeded
        );

        let new_coupon = Coupon {
            code,
            bonus_type,
            bonus_value,
            start_timestamp: current_time,
            end_timestamp: current_time + duration,
            min_stake_amount,
            max_uses,
            current_uses: 0,
            coupon_category,
            is_active: true,
        };

        staking_account.active_coupons.push(new_coupon.clone());

        emit!(CouponEvent {
            code: new_coupon.code.clone(),
            bonus_type: new_coupon.bonus_type,
            bonus_value: new_coupon.bonus_value,
            start_timestamp: new_coupon.start_timestamp,
            end_timestamp: new_coupon.end_timestamp,
            coupon_category: new_coupon.coupon_category,
            timestamp: current_time,
        });

        Ok(())
    }

}

fn calculate_tier_and_rate(
    total_staked: u64,
    time_staked: u64,
    low_tier_fee: f64,
    mid_tier_fee: f64,
    high_tier_fee: f64,
) -> (u8, f64) {
    let mut tier = 0;
    let mut reward_fee_percent = 0.0; // Default to 0 reward fee

    if total_staked >= 1000 {
        tier = 3;
        reward_fee_percent = high_tier_fee; // Use high-tier fee for 1000 and above
    } else if total_staked >= 500 {
        tier = 2;
        reward_fee_percent = mid_tier_fee; // Use mid-tier fee for 500-999
    } else if total_staked >= 100 {
        tier = 1;
        reward_fee_percent = low_tier_fee; // Use low-tier fee for 100-499
    }

    if time_staked > 5 * 30 * 24 * 60 * 60 {
        // Example threshold: ~5 months
        reward_fee_percent += 1.0; // Long-term bonus of 1% additional reward
    }

    (tier, reward_fee_percent)
}

fn is_unstake_allowed(tier: u8, stake_timestamp: u64) -> bool {
    let current_time = Clock::get().unwrap().unix_timestamp as u64;
    let required_duration = match tier {
        3 => 5, // 5 months for high tier
        2 => 3, // 3 months for mid tier
        1 => 1, // 1 month for low tier
        _ => 0, // No restriction for tier 0
    };

    current_time >= stake_timestamp + required_duration
}

fn calculate_spin_count(total_staked: u64, time_staked: u64) -> u8 {
    let mut spin_count = 0;

    if total_staked >= 1000 {
        spin_count = 5; // High tier gets 5 spins
    } else if total_staked >= 500 {
        spin_count = 3; // Mid tier gets 3 spins
    } else if total_staked >= 100 {
        spin_count = 1; // Low tier gets 1 spin
    }

    spin_count
}

fn calculate_reward(
    amount: u64,
    total_staked: u64,
    time_staked: u64,
    low_tier_fee: f64,
    mid_tier_fee: f64,
    high_tier_fee: f64,
) -> Result<u64> {
    let (tier, reward_fee_percent) = calculate_tier_and_rate(
        total_staked,
        time_staked,
        low_tier_fee,
        mid_tier_fee,
        high_tier_fee,
    );

    msg!("Amount: {}", amount);
    msg!("Tier: {}", tier);
    msg!("Reward Fee Percent: {}", reward_fee_percent);
    msg!("Time Staked: {}", time_staked);

    let reward = if reward_fee_percent > 0.0 {
        (amount as u128)
            .checked_mul(reward_fee_percent as u128)
            .ok_or_else(|| Error::from(ErrorCode::Overflow))?
            .checked_div(100)
            .ok_or_else(|| Error::from(ErrorCode::Overflow))?
    } else {
        0
    };

    msg!("Calculated Reward: {}", reward);

    Ok(reward as u64)
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy)]
pub enum CouponCategory {
    NewUser,
    Referral,
    LoyaltyReward,
    SeasonalPromo,
    Exclusive,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy)]
pub enum CouponType {
    Percentage,
    FixedAmount,
    SpinBonus,
}

impl Default for CouponType {
    fn default() -> Self {
        CouponType::Percentage
    }
}

impl Default for CouponCategory {
    fn default() -> Self {
        CouponCategory::NewUser
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = admin, space = 8 + std::mem::size_of::<StakingAccount>() + 4 + (10 * 100))]
    pub staking_account: Account<'info, StakingAccount>,
    #[account(mut)]
    pub admin: Signer<'info>,
    pub token_mint: Account<'info, Mint>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Stake<'info> {
    #[account(mut)]
    pub staking_account: Account<'info, StakingAccount>,

    // Create a new stake_record with a random address (no seeds).
    #[account(init, payer = staker, space = 8 + std::mem::size_of::<StakeRecord>())]
    pub stake_record: Account<'info, StakeRecord>,

    // Aggregated staker_info account (created if needed).
    #[account(
        init_if_needed,
        payer = staker,
        space = 8 + std::mem::size_of::<StakerInfo>(),
        seeds = [b"staker_info", staking_account.key().as_ref(), staker.key().as_ref()],
        bump
    )]
    pub staker_info: Account<'info, StakerInfo>,

    #[account(mut, constraint = staker_token_account.mint == staking_account.token_mint)]
    pub staker_token_account: Account<'info, TokenAccount>,
    #[account(mut)]
    pub admin_staking_wallet: Account<'info, TokenAccount>,
    #[account(mut)]
    pub staker: Signer<'info>,
    pub token_program: Program<'info, Token>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct UnstakeUnified<'info> {
    #[account(mut)]
    pub staking_account: Account<'info, StakingAccount>,
    #[account(mut)]
    pub stake_record: Account<'info, StakeRecord>,
    #[account(mut, constraint = staker_token_account.mint == staking_account.token_mint)]
    pub staker_token_account: Account<'info, TokenAccount>,
    #[account(mut)]
    pub admin_staking_wallet: Account<'info, TokenAccount>,
    #[account(mut)]
    pub token_mint: Account<'info, Mint>,
    #[account(
        mut,
        seeds = [b"staker_info", staking_account.key().as_ref(), staker.key().as_ref()],
        bump
    )]
    pub staker_info: Account<'info, StakerInfo>,
    #[account(mut)]
    pub staker: Signer<'info>,
    #[account(mut)]
    pub owner: AccountInfo<'info>,
    pub token_program: Program<'info, Token>,
    pub system_program: Program<'info, System>,
}

#[event]
pub struct PartialUnstakeEvent {
    pub staker_key: Pubkey,
    pub staker: Pubkey,
    pub staked_before: u64,
    pub staked_after: u64,
    pub unstaked_amount: u64,
    pub reward_amount: u64,
    pub early_withdrawal: bool,
    pub penalty_rate: f64,
    pub timestamp: u64,
}

#[derive(Accounts)]
pub struct MonthlyReport<'info> {
    #[account(mut)]
    pub staking_account: Account<'info, StakingAccount>,
}

#[derive(Accounts)]
pub struct Update<'info> {
    #[account(mut, has_one = admin)] // Ensures the staking account's admin matches
    pub staking_account: Account<'info, StakingAccount>, // The account being updated
    #[account(mut)]
    pub admin: Signer<'info>, // The admin (owner) of the staking account
    pub system_program: Program<'info, System>, // System program for compatibility
}

#[account]
#[derive(Default)]
pub struct StakingAccount {
    pub lockup_period: u64,
    pub total_staked: u64,
    pub end_timestamp: u64,
    pub token_mint: Pubkey,
    pub admin: Pubkey,
    pub low_tier_fee: f64,
    pub mid_tier_fee: f64,
    pub high_tier_fee: f64,
    pub active_coupons: Vec<Coupon>,
}

#[account]
#[derive(Default)]
pub struct StakerInfo {
    pub owner: Pubkey,
    pub total_staked: u64,
    pub spin_count: u8,
    pub spin_eligibility_tier: u8,
    pub staked_amount: u64,
    pub stake_timestamp: u64,
}

#[account]
#[derive(Default)]
pub struct StakeRecord {
    pub owner: Pubkey,
    pub amount: u64,
    pub stake_timestamp: u64,
    pub end_timestamp: u64,
    pub tier: u8,
    pub spin_count: u8,
    pub spin_eligibility_tier: u8,
    pub is_initialized: bool,
}

#[event]
pub struct StakeEvent {
    pub staker_key: Pubkey,
    pub staker: Pubkey,
    pub staked_before: u64,
    pub staked_after: u64,
    pub staked_amount: u64,
    // pub spin_eligibility_after: u8,
    pub reward_fee_percent: f64,
    pub spin_count: u8,
    pub timestamp: u64,
}

#[event]
pub struct UnstakeEvent {
    pub staker_key: Pubkey,
    pub staker: Pubkey,
    pub staked_before: u64,
    pub staked_after: u64,
    pub unstaked_amount: u64,
    pub reward_amount: u64,
    pub spin_eligibility_after: u8,
    pub spin_count: u8,
    pub timestamp: u64,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Default)]
pub struct Coupon {
    pub code: String,
    pub bonus_type: CouponType,
    pub bonus_value: f64,
    pub start_timestamp: u64,
    pub end_timestamp: u64,
    pub min_stake_amount: u64,
    pub max_uses: u64,
    pub current_uses: u64,
    pub coupon_category: CouponCategory,
    pub is_active: bool,
}

#[event]
pub struct CouponEvent {
    pub code: String,
    pub bonus_type: CouponType,
    pub bonus_value: f64,
    pub start_timestamp: u64,
    pub end_timestamp: u64,
    pub coupon_category: CouponCategory,
    pub timestamp: u64,
}

#[derive(Accounts)]
pub struct CreateCoupon<'info> {
    #[account(mut, has_one = admin)]
    pub staking_account: Account<'info, StakingAccount>,
    #[account(mut)]
    pub admin: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[error_code]
pub enum ErrorCode {
    #[msg("Staking period has ended.")]
    StakingPeriodEnded,
    #[msg("Early unstaking is not allowed.")]
    EarlyUnstake,
    #[msg("Insufficient balance for staking.")]
    InsufficientBalance,
    #[msg("Insufficient staked amount.")]
    InsufficientStake,
    #[msg("Overflow error.")]
    Overflow,
    #[msg("Underflow error.")]
    Underflow,
    #[msg("Unauthorized access.")]
    Unauthorized,
    #[msg("Invalid reward fee percentages.")]
    InvalidRewardFeePercentages,
    #[msg("You must unstake the full amount.")]
    MustUnstakeFullAmount,
    #[msg("Invalid coupon parameters.")]
    InvalidCouponParameters,
    #[msg("Invalid coupon code.")]
    InvalidCouponCode,
    #[msg("Coupon has expired.")]
    ExpiredCoupon,
    #[msg("Coupon usage limit exceeded.")]
    CouponUsageExceeded,
    #[msg("Insufficient stake amount for coupon use.")]
    InsufficientStakeForCoupon,
    #[msg("Early unstaking is not allowed.")]
    EarlyUnstakeNotAllowed,
    #[msg("Invalid stake nonce.")]
    InvalidStakeNonce,
    #[msg("Coupon array limit exceeded.")]
    CouponArrayLimitExceeded,
}

























Based on the smart contract i create this files in my reactjs project



src/pages/BuyTokens.js






"use client"

import { useState, useEffect } from "react"
import { useConnection, useWallet } from "@solana/wallet-adapter-react"
import { PublicKey } from "@solana/web3.js"
import { getProgram } from "../utils/anchor-connection"
import * as anchor from "@project-serum/anchor"
import { TOKEN_PROGRAM_ID } from "@solana/spl-token"
import { formatSol } from "../utils/formatters"
import { Label } from "../components/ui/label"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "../components/ui/card"
import { Input } from "../components/ui/input"
import { Button } from "../components/ui/button"
import { Alert, AlertDescription } from "../components/ui/alert"
import { Loader2 } from "lucide-react"

const BuyTokens = () => {
  const { connection } = useConnection()
  const wallet = useWallet()
  const [amount, setAmount] = useState("")
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState("")
  const [success, setSuccess] = useState("")
  const [icoData, setIcoData] = useState(null)

  useEffect(() => {
    if (wallet.publicKey) {
      fetchIcoData()
    }
  }, [connection, wallet.publicKey])

  const fetchIcoData = async () => {
    if (!wallet.publicKey) return

    try {
      const program = getProgram(connection, wallet)
      const [icoAccount] = await PublicKey.findProgramAddress([Buffer.from("ico")], program.programId)
      const data = await program.account.icoAccount.fetch(icoAccount)
      setIcoData(data)
    } catch (err) {
      console.error("Error fetching ICO data:", err)
      setError("Failed to fetch ICO data. Please try again later.")
    }
  }

  const handleBuyTokens = async (e) => {
    e.preventDefault()
    if (!wallet.publicKey || !wallet.signTransaction || !icoData) return

    setLoading(true)
    setError("")
    setSuccess("")

    try {
      const program = getProgram(connection, wallet)
      const [icoAccount] = await PublicKey.findProgramAddress([Buffer.from("ico")], program.programId)

      // Get the treasury wallet from the authority field
      const treasuryWallet = icoData.authority
      const purchaseCounter = icoData.purchaseCounter

      // Create the purchase account PDA
      const [purchaseAccount] = await PublicKey.findProgramAddress(
        [
          Buffer.from("purchase"),
          wallet.publicKey.toBuffer(),
          new anchor.BN(purchaseCounter).toArrayLike(Buffer, "le", 8),
        ],
        program.programId,
      )

      // Convert amount to lamports
      const amountLamports = new anchor.BN(Number.parseFloat(amount) * anchor.web3.LAMPORTS_PER_SOL)

      // Call the buyTokens instruction
      const tx = await program.methods
        .buyTokens(amountLamports)
        .accounts({
          buyer: wallet.publicKey,
          icoAccount,
          purchaseAccount,
          treasuryWallet,
          tokenProgram: TOKEN_PROGRAM_ID,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .rpc()

      setSuccess(`Tokens purchased successfully! Transaction ID: ${tx}`)
      await fetchIcoData() // Refresh ICO data
    } catch (err) {
      console.error("Error buying tokens:", err)
      setError(`Token purchase failed: ${err.message}`)
    } finally {
      setLoading(false)
    }
  }

  const calculateTokenAmount = () => {
    if (!amount || !icoData) return 0

    // Calculate based on the current price
    const currentPrice = icoData.currentPublicPrice.toString() / anchor.web3.LAMPORTS_PER_SOL
    return Number.parseFloat(amount) / currentPrice
  }

  const calculateTokensSoldPercentage = () => {
    if (!icoData) return 0
    return (icoData.tokensSold.toString() / icoData.totalSupply.toString()) * 100
  }

  const tokensSoldPercentage = calculateTokensSoldPercentage()

  return (
    <Card className="max-w-lg mx-auto">
      <CardHeader>
        <CardTitle>Buy Tokens</CardTitle>
        <CardDescription>Purchase tokens for the Solana ICO</CardDescription>
      </CardHeader>
      <CardContent>
        <form onSubmit={handleBuyTokens} className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="amount">Amount of SOL to spend:</Label>
            <Input
              type="number"
              id="amount"
              value={amount}
              onChange={(e) => setAmount(e.target.value)}
              required
              min="0"
              step="0.000000001"
            />
          </div>
          {icoData && (
            <div className="text-sm text-gray-600">
              You will receive approximately {calculateTokenAmount().toFixed(4)} tokens
            </div>
          )}
          <Button type="submit" disabled={loading || !wallet.publicKey} className="w-full">
            {loading ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                Processing...
              </>
            ) : (
              "Buy Tokens"
            )}
          </Button>
        </form>
        {error && (
          <Alert variant="destructive" className="mt-4">
            <AlertDescription>{error}</AlertDescription>
          </Alert>
        )}
        {success && (
          <Alert className="mt-4 bg-green-50 text-green-800 border-green-500">
            <AlertDescription>{success}</AlertDescription>
          </Alert>
        )}
        {icoData && (
          <div className="mt-6 space-y-4">
            <div className="flex justify-between items-center">
              <span className="text-sm font-medium text-gray-700">Current Price:</span>
              <span className="text-sm font-bold">{formatSol(icoData.currentPublicPrice)} SOL</span>
            </div>
            <div className="flex justify-between items-center">
              <span className="text-sm font-medium text-gray-700">Tokens Available:</span>
              <span className="text-sm font-bold">{formatSol(icoData.totalSupply.sub(icoData.tokensSold))}</span>
            </div>
            <div>
              <div className="flex justify-between items-center mb-1">
                <span className="text-sm font-medium text-gray-700">Tokens Sold:</span>
                <span className="text-sm font-bold">{tokensSoldPercentage.toFixed(2)}%</span>
              </div>
              <div className="w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-700">
                <div className="bg-blue-600 h-2.5 rounded-full" style={{ width: `${tokensSoldPercentage}%` }}></div>
              </div>
            </div>
          </div>
        )}
      </CardContent>
    </Card>
  )
}

export default BuyTokens








src/pages/Dashboard.js




import React, { useState, useEffect } from 'react';
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { PublicKey } from '@solana/web3.js';
import BN from 'bn.js'; 
import { getProgram } from '../utils/anchor-connection';
import { formatUnixTimestamp, formatSol } from '../utils/formatters';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "../components/ui/card";

const Dashboard = () => {
  const { connection } = useConnection();
  const wallet = useWallet();
  const [icoData, setIcoData] = useState(null);
  const [timeLeft, setTimeLeft] = useState(null);

  useEffect(() => {
    if (wallet.publicKey) {
      fetchIcoData();
    }
  }, [connection, wallet.publicKey]);

  useEffect(() => {
    if (icoData && icoData.startTime && icoData.duration) {
        const timer = setInterval(() => {
        const now = Math.floor(Date.now() / 1000);
        const startTime = icoData.startTime.toString();
        const duration = icoData.duration.toString();
        const endTime = startTime + duration;
        const remaining = endTime - now;
        
        if (remaining <= 0) {
          clearInterval(timer);
          setTimeLeft("ICO Ended");
        } else {
          const days = Math.floor(remaining / 86400);
          const hours = Math.floor((remaining % 86400) / 3600);
          const minutes = Math.floor((remaining % 3600) / 60);
          const seconds = remaining % 60;
          setTimeLeft(`${days}d ${hours}h ${minutes}m ${seconds}s`);
        }
      }, 1000);

      return () => clearInterval(timer);
    }
  }, [icoData]);

  const fetchIcoData = async () => {
    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from("ico")],
        program.programId
      );
      const data = await program.account.icoAccount.fetch(icoAccount);
      setIcoData(data);
    } catch (err) {
      console.error('Error:', err);
    }
  };

  if (!wallet.publicKey) {
    return (
      <div className="text-center py-12">
        <h2 className="text-2xl font-semibold mb-4">Welcome to Solana ICO Dashboard</h2>
        <p className="text-gray-600">Please connect your wallet to view ICO details.</p>
      </div>
    );
  }

  if (!icoData) {
    return (
      <div className="text-center py-12">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto"></div>
        <p className="mt-4 text-gray-600">Loading ICO details...</p>
      </div>
    );
  }

  const tokensSold = icoData.tokensSold;
  const totalSupply = icoData.totalSupply;
  
  const tokensSoldPercentage = tokensSold && totalSupply 
    ? tokensSold.mul(new BN(100)).div(totalSupply).toNumber() // Convert to number
    : 0;

  return (
    <div className="space-y-6">
      <h1 className="text-3xl font-bold mb-6">ICO Dashboard</h1>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>Total Supply</CardTitle>
          </CardHeader>
          <CardContent>
            <p className="text-3xl font-bold">{formatSol(icoData.totalSupply)} SOL</p>
            <p className="mt-2 text-sm text-gray-600">Round Type: {Object.keys(icoData.roundType)[0]}</p>
          </CardContent>
        </Card>
        <Card>
          <CardHeader>
            <CardTitle>Tokens Sold</CardTitle>
          </CardHeader>
          <CardContent>
            <p className="text-3xl font-bold">{formatSol(icoData.tokensSold)} SOL</p>
            <p className="mt-2 text-sm text-gray-600">
               {tokensSoldPercentage.toFixed(2)}% of total supply
            </p>
          </CardContent>
        </Card>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>Sale Progress</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="relative pt-1">
            <div className="flex mb-2 items-center justify-between">
              <div>
                <span className="text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full text-blue-600 bg-blue-200">
                  {tokensSoldPercentage.toFixed(2)}%
                </span>
              </div>
              <div className="text-right">
                <span className="text-xs font-semibold inline-block text-blue-600">
                  {formatSol(icoData.tokensSold)} / {formatSol(icoData.totalSupply)} SOL
                </span>
              </div>
            </div>
            <div className="overflow-hidden h-2 mb-4 text-xs flex rounded bg-blue-200">
              <div
                style={{ width: `${tokensSoldPercentage}%` }}
                className="shadow-none flex flex-col text-center whitespace-nowrap text-white justify-center bg-blue-500"
              ></div>
            </div>
          </div>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>ICO Details</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <p className="text-sm font-medium text-gray-500">Current Price</p>
              <p className="text-lg font-semibold">{formatSol(icoData.currentPublicPrice)} SOL</p>
            </div>
            <div>
              <p className="text-sm font-medium text-gray-500">Start Time</p>
              <p className="text-lg font-semibold">{formatUnixTimestamp(icoData.startTime)}</p>
            </div>
            <div>
              <p className="text-sm font-medium text-gray-500">End Time</p>
              <p className="text-lg font-semibold">
                {formatUnixTimestamp(icoData.startTime.toString() + icoData.duration.toString())}
              </p>
            </div>
            <div>
              <p className="text-sm font-medium text-gray-500">Time Remaining</p>
              <p className="text-lg font-semibold">{timeLeft}</p>
            </div>
            <div>
              <p className="text-sm font-medium text-gray-500">Status</p>
              <p className="text-lg font-semibold">
                {icoData.isActive ? (
                  <span className="text-green-500">Active</span>
                ) : (
                  <span className="text-red-500">Inactive</span>
                )}
              </p>
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  );
};

export default Dashboard;









src/pages/DistributeToken.js




import React, { useState, useEffect } from 'react';
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { PublicKey } from '@solana/web3.js';
import { getProgram } from '../utils/anchor-connection';
import { formatSol } from '../utils/formatters';
import { isAdminWallet } from '../utils/admin-check';
import AdminLayout from '../components/AdminLayout';
import { Button } from "../components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "../components/ui/card";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "../components/ui/table";

const DistributeTokens = () => {
  const { connection } = useConnection();
  const wallet = useWallet();
  const [investors, setInvestors] = useState([]);
  const [loading, setLoading] = useState(true);
  const [distributing, setDistributing] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');

  useEffect(() => {
    if (wallet.publicKey && isAdminWallet(wallet.publicKey)) {
      fetchInvestors();
    }
  }, [connection, wallet.publicKey]);

  const fetchInvestors = async () => {
    if (!wallet.publicKey) return;

    setLoading(true);
    setError('');

    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from('ico')],
        program.programId
      );
      const icoData = await program.account.icoAccount.fetch(icoAccount);

      const purchaseAccounts = await connection.getProgramAccounts(program.programId, {
        filters: [
          { dataSize: program.account.purchaseAccount.size },
          { memcmp: { offset: 8, bytes: icoAccount.toBase58() } },
        ],
      });

      const investorsData = await Promise.all(
        purchaseAccounts.map(async (account) => {
          const purchaseData = await program.account.purchaseAccount.fetch(account.pubkey);
          return {
            address: purchaseData.buyer.toString(),
            amount: purchaseData.amount,
            isDistributed: purchaseData.isDistributed,
            purchaseAccountPubkey: account.pubkey,
          };
        })
      );

      setInvestors(investorsData);
    } catch (err) {
      console.error('Error fetching investors:', err);
      setError('Failed to fetch investors. Please try again later.');
    } finally {
      setLoading(false);
    }
  };

  const handleDistribute = async (purchaseAccountPubkey) => {
    if (!wallet.publicKey || !wallet.signTransaction) return;

    setDistributing(true);
    setError('');
    setSuccess('');

    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from('ico')],
        program.programId
      );

      const tx = await program.methods
        .distributeTokens()
        .accounts({
          icoAccount,
          purchaseAccount: purchaseAccountPubkey,
          authority: wallet.publicKey,
        })
        .rpc();

      setSuccess(`Tokens distributed successfully! Transaction ID: ${tx}`);
      await fetchInvestors(); // Refresh investors list
    } catch (err) {
      console.error('Error distributing tokens:', err);
      setError('Failed to distribute tokens. Please try again later.');
    } finally {
      setDistributing(false);
    }
  };

  if (!wallet.publicKey || !isAdminWallet(wallet.publicKey)) {
    return (
      <AdminLayout>
        <Card>
          <CardHeader>
            <CardTitle>Distribute Tokens</CardTitle>
            <CardDescription>You do not have permission to access this page.</CardDescription>
          </CardHeader>
        </Card>
      </AdminLayout>
    );
  }

  return (
    <AdminLayout>
      <Card>
        <CardHeader>
          <CardTitle>Distribute Tokens</CardTitle>
          <CardDescription>Distribute tokens to investors</CardDescription>
        </CardHeader>
        <CardContent>
          {loading ? (
            <div className="text-center py-12">
              <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto"></div>
              <p className="mt-4 text-gray-600">Loading investors...</p>
            </div>
          ) : error ? (
            <div className="p-4 bg-red-100 border border-red-400 text-red-700 rounded-md text-sm">
              {error}
            </div>
          ) : (
            <>
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead>Investor Address</TableHead>
                    <TableHead>Amount Purchased</TableHead>
                    <TableHead>Status</TableHead>
                    <TableHead>Action</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {investors.map((investor, index) => (
                    <TableRow key={index}>
                      <TableCell>{investor.address}</TableCell>
                      <TableCell>{formatSol(investor.amount)} SOL</TableCell>
                      <TableCell>
                        {investor.isDistributed ? 'Distributed' : 'Pending'}
                      </TableCell>
                      <TableCell>
                        <Button
                          onClick={() => handleDistribute(investor.purchaseAccountPubkey)}
                          disabled={distributing || investor.isDistributed}
                          size="sm"
                        >
                          {distributing ? 'Distributing...' : 'Distribute'}
                        </Button>
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
              {success && (
                <div className="mt-4 p-4 bg-green-100 border border-green-400 text-green-700 rounded-md text-sm">
                  {success}
                </div>
              )}
            </>
          )}
        </CardContent>
      </Card>
    </AdminLayout>
  );
};

export default DistributeTokens;








src/pages/EndIco.js



import React, { useState, useEffect } from 'react';
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { PublicKey } from '@solana/web3.js';
import { getProgram } from '../utils/anchor-connection';
import { formatSol } from '../utils/formatters';
import { isAdminWallet } from '../utils/admin-check';
import AdminLayout from '../components/AdminLayout';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "../components/ui/card";
import { Button } from "../components/ui/button";

const EndIco = () => {
  const { connection } = useConnection();
  const wallet = useWallet();
  const [icoData, setIcoData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [ending, setEnding] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');

  useEffect(() => {
    if (wallet.publicKey && isAdminWallet(wallet.publicKey)) {
      fetchIcoData();
    }
  }, [connection, wallet.publicKey]);

  const fetchIcoData = async () => {
    if (!wallet.publicKey) return;

    setLoading(true);
    setError('');

    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from('ico')],
        program.programId
      );
      const data = await program.account.icoAccount.fetch(icoAccount);
      setIcoData(data);
    } catch (err) {
      console.error('Error fetching ICO data:', err);
      setError('Failed to fetch ICO data. Please try again later.');
    } finally {
      setLoading(false);
    }
  };

  const handleEndIco = async () => {
    if (!wallet.publicKey || !wallet.signTransaction) return;

    setEnding(true);
    setError('');
    setSuccess('');

    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from('ico')],
        program.programId
      );

      const tx = await program.methods
        .endIco()
        .accounts({
          icoAccount,
          authority: wallet.publicKey,
        })
        .rpc();

      setSuccess(`ICO ended successfully! Transaction ID: ${tx}`);
      await fetchIcoData();
    } catch (err) {
      console.error('Error ending ICO:', err);
      setError('Failed to end ICO. Please try again later.');
    } finally {
      setEnding(false);
    }
  };

  if (!wallet.publicKey || !isAdminWallet(wallet.publicKey)) {
    return (
      <AdminLayout>
        <Card>
          <CardHeader>
            <CardTitle>End ICO</CardTitle>
            <CardDescription>You do not have permission to access this page.</CardDescription>
          </CardHeader>
        </Card>
      </AdminLayout>
    );
  }

  return (
    <AdminLayout>
      <Card>
        <CardHeader>
          <CardTitle>End ICO</CardTitle>
          <CardDescription>Finalize and end the current ICO</CardDescription>
        </CardHeader>
        <CardContent>
          {loading ? (
            <div className="text-center py-12">
              <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto"></div>
              <p className="mt-4 text-gray-600">Loading ICO data...</p>
            </div>
          ) : (
            <>
              <div className="space-y-4 mb-6">
                <div>
                  <p className="text-sm font-medium text-gray-500">Total Supply:</p>
                  <p className="text-lg font-semibold">{formatSol(icoData.totalSupply)} SOL</p>
                </div>
                <div>
                  <p className="text-sm font-medium text-gray-500">Tokens Sold:</p>
                  <p className="text-lg font-semibold">{formatSol(icoData.tokensSold)} SOL</p>
                </div>
                <div>
                  <p className="text-sm font-medium text-gray-500">Current Status:</p>
                  <p className="text-lg font-semibold">{icoData.isActive ? 'Active' : 'Inactive'}</p>
                </div>
              </div>
              <Button
                onClick={handleEndIco}
                disabled={ending || !icoData.isActive}
                className="w-full"
              >
                {ending ? 'Ending ICO...' : 'End ICO'}
              </Button>
              {error && (
                <div className="mt-4 p-4 bg-red-100 border border-red-400 text-red-700 rounded-md text-sm">
                  {error}
                </div>
              )}
              {success && (
                <div className="mt-4 p-4 bg-green-100 border border-green-400 text-green-700 rounded-md text-sm">
                  {success}
                </div>
              )}
            </>
          )}
        </CardContent>
      </Card>
    </AdminLayout>
  );
};

export default EndIco;









src/pages/IcoAnalytics.js






import React, { useState, useEffect } from 'react';
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { PublicKey } from '@solana/web3.js';
import { getProgram } from '../utils/anchor-connection';
import { formatSol } from '../utils/formatters';
import { motion } from 'framer-motion';
import {
  AreaChart,
  Area,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  PieChart,
  Pie,
  Cell,
  BarChart,
  Bar,
  Legend
} from 'recharts';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "../components/ui/cardTitle";
import { Skeleton } from "../components/ui/skeleton";

const COLORS = ['#0088FE', '#00C49F', '#FFBB28', '#FF8042'];

const IcoAnalytics = () => {
  const { connection } = useConnection();
  const wallet = useWallet();
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  const [analyticsData, setAnalyticsData] = useState(null);

  useEffect(() => {
    if (wallet.publicKey) {
      fetchAnalyticsData();
    }
  }, [connection, wallet.publicKey]);

  const fetchAnalyticsData = async () => {
    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from('ico')],
        program.programId
      );
      const icoData = await program.account.icoAccount.fetch(icoAccount);

      // Get all purchase accounts
      const purchaseAccounts = await connection.getProgramAccounts(program.programId, {
        filters: [
          { dataSize: program.account.purchaseAccount.size },
          { memcmp: { offset: 8, bytes: icoAccount.toBase58() } },
        ],
      });

      const purchases = await Promise.all(
        purchaseAccounts.map(async (account) => {
          const purchaseData = await program.account.purchaseAccount.fetch(account.pubkey);
          return {
            amount: purchaseData.amount.toNumber() / 1e9,
            timestamp: purchaseData.timestamp.toNumber() * 1000,
            buyer: purchaseData.buyer.toString(),
          };
        })
      );

      // Sort purchases by timestamp
      purchases.sort((a, b) => a.timestamp - b.timestamp);

      // Calculate cumulative amounts
      let cumulative = 0;
      const timeSeriesData = purchases.map(p => {
        cumulative += p.amount;
        return {
          timestamp: new Date(p.timestamp).toLocaleDateString(),
          amount: p.amount,
          cumulative
        };
      });

      // Calculate distribution data
      const uniqueBuyers = [...new Set(purchases.map(p => p.buyer))];
      const distributionData = uniqueBuyers.map(buyer => {
        const totalAmount = purchases
          .filter(p => p.buyer === buyer)
          .reduce((sum, p) => sum + p.amount, 0);
        return {
          buyer: buyer.slice(0, 4) + '...' + buyer.slice(-4),
          amount: totalAmount
        };
      });

      setAnalyticsData({
        totalSupply: icoData.totalSupply.toNumber() / 1e9,
        tokensSold: icoData.tokensSold.toNumber() / 1e9,
        timeSeriesData,
        distributionData,
        roundType: Object.keys(icoData.roundType)[0],
      });
    } catch (err) {
      console.error('Error fetching analytics data:', err);
      setError('Failed to fetch analytics data');
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return (
      <div className="space-y-6">
        <Skeleton className="h-[400px] w-full" />
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <Skeleton className="h-[300px]" />
          <Skeleton className="h-[300px]" />
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>Error</CardTitle>
          <CardDescription>{error}</CardDescription>
        </CardHeader>
      </Card>
    );
  }

  return (
    <div className="space-y-6">
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5 }}
      >
        <Card>
          <CardHeader>
            <CardTitle>Token Sales Over Time</CardTitle>
            <CardDescription>Cumulative token sales progression</CardDescription>
          </CardHeader>
          <CardContent className="h-[400px]">
            <ResponsiveContainer width="100%" height="100%">
              <AreaChart data={analyticsData.timeSeriesData}>
                <defs>
                  <linearGradient id="colorAmount" x1="0" y1="0" x2="0" y2="1">
                    <stop offset="5%" stopColor="#0088FE" stopOpacity={0.8}/>
                    <stop offset="95%" stopColor="#0088FE" stopOpacity={0}/>
                  </linearGradient>
                </defs>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="timestamp" />
                <YAxis />
                <Tooltip />
                <Area
                  type="monotone"
                  dataKey="cumulative"
                  stroke="#0088FE"
                  fillOpacity={1}
                  fill="url(#colorAmount)"
                />
              </AreaChart>
            </ResponsiveContainer>
          </CardContent>
        </Card>
      </motion.div>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <motion.div
          initial={{ opacity: 0, x: -20 }}
          animate={{ opacity: 1, x: 0 }}
          transition={{ duration: 0.5, delay: 0.2 }}
        >
          <Card>
            <CardHeader>
              <CardTitle>Token Distribution</CardTitle>
              <CardDescription>Distribution among investors</CardDescription>
            </CardHeader>
            <CardContent className="h-[300px]">
              <ResponsiveContainer width="100%" height="100%">
                <PieChart>
                  <Pie
                    data={analyticsData.distributionData}
                    dataKey="amount"
                    nameKey="buyer"
                    cx="50%"
                    cy="50%"
                    outerRadius={80}
                    label
                  >
                    {analyticsData.distributionData.map((entry, index) => (
                      <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                    ))}
                  </Pie>
                  <Tooltip />
                  <Legend />
                </PieChart>
              </ResponsiveContainer>
            </CardContent>
          </Card>
        </motion.div>

        <motion.div
          initial={{ opacity: 0, x: 20 }}
          animate={{ opacity: 1, x: 0 }}
          transition={{ duration: 0.5, delay: 0.4 }}
        >
          <Card>
            <CardHeader>
              <CardTitle>Sales Summary</CardTitle>
              <CardDescription>Current ICO round: {analyticsData.roundType}</CardDescription>
            </CardHeader>
            <CardContent className="h-[300px]">
              <ResponsiveContainer width="100%" height="100%">
                <BarChart
                  data={[
                    {
                      name: 'Token Supply',
                      total: analyticsData.totalSupply,
                      sold: analyticsData.tokensSold,
                      remaining: analyticsData.totalSupply - analyticsData.tokensSold
                    }
                  ]}
                >
                  <CartesianGrid strokeDasharray="3 3" />
                  <XAxis dataKey="name" />
                  <YAxis />
                  <Tooltip />
                  <Legend />
                  <Bar dataKey="sold" stackId="a" fill="#0088FE" name="Sold" />
                  <Bar dataKey="remaining" stackId="a" fill="#00C49F" name="Remaining" />
                </BarChart>
              </ResponsiveContainer>
            </CardContent>
          </Card>
        </motion.div>
      </div>
    </div>
  );
};

export default IcoAnalytics;








src/pages/IcoDetails.js




import React, { useState, useEffect } from 'react';
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { PublicKey } from '@solana/web3.js';
import { getProgram } from '../utils/anchor-connection';
import { formatUnixTimestamp, formatSol } from '../utils/formatters';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "../components/ui/card";

const IcoDetails = () => {
  const { connection } = useConnection();
  const wallet = useWallet();
  const [icoData, setIcoData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');

  useEffect(() => {
    if (wallet.publicKey) {
      fetchIcoDetails();
    }
  }, [connection, wallet.publicKey]);

  const fetchIcoDetails = async () => {
    if (!wallet.publicKey) return;

    setLoading(true);
    setError('');

    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from('ico')],
        program.programId
      );
      const data = await program.account.icoAccount.fetch(icoAccount);
      setIcoData(data);
    } catch (err) {
      console.error('Error fetching ICO details:', err);
      setError('Failed to fetch ICO details. Please try again later.');
    } finally {
      setLoading(false);
    }
  };

  if (!wallet.publicKey) {
    return (
      <div className="text-center py-12">
        <h2 className="text-2xl font-semibold mb-4">ICO Details</h2>
        <p className="text-gray-600">Please connect your wallet to view ICO details.</p>
      </div>
    );
  }

  if (loading) {
    return (
      <div className="text-center py-12">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto"></div>
        <p className="mt-4 text-gray-600">Loading ICO details...</p>
      </div>
    );
  }

  if (error) {
    return (
      <Card className="max-w-lg mx-auto">
        <CardHeader>
          <CardTitle>ICO Details</CardTitle>
        </CardHeader>
        <CardContent>
          <p className="text-red-500">{error}</p>
        </CardContent>
      </Card>
    );
  }

  // const progress = (icoData.tokensSold.toNumber() / icoData.totalSupply.toNumber()) * 100;
  const progress = (parseFloat(icoData.tokensSold.toString()) / parseFloat(icoData.totalSupply.toString())) * 100;

  return (
    <Card className="max-w-4xl mx-auto">
      <CardHeader>
        <CardTitle>ICO Details</CardTitle>
        <CardDescription>Current status and information about the ICO</CardDescription>
      </CardHeader>
      <CardContent className="space-y-6">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <h3 className="text-lg font-semibold mb-2">Total Supply</h3>
            <p className="text-3xl font-bold">{formatSol(icoData.totalSupply.toString())} SOL</p>
          </div>
          <div>
            <h3 className="text-lg font-semibold mb-2">Tokens Sold</h3>
            <p className="text-3xl font-bold">{formatSol(icoData.tokensSold.toString())} SOL</p>
          </div>
        </div>
        <div>
          <h3 className="text-lg font-semibold mb-2">Sale Progress</h3>
          <div className="w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-700">
            <div className="bg-blue-600 h-2.5 rounded-full" style={{ width: `${progress}%` }}></div>
          </div>
          <p className="text-sm text-gray-500 mt-2">{progress.toFixed(2)}% sold</p>
        </div>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <h3 className="text-lg font-semibold mb-2">Current Price</h3>
            <p className="text-2xl font-bold">{formatSol(icoData.currentPublicPrice.toString())} SOL</p>
          </div>
          <div>
            <h3 className="text-lg font-semibold mb-2">Round Type</h3>
            <p className="text-2xl font-bold">{Object.keys(icoData.roundType)[0]}</p>
          </div>
        </div>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <h3 className="text-lg font-semibold mb-2">Start Time</h3>
            <p className="text-xl">{formatUnixTimestamp(icoData.startTime)}</p>
          </div>
          <div>
            <h3 className="text-lg font-semibold mb-2">End Time</h3>
            <p className="text-xl">{formatUnixTimestamp(icoData.startTime.toString() + icoData.duration.toString())}</p>
          </div>
        </div>
        <div>
          <h3 className="text-lg font-semibold mb-2">Status</h3>
          <p className={`text-xl font-bold ${icoData.isActive ? 'text-green-500' : 'text-red-500'}`}>
            {icoData.isActive ? 'Active' : 'Inactive'}
          </p>
        </div>
      </CardContent>
    </Card>
  );
};

export default IcoDetails;







src/pages/InitializeIco.js




import React, { useState } from 'react';
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { PublicKey } from '@solana/web3.js';
import { getProgram } from '../utils/anchor-connection';
import * as anchor from '@project-serum/anchor';
import { isAdminWallet } from '../utils/admin-check';
import { Label } from "../components/ui/label"
import { Button } from "../components/ui/button"
import { Input } from "../components/ui/input"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "../components/ui/cardTitle"
import { Alert, AlertDescription } from "../components/ui/alert"
import { Loader2 } from 'lucide-react'

const InitializeIco = () => {
  const { connection } = useConnection();
  const wallet = useWallet();
  const [formData, setFormData] = useState({
    totalSupply: '',
    seedPrice: '',
    preIcoPrice: '',
    publicPrice: '',
    startTime: '',
    duration: '',
    roundType: 'PreICO',
  });
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');

  const handleInputChange = (e) => {
    const { name, value } = e.target;
    setFormData(prevState => ({
      ...prevState,
      [name]: value
    }));
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!wallet.publicKey || !wallet.signTransaction) {
      setError('Please connect your wallet first');
      return;
    }

    setLoading(true);
    setError('');
    setSuccess('');

    try {
      const program = getProgram(connection, wallet);
      
      // Find the ICO account PDA
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from('ico')],
        program.programId
      );

      // Convert form values to the correct format
      const totalSupply = new anchor.BN(
        Math.floor(parseFloat(formData.totalSupply) * anchor.web3.LAMPORTS_PER_SOL)
      );
      const seedPrice = new anchor.BN(
        Math.floor(parseFloat(formData.seedPrice) * anchor.web3.LAMPORTS_PER_SOL)
      );
      const preIcoPrice = new anchor.BN(
        Math.floor(parseFloat(formData.preIcoPrice) * anchor.web3.LAMPORTS_PER_SOL)
      );
      const publicPrice = new anchor.BN(
        Math.floor(parseFloat(formData.publicPrice) * anchor.web3.LAMPORTS_PER_SOL)
      );
      const startTime = new anchor.BN(Math.floor(new Date(formData.startTime).getTime() / 1000));
      const duration = new anchor.BN(parseInt(formData.duration));

      // Create the token mint account if it doesn't exist
      const tokenMint = new PublicKey(process.env.REACT_APP_TOKEN_MINT_ADDRESS);

      console.log('Initializing ICO with parameters:', {
        totalSupply: totalSupply.toString(),
        seedPrice: seedPrice.toString(),
        preIcoPrice: preIcoPrice.toString(),
        publicPrice: publicPrice.toString(),
        startTime: startTime.toString(),
        duration: duration.toString(),
        roundType: formData.roundType.toLowerCase()
      });

      const tx = await program.methods
        .initialize(
          totalSupply,
          seedPrice,
          preIcoPrice,
          publicPrice,
          startTime,
          duration,
          { [formData.roundType.toLowerCase()]: {} }
        )
        .accounts({
          icoAccount,
          authority: wallet.publicKey,
          tokenMint,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .rpc();

      console.log('Transaction signature:', tx);
      setSuccess(`ICO initialized successfully! Transaction ID: ${tx}`);
      
      // Reset form
      setFormData({
        totalSupply: '',
        seedPrice: '',
        preIcoPrice: '',
        publicPrice: '',
        startTime: '',
        duration: '',
        roundType: 'PreICO',
      });
    } catch (err) {
      console.error('Error initializing ICO:', err);
      setError(err.message || 'Failed to initialize ICO. Please try again later.');
    } finally {
      setLoading(false);
    }
  };

  if (!wallet.publicKey || !isAdminWallet(wallet.publicKey)) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>Access Denied</CardTitle>
          <CardDescription>
            You must connect with an admin wallet to access this page.
          </CardDescription>
        </CardHeader>
      </Card>
    );
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle>Initialize ICO</CardTitle>
        <CardDescription>Set up the initial parameters for your ICO</CardDescription>
      </CardHeader>
      <CardContent>
        <form onSubmit={handleSubmit} className="space-y-6">
          <div className="grid grid-cols-1 gap-6 sm:grid-cols-2">
            <div className="space-y-2">
              <Label htmlFor="totalSupply">Total Supply (SOL)</Label>
              <Input
                id="totalSupply"
                name="totalSupply"
                type="number"
                step="0.000000001"
                value={formData.totalSupply}
                onChange={handleInputChange}
                required
                placeholder="Enter total supply"
              />
            </div>

            <div className="space-y-2">
              <Label htmlFor="seedPrice">Seed Price (SOL)</Label>
              <Input
                id="seedPrice"
                name="seedPrice"
                type="number"
                step="0.000000001"
                value={formData.seedPrice}
                onChange={handleInputChange}
                required
                placeholder="Enter seed price"
              />
            </div>

            <div className="space-y-2">
              <Label htmlFor="preIcoPrice">Pre-ICO Price (SOL)</Label>
              <Input
                id="preIcoPrice"
                name="preIcoPrice"
                type="number"
                step="0.000000001"
                value={formData.preIcoPrice}
                onChange={handleInputChange}
                required
                placeholder="Enter pre-ICO price"
              />
            </div>

            <div className="space-y-2">
              <Label htmlFor="publicPrice">Public Price (SOL)</Label>
              <Input
                id="publicPrice"
                name="publicPrice"
                type="number"
                step="0.000000001"
                value={formData.publicPrice}
                onChange={handleInputChange}
                required
                placeholder="Enter public price"
              />
            </div>

            <div className="space-y-2">
              <Label htmlFor="startTime">Start Time</Label>
              <Input
                id="startTime"
                name="startTime"
                type="datetime-local"
                value={formData.startTime}
                onChange={handleInputChange}
                required
              />
            </div>

            <div className="space-y-2">
              <Label htmlFor="duration">Duration (seconds)</Label>
              <Input
                id="duration"
                name="duration"
                type="number"
                min="1"
                value={formData.duration}
                onChange={handleInputChange}
                required
                placeholder="Enter duration in seconds"
              />
            </div>
          </div>

          <div className="space-y-2">
            <Label htmlFor="roundType">Initial Round Type</Label>
            <select
              id="roundType"
              name="roundType"
              value={formData.roundType}
              onChange={handleInputChange}
              className="w-full rounded-md border border-gray-300 bg-white px-3 py-2 text-sm"
            >
              <option value="PreICO">Pre-ICO</option>
              <option value="PublicICO">Public ICO</option>
            </select>
          </div>

          <Button 
            type="submit" 
            className="w-full" 
            disabled={loading}
          >
            {loading ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                Initializing...
              </>
            ) : (
              'Initialize ICO'
            )}
          </Button>

          {error && (
            <Alert variant="destructive">
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}

          {success && (
            <Alert className="bg-green-50 text-green-800 border-green-500">
              <AlertDescription>{success}</AlertDescription>
            </Alert>
          )}
        </form>
      </CardContent>
    </Card>
  );
};

export default InitializeIco;






src/pages/ManageInvestors.js



import React, { useState, useEffect } from 'react';
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { PublicKey } from '@solana/web3.js';
import { getProgram } from '../utils/anchor-connection';
import { isAdminWallet } from '../utils/admin-check';
import AdminLayout from '../components/AdminLayout';
import { Button, Input, Card, CardContent, CardDescription, CardHeader, CardTitle, Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "../components/ui/cardTitle";

const ManageInvestors = () => {
  const { connection } = useConnection();
  const wallet = useWallet();
  const [investors, setInvestors] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  const [newInvestor, setNewInvestor] = useState('');
  const [addingInvestor, setAddingInvestor] = useState(false);

  useEffect(() => {
    if (wallet.publicKey && isAdminWallet(wallet.publicKey)) {
      fetchInvestors();
    }
  }, [connection, wallet.publicKey]);

  const fetchInvestors = async () => {
    if (!wallet.publicKey) return;

    setLoading(true);
    setError('');

    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from('ico')],
        program.programId
      );
      const icoData = await program.account.icoAccount.fetch(icoAccount);

      setInvestors(icoData.seedInvestors.map(investor => ({
        address: investor.toString(),
        isWhitelisted: true
      })));
    } catch (err) {
      console.error('Error fetching investors:', err);
      setError('Failed to fetch investors. Please try again later.');
    } finally {
      setLoading(false);
    }
  };

  const handleAddInvestor = async (e) => {
    e.preventDefault();
    if (!wallet.publicKey || !isAdminWallet(wallet.publicKey)) return;

    setAddingInvestor(true);
    setError('');

    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from('ico')],
        program.programId
      );

      await program.methods
        .addSeedInvestor(new PublicKey(newInvestor))
        .accounts({
          icoAccount,
          authority: wallet.publicKey,
        })
        .rpc();

      setNewInvestor('');
      await fetchInvestors();
    } catch (err) {
      console.error('Error adding investor:', err);
      setError('Failed to add investor. Please try again later.');
    } finally {
      setAddingInvestor(false);
    }
  };

  const handleRemoveInvestor = async (investorAddress) => {
    if (!wallet.publicKey || !isAdminWallet(wallet.publicKey)) return;

    setError('');

    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from('ico')],
        program.programId
      );

      await program.methods
        .removeSeedInvestor(new PublicKey(investorAddress))
        .accounts({
          icoAccount,
          authority: wallet.publicKey,
        })
        .rpc();

      await fetchInvestors();
    } catch (err) {
      console.error('Error removing investor:', err);
      setError('Failed to remove investor. Please try again later.');
    }
  };

  if (!wallet.publicKey || !isAdminWallet(wallet.publicKey)) {
    return (
      <AdminLayout>
        <Card>
          <CardHeader>
            <CardTitle>Manage Investors</CardTitle>
            <CardDescription>You do not have permission to access this page.</CardDescription>
          </CardHeader>
        </Card>
      </AdminLayout>
    );
  }

  return (
    <AdminLayout>
      <Card>
        <CardHeader>
          <CardTitle>Manage Investors</CardTitle>
          <CardDescription>Add or remove seed investors for your ICO</CardDescription>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleAddInvestor} className="mb-6 flex gap-4">
            <Input
              type="text"
              value={newInvestor}
              onChange={(e) => setNewInvestor(e.target.value)}
              placeholder="Investor Public Key"
              className="flex-grow"
            />
            <Button type="submit" disabled={addingInvestor}>
              {addingInvestor ? 'Adding...' : 'Add Investor'}
            </Button>
          </form>
          {loading ? (
            <div className="text-center py-12">
              <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto"></div>
              <p className="mt-4 text-gray-600">Loading investors...</p>
            </div>
          ) : error ? (
            <div className="p-4 bg-red-100 border border-red-400 text-red-700 rounded-md text-sm">
              {error}
            </div>
          ) : (
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Investor Address</TableHead>
                  <TableHead>Status</TableHead>
                  <TableHead>Action</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {investors.map((investor, index) => (
                  <TableRow key={index}>
                    <TableCell>{investor.address}</TableCell>
                    <TableCell>{investor.isWhitelisted ? 'Whitelisted' : 'Not Whitelisted'}</TableCell>
                    <TableCell>
                      <Button
                        onClick={() => handleRemoveInvestor(investor.address)}
                        variant="destructive"
                        size="sm"
                      >
                        Remove
                      </Button>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          )}
        </CardContent>
      </Card>
    </AdminLayout>
  );
};

export default ManageInvestors;
















src/pages/Staking.js






"use client"

import { useState, useEffect } from "react"
import { useConnection, useWallet } from "@solana/wallet-adapter-react"
import { PublicKey } from "@solana/web3.js"
import { getStakingProgram } from "../utils/anchor-connection"
import * as anchor from "@project-serum/anchor"
import { TOKEN_PROGRAM_ID } from "@solana/spl-token"
import { formatSol } from "../utils/formatters"
import { Label } from "../components/ui/label"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "../components/ui/card"
import { Input } from "../components/ui/input"
import { Button } from "../components/ui/button"
import { Alert, AlertDescription } from "../components/ui/alert"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "../components/ui/tabs"
import { Loader2 } from "lucide-react"

const Staking = () => {
  const { connection } = useConnection()
  const wallet = useWallet()
  const [stakeAmount, setStakeAmount] = useState("")
  const [unstakeAmount, setUnstakeAmount] = useState("")
  const [couponCode, setCouponCode] = useState("")
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState("")
  const [success, setSuccess] = useState("")
  const [stakingData, setStakingData] = useState(null)
  const [stakerInfo, setStakerInfo] = useState(null)
  const [stakeRecords, setStakeRecords] = useState([])
  const [activeTab, setActiveTab] = useState("stake")

  useEffect(() => {
    if (wallet.publicKey) {
      fetchStakingData()
    }
  }, [connection, wallet.publicKey])

  const fetchStakingData = async () => {
    if (!wallet.publicKey) return

    try {
      setLoading(true)
      const program = getStakingProgram(connection, wallet)

      // Fetch staking account
      const [stakingAccount] = await PublicKey.findProgramAddress([Buffer.from("staking_account")], program.programId)
      const stakingData = await program.account.stakingAccount.fetch(stakingAccount)
      setStakingData(stakingData)

      // Fetch staker info
      try {
        const [stakerInfoAccount] = await PublicKey.findProgramAddress(
          [Buffer.from("staker_info"), stakingAccount.toBuffer(), wallet.publicKey.toBuffer()],
          program.programId,
        )
        const stakerInfo = await program.account.stakerInfo.fetch(stakerInfoAccount)
        setStakerInfo(stakerInfo)
      } catch (err) {
        console.log("No staker info found, user has not staked yet")
      }

      // Fetch stake records
      const stakeAccountsFilters = [
        { dataSize: program.account.stakeRecord.size },
        { memcmp: { offset: 8, bytes: wallet.publicKey.toBase58() } }, // owner field
      ]

      const stakeAccounts = await connection.getProgramAccounts(program.programId, {
        filters: stakeAccountsFilters,
      })

      const records = await Promise.all(
        stakeAccounts.map(async (account) => {
          const stakeRecord = await program.account.stakeRecord.fetch(account.pubkey)
          return {
            pubkey: account.pubkey,
            ...stakeRecord,
          }
        }),
      )

      setStakeRecords(records)
      setLoading(false)
    } catch (err) {
      console.error("Error fetching staking data:", err)
      setError("Failed to fetch staking data. Please try again later.")
      setLoading(false)
    }
  }

  const handleStake = async (e) => {
    e.preventDefault()
    if (!wallet.publicKey || !wallet.signTransaction || !stakingData) return

    setLoading(true)
    setError("")
    setSuccess("")

    try {
      const program = getStakingProgram(connection, wallet)
      const [stakingAccount] = await PublicKey.findProgramAddress([Buffer.from("staking_account")], program.programId)

      // Get token accounts
      const tokenMint = stakingData.tokenMint

      // Find the user's token account for this mint
      const userTokenAccounts = await connection.getParsedTokenAccountsByOwner(wallet.publicKey, { mint: tokenMint })

      if (userTokenAccounts.value.length === 0) {
        throw new Error("No token account found for this mint. Please make sure you have the token.")
      }

      const userTokenAccount = userTokenAccounts.value[0].pubkey

      // Find the admin's staking wallet
      const adminTokenAccounts = await connection.getParsedTokenAccountsByOwner(stakingData.admin, { mint: tokenMint })

      if (adminTokenAccounts.value.length === 0) {
        throw new Error("Admin staking wallet not found.")
      }

      const adminStakingWallet = adminTokenAccounts.value[0].pubkey

      // Create a new stake record account
      const stakeRecord = anchor.web3.Keypair.generate()

      // Convert amount to lamports
      const amountLamports = new anchor.BN(Number.parseFloat(stakeAmount) * anchor.web3.LAMPORTS_PER_SOL)

      // Find staker info PDA
      const [stakerInfoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from("staker_info"), stakingAccount.toBuffer(), wallet.publicKey.toBuffer()],
        program.programId,
      )

      // Call the stakeTokens instruction
      const tx = await program.methods
        .stakeTokens(amountLamports, couponCode ? couponCode : null)
        .accounts({
          stakingAccount,
          stakeRecord: stakeRecord.publicKey,
          stakerInfo: stakerInfoAccount,
          stakerTokenAccount: userTokenAccount,
          adminStakingWallet,
          staker: wallet.publicKey,
          tokenProgram: TOKEN_PROGRAM_ID,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([stakeRecord])
        .rpc()

      setSuccess(`Tokens staked successfully! Transaction ID: ${tx}`)
      setStakeAmount("")
      setCouponCode("")
      await fetchStakingData() // Refresh staking data
    } catch (err) {
      console.error("Error staking tokens:", err)
      setError(`Staking failed: ${err.message}`)
    } finally {
      setLoading(false)
    }
  }

  const handleUnstake = async (e) => {
    e.preventDefault()
    if (!wallet.publicKey || !wallet.signTransaction || stakeRecords.length === 0) return

    setLoading(true)
    setError("")
    setSuccess("")

    try {
      const program = getStakingProgram(connection, wallet)
      const [stakingAccount] = await PublicKey.findProgramAddress([Buffer.from("staking_account")], program.programId)

      // Get the selected stake record
      const stakeRecord = stakeRecords[0] // For simplicity, using the first record

      // Get token accounts
      const tokenMint = stakingData.tokenMint

      // Find the user's token account for this mint
      const userTokenAccounts = await connection.getParsedTokenAccountsByOwner(wallet.publicKey, { mint: tokenMint })

      if (userTokenAccounts.value.length === 0) {
        throw new Error("No token account found for this mint.")
      }

      const userTokenAccount = userTokenAccounts.value[0].pubkey

      // Find the admin's staking wallet
      const adminTokenAccounts = await connection.getParsedTokenAccountsByOwner(stakingData.admin, { mint: tokenMint })

      if (adminTokenAccounts.value.length === 0) {
        throw new Error("Admin staking wallet not found.")
      }

      const adminStakingWallet = adminTokenAccounts.value[0].pubkey

      // Find staker info PDA
      const [stakerInfoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from("staker_info"), stakingAccount.toBuffer(), wallet.publicKey.toBuffer()],
        program.programId,
      )

      // Convert amount to lamports
      const amountLamports = new anchor.BN(Number.parseFloat(unstakeAmount) * anchor.web3.LAMPORTS_PER_SOL)

      // Call the unstakeCombined instruction
      const tx = await program.methods
        .unstakeCombined(amountLamports)
        .accounts({
          stakingAccount,
          stakeRecord: stakeRecord.pubkey,
          stakerInfo: stakerInfoAccount,
          stakerTokenAccount: userTokenAccount,
          adminStakingWallet,
          tokenMint: stakingData.tokenMint,
          staker: wallet.publicKey,
          owner: stakingData.admin, // This is the admin who can sign for token transfers
          tokenProgram: TOKEN_PROGRAM_ID,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .rpc()

      setSuccess(`Tokens unstaked successfully! Transaction ID: ${tx}`)
      setUnstakeAmount("")
      await fetchStakingData() // Refresh staking data
    } catch (err) {
      console.error("Error unstaking tokens:", err)
      setError(`Unstaking failed: ${err.message}`)
    } finally {
      setLoading(false)
    }
  }

  const calculateRewardRate = () => {
    if (!stakingData) return "0%"

    if (stakerInfo && stakerInfo.totalStaked.toNumber() >= 1000) {
      return `${stakingData.highTierFee}%`
    } else if (stakerInfo && stakerInfo.totalStaked.toNumber() >= 500) {
      return `${stakingData.midTierFee}%`
    } else {
      return `${stakingData.lowTierFee}%`
    }
  }

  const calculateLockupPeriod = (tier) => {
    switch (tier) {
      case 3:
        return "180 days"
      case 2:
        return "90 days"
      case 1:
        return "30 days"
      default:
        return "No lockup"
    }
  }

  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle>Staking Dashboard</CardTitle>
          <CardDescription>Stake your tokens to earn rewards</CardDescription>
        </CardHeader>
        <CardContent>
          {loading && !stakingData ? (
            <div className="flex justify-center items-center py-8">
              <Loader2 className="h-8 w-8 animate-spin text-blue-500" />
            </div>
          ) : (
            <>
              {stakerInfo && (
                <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                  <div className="bg-gray-50 p-4 rounded-lg">
                    <p className="text-sm text-gray-500">Total Staked</p>
                    <p className="text-2xl font-bold">{formatSol(stakerInfo.totalStaked)} SOL</p>
                  </div>
                  <div className="bg-gray-50 p-4 rounded-lg">
                    <p className="text-sm text-gray-500">Reward Rate</p>
                    <p className="text-2xl font-bold">{calculateRewardRate()}</p>
                  </div>
                  <div className="bg-gray-50 p-4 rounded-lg">
                    <p className="text-sm text-gray-500">Spin Count</p>
                    <p className="text-2xl font-bold">{stakerInfo.spinCount}</p>
                  </div>
                </div>
              )}

              <Tabs defaultValue="stake" value={activeTab} onValueChange={setActiveTab} className="w-full">
                <TabsList className="grid w-full grid-cols-2">
                  <TabsTrigger value="stake">Stake</TabsTrigger>
                  <TabsTrigger value="unstake">Unstake</TabsTrigger>
                </TabsList>
                <TabsContent value="stake">
                  <form onSubmit={handleStake} className="space-y-4 pt-4">
                    <div className="space-y-2">
                      <Label htmlFor="stakeAmount">Amount to Stake (SOL):</Label>
                      <Input
                        type="number"
                        id="stakeAmount"
                        value={stakeAmount}
                        onChange={(e) => setStakeAmount(e.target.value)}
                        required
                        min="0"
                        step="0.000000001"
                      />
                    </div>
                    <div className="space-y-2">
                      <Label htmlFor="couponCode">Coupon Code (Optional):</Label>
                      <Input
                        type="text"
                        id="couponCode"
                        value={couponCode}
                        onChange={(e) => setCouponCode(e.target.value)}
                      />
                    </div>
                    <Button type="submit" disabled={loading || !wallet.publicKey} className="w-full">
                      {loading ? (
                        <>
                          <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                          Processing...
                        </>
                      ) : (
                        "Stake Tokens"
                      )}
                    </Button>
                  </form>
                </TabsContent>
                <TabsContent value="unstake">
                  {stakeRecords.length > 0 ? (
                    <form onSubmit={handleUnstake} className="space-y-4 pt-4">
                      <div className="space-y-2">
                        <Label htmlFor="unstakeAmount">Amount to Unstake (SOL):</Label>
                        <Input
                          type="number"
                          id="unstakeAmount"
                          value={unstakeAmount}
                          onChange={(e) => setUnstakeAmount(e.target.value)}
                          required
                          min="0"
                          max={stakeRecords[0].amount.toNumber() / anchor.web3.LAMPORTS_PER_SOL}
                          step="0.000000001"
                        />
                      </div>
                      <Button type="submit" disabled={loading || !wallet.publicKey} className="w-full">
                        {loading ? (
                          <>
                            <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                            Processing...
                          </>
                        ) : (
                          "Unstake Tokens"
                        )}
                      </Button>
                    </form>
                  ) : (
                    <div className="py-8 text-center">
                      <p className="text-gray-500">You don't have any staked tokens to unstake.</p>
                    </div>
                  )}
                </TabsContent>
              </Tabs>

              {error && (
                <Alert variant="destructive" className="mt-4">
                  <AlertDescription>{error}</AlertDescription>
                </Alert>
              )}
              {success && (
                <Alert className="mt-4 bg-green-50 text-green-800 border-green-500">
                  <AlertDescription>{success}</AlertDescription>
                </Alert>
              )}
            </>
          )}
        </CardContent>
      </Card>

      {stakeRecords.length > 0 && (
        <Card>
          <CardHeader>
            <CardTitle>Your Stake Records</CardTitle>
            <CardDescription>View your active stake records</CardDescription>
          </CardHeader>
          <CardContent>
            <div className="space-y-4">
              {stakeRecords.map((record, index) => (
                <div key={index} className="border rounded-lg p-4">
                  <div className="grid grid-cols-2 gap-4">
                    <div>
                      <p className="text-sm text-gray-500">Amount Staked</p>
                      <p className="font-medium">{formatSol(record.amount)} SOL</p>
                    </div>
                    <div>
                      <p className="text-sm text-gray-500">Tier</p>
                      <p className="font-medium">Tier {record.tier}</p>
                    </div>
                    <div>
                      <p className="text-sm text-gray-500">Staked On</p>
                      <p className="font-medium">{new Date(record.stakeTimestamp * 1000).toLocaleDateString()}</p>
                    </div>
                    <div>
                      <p className="text-sm text-gray-500">Lockup Period</p>
                      <p className="font-medium">{calculateLockupPeriod(record.tier)}</p>
                    </div>
                    <div>
                      <p className="text-sm text-gray-500">Unlock Date</p>
                      <p className="font-medium">{new Date(record.endTimestamp * 1000).toLocaleDateString()}</p>
                    </div>
                    <div>
                      <p className="text-sm text-gray-500">Spin Count</p>
                      <p className="font-medium">{record.spinCount}</p>
                    </div>
                  </div>
                </div>
              ))}
            </div>
          </CardContent>
        </Card>
      )}
    </div>
  )
}

export default Staking








src/pages/StakingAdmin.js







"use client";

import { useState, useEffect } from "react";
import { useConnection, useWallet } from "@solana/wallet-adapter-react";
import { PublicKey } from "@solana/web3.js";
import { getStakingProgram } from "../utils/anchor-connection";
import * as anchor from "@project-serum/anchor";
import { isAdminWallet } from "../utils/admin-check";
import AdminLayout from "../components/AdminLayout";
import { Label } from "../components/ui/label";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "../components/ui/card";
import { Input } from "../components/ui/input";
import { Button } from "../components/ui/button";
import { Alert, AlertDescription } from "../components/ui/alert";
import {
  Tabs,
  TabsContent,
  TabsList,
  TabsTrigger,
} from "../components/ui/tabs";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "../components/ui/select";
import { Loader2 } from "lucide-react";

const StakingAdmin = () => {
  const { connection } = useConnection();
  const wallet = useWallet();
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  const [success, setSuccess] = useState("");
  const [stakingData, setStakingData] = useState(null);
  const [activeTab, setActiveTab] = useState("update");

  // Update staking parameters form
  const [updateForm, setUpdateForm] = useState({
    lockupPeriod: "",
    lowTierFee: "",
    midTierFee: "",
    highTierFee: "",
  });

  // Create coupon form
  const [couponForm, setCreateCouponForm] = useState({
    code: "",
    bonusType: "Percentage",
    bonusValue: "",
    duration: "",
    minStakeAmount: "",
    maxUses: "",
    couponCategory: "NewUser",
  });

  useEffect(() => {
    if (wallet.publicKey && isAdminWallet(wallet.publicKey)) {
      fetchStakingData();
    }
  }, [connection, wallet.publicKey]);

  const fetchStakingData = async () => {
    if (!wallet.publicKey) return;

    try {
      setLoading(true);
      const program = getStakingProgram(connection, wallet);

      // Fetch staking account
      const [stakingAccount] = await PublicKey.findProgramAddress(
        [Buffer.from("staking_account")],
        program.programId
      );
      const data = await program.account.stakingAccount.fetch(stakingAccount);
      setStakingData(data);

      // Set form values
      setUpdateForm({
        lockupPeriod: data.lockupPeriod.toString(),
        lowTierFee: data.lowTierFee.toString(),
        midTierFee: data.midTierFee.toString(),
        highTierFee: data.highTierFee.toString(),
      });

      setLoading(false);
    } catch (err) {
      console.error("Error fetching staking data:", err);
      setError("Failed to fetch staking data. Please try again later.");
      setLoading(false);
    }
  };

  const handleUpdateStakingParams = async (e) => {
    e.preventDefault();
    if (!wallet.publicKey || !isAdminWallet(wallet.publicKey)) return;

    setLoading(true);
    setError("");
    setSuccess("");

    try {
      const program = getStakingProgram(connection, wallet);
      const [stakingAccount] = await PublicKey.findProgramAddress(
        [Buffer.from("staking_account")],
        program.programId
      );

      // Convert form values
      const lockupPeriod = new anchor.BN(
        Number.parseInt(updateForm.lockupPeriod)
      );
      const lowTierFee = Number.parseFloat(updateForm.lowTierFee);
      const midTierFee = Number.parseFloat(updateForm.midTierFee);
      const highTierFee = Number.parseFloat(updateForm.highTierFee);

      // Call the update instruction
      const tx = await program.methods
        .update(lockupPeriod, lowTierFee, midTierFee, highTierFee)
        .accounts({
          stakingAccount,
          admin: wallet.publicKey,
        })
        .rpc();

      setSuccess(
        `Staking parameters updated successfully! Transaction ID: ${tx}`
      );
      await fetchStakingData(); // Refresh staking data
    } catch (err) {
      console.error("Error updating staking parameters:", err);
      setError(`Update failed: ${err.message}`);
    } finally {
      setLoading(false);
    }
  };

  const handleCreateCoupon = async (e) => {
    e.preventDefault();
    if (!wallet.publicKey || !isAdminWallet(wallet.publicKey)) return;

    setLoading(true);
    setError("");
    setSuccess("");

    try {
      const program = getStakingProgram(connection, wallet);
      const [stakingAccount] = await PublicKey.findProgramAddress(
        [Buffer.from("staking_account")],
        program.programId
      );

      // Convert form values
      const bonusType = { [couponForm.bonusType.toLowerCase()]: {} };
      const bonusValue = Number.parseFloat(couponForm.bonusValue);
      const duration = new anchor.BN(Number.parseInt(couponForm.duration));
      const minStakeAmount = new anchor.BN(
        Number.parseFloat(couponForm.minStakeAmount) *
          anchor.web3.LAMPORTS_PER_SOL
      );
      const maxUses = new anchor.BN(Number.parseInt(couponForm.maxUses));
      const couponCategory = { [couponForm.couponCategory]: {} };

      // Call the createCoupon instruction
      const tx = await program.methods
        .createCoupon(
          couponForm.code,
          bonusType,
          bonusValue,
          duration,
          minStakeAmount,
          maxUses,
          couponCategory
        )
        .accounts({
          stakingAccount,
          admin: wallet.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .rpc();

      setSuccess(`Coupon created successfully! Transaction ID: ${tx}`);

      // Reset form
      setCreateCouponForm({
        code: "",
        bonusType: "Percentage",
        bonusValue: "",
        duration: "",
        minStakeAmount: "",
        maxUses: "",
        couponCategory: "NewUser",
      });

      await fetchStakingData(); // Refresh staking data
    } catch (err) {
      console.error("Error creating coupon:", err);
      setError(`Coupon creation failed: ${err.message}`);
    } finally {
      setLoading(false);
    }
  };

  const handleUpdateFormChange = (e) => {
    const { name, value } = e.target;
    setUpdateForm((prev) => ({
      ...prev,
      [name]: value,
    }));
  };

  const handleCouponFormChange = (e) => {
    const { name, value } = e.target;
    setCreateCouponForm((prev) => ({
      ...prev,
      [name]: value,
    }));
  };

  const handleSelectChange = (name, value) => {
    setCreateCouponForm((prev) => ({
      ...prev,
      [name]: value,
    }));
  };

  if (!wallet.publicKey || !isAdminWallet(wallet.publicKey)) {
    return (
      <AdminLayout>
        <Card>
          <CardHeader>
            <CardTitle>Staking Administration</CardTitle>
            <CardDescription>
              You do not have permission to access this page.
            </CardDescription>
          </CardHeader>
        </Card>
      </AdminLayout>
    );
  }

  return (
    <AdminLayout>
      <Card>
        <CardHeader>
          <CardTitle>Staking Administration</CardTitle>
          <CardDescription>
            Manage staking parameters and coupons
          </CardDescription>
        </CardHeader>
        <CardContent>
          {loading && !stakingData ? (
            <div className="flex justify-center items-center py-8">
              <Loader2 className="h-8 w-8 animate-spin text-blue-500" />
            </div>
          ) : (
            <Tabs
              defaultValue="update"
              value={activeTab}
              onValueChange={setActiveTab}
              className="w-full"
            >
              <TabsList className="grid w-full grid-cols-2">
                <TabsTrigger value="update">Update Parameters</TabsTrigger>
                <TabsTrigger value="coupons">Create Coupon</TabsTrigger>
              </TabsList>

              <TabsContent value="update">
                <form
                  onSubmit={handleUpdateStakingParams}
                  className="space-y-4 pt-4"
                >
                  <div className="space-y-2">
                    <Label htmlFor="lockupPeriod">
                      Lockup Period (seconds):
                    </Label>
                    <Input
                      type="number"
                      id="lockupPeriod"
                      name="lockupPeriod"
                      value={updateForm.lockupPeriod}
                      onChange={handleUpdateFormChange}
                      required
                      min="0"
                    />
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="lowTierFee">Low Tier Fee (%):</Label>
                    <Input
                      type="number"
                      id="lowTierFee"
                      name="lowTierFee"
                      value={updateForm.lowTierFee}
                      onChange={handleUpdateFormChange}
                      required
                      min="0"
                      step="0.01"
                    />
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="midTierFee">Mid Tier Fee (%):</Label>
                    <Input
                      type="number"
                      id="midTierFee"
                      name="midTierFee"
                      value={updateForm.midTierFee}
                      onChange={handleUpdateFormChange}
                      required
                      min="0"
                      step="0.01"
                    />
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="highTierFee">High Tier Fee (%):</Label>
                    <Input
                      type="number"
                      id="highTierFee"
                      name="highTierFee"
                      value={updateForm.highTierFee}
                      onChange={handleUpdateFormChange}
                      required
                      min="0"
                      step="0.01"
                    />
                  </div>
                  <Button type="submit" disabled={loading} className="w-full">
                    {loading ? (
                      <>
                        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                        Updating...
                      </>
                    ) : (
                      "Update Parameters"
                    )}
                  </Button>
                </form>
              </TabsContent>

              <TabsContent value="coupons">
                <form onSubmit={handleCreateCoupon} className="space-y-4 pt-4">
                  <div className="space-y-2">
                    <Label htmlFor="code">Coupon Code:</Label>
                    <Input
                      type="text"
                      id="code"
                      name="code"
                      value={couponForm.code}
                      onChange={handleCouponFormChange}
                      required
                    />
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="bonusType">Bonus Type:</Label>
                    <Select
                      value={couponForm.bonusType}
                      onValueChange={(value) =>
                        handleSelectChange("bonusType", value)
                      }
                    >
                      <SelectTrigger>
                        <SelectValue placeholder="Select bonus type" />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="Percentage">Percentage</SelectItem>
                        <SelectItem value="FixedAmount">
                          Fixed Amount
                        </SelectItem>
                        <SelectItem value="SpinBonus">Spin Bonus</SelectItem>
                      </SelectContent>
                    </Select>
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="bonusValue">Bonus Value:</Label>
                    <Input
                      type="number"
                      id="bonusValue"
                      name="bonusValue"
                      value={couponForm.bonusValue}
                      onChange={handleCouponFormChange}
                      required
                      min="0"
                      step="0.01"
                    />
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="duration">Duration (seconds):</Label>
                    <Input
                      type="number"
                      id="duration"
                      name="duration"
                      value={couponForm.duration}
                      onChange={handleCouponFormChange}
                      required
                      min="0"
                    />
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="minStakeAmount">
                      Minimum Stake Amount (SOL):
                    </Label>
                    <Input
                      type="number"
                      id="minStakeAmount"
                      name="minStakeAmount"
                      value={couponForm.minStakeAmount}
                      onChange={handleCouponFormChange}
                      required
                      min="0"
                      step="0.000000001"
                    />
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="maxUses">Maximum Uses:</Label>
                    <Input
                      type="number"
                      id="maxUses"
                      name="maxUses"
                      value={couponForm.maxUses}
                      onChange={handleCouponFormChange}
                      required
                      min="1"
                    />
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="couponCategory">Coupon Category:</Label>
                    <Select
                      value={couponForm.couponCategory}
                      onValueChange={(value) =>
                        handleSelectChange("couponCategory", value)
                      }
                    >
                      <SelectTrigger>
                        <SelectValue placeholder="Select category" />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="NewUser">New User</SelectItem>
                        <SelectItem value="Referral">Referral</SelectItem>
                        <SelectItem value="LoyaltyReward">
                          Loyalty Reward
                        </SelectItem>
                        <SelectItem value="SeasonalPromo">
                          Seasonal Promo
                        </SelectItem>
                        <SelectItem value="Exclusive">Exclusive</SelectItem>
                      </SelectContent>
                    </Select>
                  </div>
                  <Button type="submit" disabled={loading} className="w-full">
                    {loading ? (
                      <>
                        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                        Creating...
                      </>
                    ) : (
                      "Create Coupon"
                    )}
                  </Button>
                </form>
              </TabsContent>
            </Tabs>
          )}

          {error && (
            <Alert variant="destructive" className="mt-4">
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}
          {success && (
            <Alert className="mt-4 bg-green-50 text-green-800 border-green-500">
              <AlertDescription>{success}</AlertDescription>
            </Alert>
          )}
        </CardContent>
      </Card>
    </AdminLayout>
  );
};

export default StakingAdmin;











src/pages/TokenBalance.js





import React, { useState, useEffect } from 'react';
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { PublicKey } from '@solana/web3.js';
import { getProgram } from '../utils/anchor-connection';
import { formatSol } from '../utils/formatters';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "../components/ui/card";
import { Button } from "../components/ui/button";

const TokenBalance = () => {
  const { connection } = useConnection();
  const wallet = useWallet();
  const [balance, setBalance] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');

  useEffect(() => {
    if (wallet.publicKey) {
      fetchTokenBalance();
    }
  }, [connection, wallet.publicKey]);

  const fetchTokenBalance = async () => {
    if (!wallet.publicKey) return;

    setLoading(true);
    setError('');

    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from('ico')],
        program.programId
      );
      const icoData = await program.account.icoAccount.fetch(icoAccount);

      const [userTokenAccount] = await PublicKey.findProgramAddress(
        [Buffer.from('user_token_account'), wallet.publicKey.toBuffer()],
        program.programId
      );

      const userTokenAccountInfo = await connection.getAccountInfo(userTokenAccount);

      if (userTokenAccountInfo) {
        const userTokenBalance = await connection.getTokenAccountBalance(userTokenAccount);
        setBalance(Number(userTokenBalance.value.amount) / Math.pow(10, icoData.decimals));
      } else {
        setBalance(0);
      }
    } catch (err) {
      console.error('Error fetching token balance:', err);
      setError('Failed to fetch token balance. Please try again later.');
    } finally {
      setLoading(false);
    }
  };

  if (!wallet.publicKey) {
    return (
      <div className="text-center py-12">
        <h2 className="text-2xl font-semibold mb-4">Token Balance</h2>
        <p className="text-gray-600">Please connect your wallet to view your token balance.</p>
      </div>
    );
  }

  return (
    <Card className="max-w-lg mx-auto">
      <CardHeader>
        <CardTitle>Token Balance</CardTitle>
        <CardDescription>View your current token balance</CardDescription>
      </CardHeader>
      <CardContent>
        {loading ? (
          <div className="text-center">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto"></div>
            <p className="mt-4 text-gray-600">Loading token balance...</p>
          </div>
        ) : error ? (
          <div className="p-4 bg-red-100 border border-red-400 text-red-700 rounded-md text-sm">
            {error}
          </div>
        ) : (
          <div className="text-center">
            <p className="text-4xl font-bold text-gray-800">{formatSol(balance)} SOL</p>
            <p className="mt-2 text-gray-600">Current token balance</p>
          </div>
        )}
        <Button
          onClick={fetchTokenBalance}
          className="mt-6 w-full"
        >
          Refresh Balance
        </Button>
      </CardContent>
    </Card>
  );
};

export default TokenBalance;






src/pages/UpdateIcoParameter.js




import React, { useState, useEffect } from 'react';
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { PublicKey } from '@solana/web3.js';
import { getProgram } from '../utils/anchor-connection';
import * as anchor from '@project-serum/anchor';
import { isAdminWallet } from '../utils/admin-check';
import AdminLayout from '../components/AdminLayout';
import {Input} from '../components/ui/input';
import { Button, Card, CardContent, CardDescription, CardHeader, CardTitle } from "../components/ui/cardTitle";
import { Label } from "../components/ui/label";

const UpdateIcoParameters = () => {
  const { connection } = useConnection();
  const wallet = useWallet();
  const [icoData, setIcoData] = useState(null);
  const [formData, setFormData] = useState({
    seedPrice: '',
    preIcoPrice: '',
    publicPrice: '',
    duration: '',
  });
  const [loading, setLoading] = useState(true);
  const [updating, setUpdating] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');

  useEffect(() => {
    if (wallet.publicKey && isAdminWallet(wallet.publicKey)) {
      fetchIcoData();
    }
  }, [connection, wallet.publicKey]);

  const fetchIcoData = async () => {
    if (!wallet.publicKey) return;

    setLoading(true);
    setError('');

    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from('ico')],
        program.programId
      );
      const data = await program.account.icoAccount.fetch(icoAccount);
      setIcoData(data);
      setFormData({
        seedPrice: (data.seedPrice.toNumber() / anchor.web3.LAMPORTS_PER_SOL).toString(),
        preIcoPrice: (data.preIcoPrice.toNumber() / anchor.web3.LAMPORTS_PER_SOL).toString(),
        publicPrice: (data.publicPrice.toNumber() / anchor.web3.LAMPORTS_PER_SOL).toString(),
        duration: data.duration.toString(),
      });
    } catch (err) {
      console.error('Error fetching ICO data:', err);
      setError('Failed to fetch ICO data. Please try again later.');
    } finally {
      setLoading(false);
    }
  };

  const handleInputChange = (e) => {
    const { name, value } = e.target;
    setFormData(prevState => ({
      ...prevState,
      [name]: value
    }));
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!wallet.publicKey || !wallet.signTransaction) return;

    setUpdating(true);
    setError('');
    setSuccess('');

    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from('ico')],
        program.programId
      );

      const seedPrice = new anchor.BN(parseFloat(formData.seedPrice) * anchor.web3.LAMPORTS_PER_SOL);
      const preIcoPrice = new anchor.BN(parseFloat(formData.preIcoPrice) * anchor.web3.LAMPORTS_PER_SOL);
      const publicPrice = new anchor.BN(parseFloat(formData.publicPrice) * anchor.web3.LAMPORTS_PER_SOL);
      const duration = new anchor.BN(parseInt(formData.duration));

      const tx = await program.methods
        .updateIcoParameters(seedPrice, preIcoPrice, publicPrice, duration)
        .accounts({
          icoAccount,
          authority: wallet.publicKey,
        })
        .rpc();

      setSuccess(`ICO parameters updated successfully! Transaction ID: ${tx}`);
      await fetchIcoData();
    } catch (err) {
      console.error('Error updating ICO parameters:', err);
      setError('Failed to update ICO parameters. Please try again later.');
    } finally {
      setUpdating(false);
    }
  };

  if (!wallet.publicKey || !isAdminWallet(wallet.publicKey)) {
    return (
      <AdminLayout>
        <Card>
          <CardHeader>
            <CardTitle>Update ICO Parameters</CardTitle>
            <CardDescription>You do not have permission to access this page.</CardDescription>
          </CardHeader>
        </Card>
      </AdminLayout>
    );
  }

  return (
    <AdminLayout>
      <Card>
        <CardHeader>
          <CardTitle>Update ICO Parameters</CardTitle>
          <CardDescription>Modify the current ICO parameters</CardDescription>
        </CardHeader>
        <CardContent>
          {loading ? (
            <div className="text-center py-12">
              <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto"></div>
              <p className="mt-4 text-gray-600">Loading ICO data...</p>
            </div>
          ) : (
            <form onSubmit={handleSubmit} className="space-y-4">
              <div className="space-y-2">
                <Label htmlFor="seedPrice">Seed Price (SOL):</Label>
                <Input
                  type="number"
                  id="seedPrice"
                  name="seedPrice"
                  value={formData.seedPrice}
                  onChange={handleInputChange}
                  required
                  min="0"
                  step="0.000000001"
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="preIcoPrice">Pre-ICO Price (SOL):</Label>
                <Input
                  type="number"
                  id="preIcoPrice"
                  name="preIcoPrice"
                  value={formData.preIcoPrice}
                  onChange={handleInputChange}
                  required
                  min="0"
                  step="0.000000001"
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="publicPrice">Public Price (SOL):</Label>
                <Input
                  type="number"
                  id="publicPrice"
                  name="publicPrice"
                  value={formData.publicPrice}
                  onChange={handleInputChange}
                  required
                  min="0"
                  step="0.000000001"
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="duration">Duration (seconds):</Label>
                <Input
                  type="number"
                  id="duration"
                  name="duration"
                  value={formData.duration}
                  onChange={handleInputChange}
                  required
                  min="1"
                />
              </div>
              {/* <Button type="submit" disabled={updating} className="w-full"> */}
              <Button type="submit" disabled={updating} >
                {updating ? 'Updating...' : 'Update'}
              </Button>
            </form>
          )}
          {error && (
            <div className="mt-4 p-4 bg-red-100 border border-red-400 text-red-700 rounded-md text-sm">
              {error}
            </div>
          )}
          {success && (
            <div className="mt-4 p-4 bg-green-100 border border-green-400 text-green-700 rounded-md text-sm">
              {success}
            </div>
          )}
        </CardContent>
      </Card>
    </AdminLayout>
  );
};

export default UpdateIcoParameters;








src/pages/UpdateRound.js






import React, { useState, useEffect } from 'react';
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { PublicKey } from '@solana/web3.js';
import { getProgram } from '../utils/anchor-connection';
import { isAdminWallet } from '../utils/admin-check';
import AdminLayout from '../components/AdminLayout';
import { Select } from "../components/ui/select"
import { Button, Card, CardContent, CardDescription, CardHeader, CardTitle } from "../components/ui/cardTitle";

const UpdateRound = () => {
  const { connection } = useConnection();
  const wallet = useWallet();
  const [currentRound, setCurrentRound] = useState('');
  const [newRound, setNewRound] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');

  useEffect(() => {
    if (wallet.publicKey && isAdminWallet(wallet.publicKey)) {
      fetchCurrentRound();
    }
  }, [connection, wallet.publicKey]);

  const fetchCurrentRound = async () => {
    if (!wallet.publicKey) return;

    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from('ico')],
        program.programId
      );
      const icoData = await program.account.icoAccount.fetch(icoAccount);
      setCurrentRound(Object.keys(icoData.roundType)[0]);
    } catch (err) {
      console.error('Error fetching current round:', err);
      setError('Failed to fetch current round. Please try again later.');
    }
  };

  const handleUpdateRound = async (e) => {
    e.preventDefault();
    if (!wallet.publicKey || !isAdminWallet(wallet.publicKey)) return;

    setLoading(true);
    setError('');
    setSuccess('');

    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from('ico')],
        program.programId
      );

      await program.methods
        .updateRound({ [newRound.toLowerCase()]: {} })
        .accounts({
          icoAccount,
          authority: wallet.publicKey,
        })
        .rpc();

      setSuccess(`Round updated successfully to ${newRound}`);
      setCurrentRound(newRound);
    } catch (err) {
      console.error('Error updating round:', err);
      setError('Failed to update round. Please try again later.');
    } finally {
      setLoading(false);
    }
  };

  if (!wallet.publicKey || !isAdminWallet(wallet.publicKey)) {
    return (
      <AdminLayout>
        <Card>
          <CardHeader>
            <CardTitle>Update Round</CardTitle>
            <CardDescription>You do not have permission to access this page.</CardDescription>
          </CardHeader>
        </Card>
      </AdminLayout>
    );
  }

  return (
    <AdminLayout>
      <Card>
        <CardHeader>
          <CardTitle>Update Round</CardTitle>
          <CardDescription>Change the current ICO round</CardDescription>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleUpdateRound} className="space-y-4">
            <div>
              <p className="text-sm font-medium text-gray-700 mb-1">Current Round:</p>
              <p className="text-lg font-semibold">{currentRound}</p>
            </div>
            <div>
              <label htmlFor="newRound" className="block text-sm font-medium text-gray-700 mb-1">
                New Round:
              </label>
              <Select
                id="newRound"
                value={newRound}
                onChange={(e) => setNewRound(e.target.value)}
                required
                className="w-full"
              >
                <option value="">Select new round</option>
                <option value="PreICO">Pre-ICO</option>
                <option value="PublicICO">Public ICO</option>
              </Select>
            </div>
            {/* <Button type="submit" disabled={loading || !newRound} className="w-full"> */}
            <Button type="submit" disabled={loading || !newRound} >
              {loading ? 'Updating...' : 'Update '}
            </Button>
          </form>
          {error && (
            <div className="mt-4 p-4 bg-red-100 border border-red-400 text-red-700 rounded-md text-sm">
              {error}
            </div>
          )}
          {success && (
            <div className="mt-4 p-4 bg-green-100 border border-green-400 text-green-700 rounded-md text-sm">
              {success}
            </div>
          )}
        </CardContent>
      </Card>
    </AdminLayout>
  );
};

export default UpdateRound;








src/pages/UserDashboard.js



import React, { useState, useEffect } from 'react';
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { PublicKey } from '@solana/web3.js';
import { getProgram } from '../utils/anchor-connection';
import { formatSol, formatUnixTimestamp } from '../utils/formatters';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "../components/ui/card";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "../components/ui/table";

const UserDashboard = () => {
  const { connection } = useConnection();
  const wallet = useWallet();
  const [icoData, setIcoData] = useState(null);
  const [userPurchases, setUserPurchases] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');

  useEffect(() => {
    if (wallet.publicKey) {
      fetchData();
    }
  }, [connection, wallet.publicKey]);

  const fetchData = async () => {
    if (!wallet.publicKey) return;

    setLoading(true);
    setError('');

    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from('ico')],
        program.programId
      );
      const data = await program.account.icoAccount.fetch(icoAccount);
      setIcoData(data);

      const purchaseAccounts = await connection.getProgramAccounts(program.programId, {
        filters: [
          { dataSize: program.account.purchaseAccount.size },
          { memcmp: { offset: 8, bytes: icoAccount.toBase58() } },
          { memcmp: { offset: 8 + 32, bytes: wallet.publicKey.toBase58() } },
        ],
      });

      const userPurchasesData = await Promise.all(
        purchaseAccounts.map(async (account) => {
          const purchaseData = await program.account.purchaseAccount.fetch(account.pubkey);
          return {
            amount: purchaseData.amount,
            timestamp: purchaseData.timestamp,
            isDistributed: purchaseData.isDistributed,
            purchaseAccountPubkey: account.pubkey,
          };
        })
      );

      setUserPurchases(userPurchasesData);
    } catch (err) {
      console.error('Error fetching data:', err);
      setError('Failed to fetch data. Please try again later.');
    } finally {
      setLoading(false);
    }
  };

  if (!wallet.publicKey) {
    return (
      <div className="text-center py-12">
        <h2 className="text-2xl font-semibold mb-4">User Dashboard</h2>
        <p className="text-gray-600">Please connect your wallet to view your dashboard.</p>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <h1 className="text-3xl font-bold mb-6">User Dashboard</h1>
      {loading ? (
        <div className="text-center py-12">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto"></div>
          <p className="mt-4 text-gray-600">Loading dashboard data...</p>
        </div>
      ) : error ? (
        <div className="p-4 bg-red-100 border border-red-400 text-red-700 rounded-md text-sm">
          {error}
        </div>
      ) : (
        <>
          <Card>
            <CardHeader>
              <CardTitle>ICO Overview</CardTitle>
              <CardDescription>Current status of the ICO</CardDescription>
            </CardHeader>
            <CardContent>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                  <p className="text-sm font-medium text-gray-500">Current Price</p>
                  <p className="text-lg font-semibold">{formatSol(icoData.currentPublicPrice)} SOL</p>
                </div>
                <div>
                  <p className="text-sm font-medium text-gray-500">Tokens Sold</p>
                  <p className="text-lg font-semibold">{formatSol(icoData.tokensSold)} / {formatSol(icoData.totalSupply)} SOL</p>
                </div>
                <div>
                  <p className="text-sm font-medium text-gray-500">Round Type</p>
                  <p className="text-lg font-semibold">{Object.keys(icoData.roundType)[0]}</p>
                </div>
                <div>
                  <p className="text-sm font-medium text-gray-500">Status</p>
                  <p className="text-lg font-semibold">{icoData.isActive ? 'Active' : 'Inactive'}</p>
                </div>
              </div>
            </CardContent>
          </Card>

          <Card>
            <CardHeader>
              <CardTitle>Your Purchases</CardTitle>
              <CardDescription>History of your token purchases</CardDescription>
            </CardHeader>
            <CardContent>
              {userPurchases.length === 0 ? (
                <p className="text-gray-600">You haven't made any purchases yet.</p>
              ) : (
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead>Amount</TableHead>
                      <TableHead>Date</TableHead>
                      <TableHead>Status</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {userPurchases.map((purchase, index) => (
                      <TableRow key={index}>
                        <TableCell>{formatSol(purchase.amount)} SOL</TableCell>
                        <TableCell>{formatUnixTimestamp(purchase.timestamp)}</TableCell>
                        <TableCell>{purchase.isDistributed ? 'Distributed' : 'Pending'}</TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              )}
            </CardContent>
          </Card>
        </>
      )}
    </div>
  );
};

export default UserDashboard;








src/components/AdminLayout.js 




import React from 'react';
import { useWallet } from '@solana/wallet-adapter-react';
import { isAdminWallet } from '../utils/admin-check';
import Sidebar from './Sidebar';
import Header from './Header';

const AdminLayout = ({ children }) => {
  const { publicKey } = useWallet();

  if (!publicKey || !isAdminWallet(publicKey)) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-100">
        <div className="text-center">
          <h1 className="text-3xl font-bold text-gray-800 mb-4">Access Denied</h1>
          <p className="text-gray-600">You do not have permission to access this page.</p>
        </div>
      </div>
    );
  }

  return (
    <div className="flex h-screen bg-gray-100">
      {/* <Sidebar /> */}
      <div className="flex-1 flex flex-col overflow-hidden">
        <Header />
        <main className="flex-1 overflow-x-hidden overflow-y-auto bg-gray-100">
          <div className="container mx-auto px-6 py-8">
            {children}
          </div>
        </main>
      </div>
    </div>
  );
};

export default AdminLayout;








src/components/AdminRoute.js




import React from 'react';
import { Navigate } from 'react-router-dom';
import { useWallet } from '@solana/wallet-adapter-react';
import { isAdminWallet } from '../utils/admin-check';

export const AdminRoute = ({ children }) => {
  const { publicKey } = useWallet();

  if (!publicKey || !isAdminWallet(publicKey)) {
    return <Navigate to="/" replace />;
  }

  return children;
};






src/components/AdminSidebar.js






import React from 'react';
import { Link, useLocation } from 'react-router-dom';
import { Settings, Users, RefreshCw, Power, Share2, BarChart3, Sliders, Home, DollarSign } from 'lucide-react';

const AdminSidebar = () => {
  const location = useLocation();

  const adminRoutes = [
    // {
    //   name: 'Dashboard',
    //   path: '/admin',
    //   icon: Home
    // },
    {
      name: 'Initialize ICO',
      path: '/admin/initialize-ico',
      icon: DollarSign
    },
    {
      name: 'Manage Investors',
      path: '/admin/manage-investors',
      icon: Users
    },
    {
      name: 'Update Round',
      path: '/admin/update-round',
      icon: RefreshCw
    },
    {
      name: 'Update Parameters',
      path: '/admin/update-parameters',
      icon: Sliders
    },
    {
      name: 'Distribute Tokens',
      path: '/admin/distribute-tokens',
      icon: Share2
    },
    {
      name: 'ICO Analytics',
      path: '/admin/analytics',
      icon: BarChart3
    },
    {
      name: 'End ICO',
      path: '/admin/end-ico',
      icon: Power
    }
  ];

  return (
    <div className="hidden lg:flex lg:flex-shrink-0">
      <div className="flex flex-col w-64">
        <div className="flex flex-col flex-grow bg-white pt-5 pb-4 overflow-y-auto">
          <div className="flex items-center flex-shrink-0 px-4">
            <span className="text-xl font-semibold text-gray-800">Admin Portal</span>
          </div>
          <nav className="mt-8 flex-1 px-2 space-y-1">
            {adminRoutes.map((route) => {
              const isActive = location.pathname === route.path;
              return (
                <Link
                  key={route.name}
                  to={route.path}
                  className={`${
                    isActive
                      ? 'bg-blue-50 text-blue-600'
                      : 'text-gray-600 hover:bg-gray-50 hover:text-gray-900'
                  } group flex items-center px-2 py-2 text-sm font-medium rounded-md transition-colors`}
                >
                  <route.icon
                    className={`${
                      isActive ? 'text-blue-600' : 'text-gray-400 group-hover:text-gray-500'
                    } mr-3 flex-shrink-0 h-5 w-5 transition-colors`}
                  />
                  {route.name}
                </Link>
              );
            })}
          </nav>
        </div>
      </div>
    </div>
  );
};

export default AdminSidebar;








src/components/Footer.js


import React from 'react';

const Footer = () => {
  return (
    <footer className="bg-white shadow-md mt-8">
      <div className="max-w-7xl mx-auto py-4 px-4 sm:px-6 lg:px-8">
        <p className="text-center text-gray-500 text-sm">
          © {new Date().getFullYear()} Solana ICO Platform. All rights reserved.
        </p>
      </div>
    </footer>
  );
};

export default Footer;





src/component/Header.js



import React from 'react';
import { WalletMultiButton } from '@solana/wallet-adapter-react-ui';
import { useWallet } from '@solana/wallet-adapter-react';
import { isAdminWallet } from '../utils/admin-check';

const Header = () => {
  const { publicKey } = useWallet();

  return (
    <header className="bg-white shadow-md">
      {/* <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="flex justify-between items-center py-6 md:justify-start md:space-x-10">
          <div className="flex justify-start lg:w-0 lg:flex-1"> */}
            {/* <a href="/" className="text-2xl font-bold text-blue-600">
              Solana ICO Admin
            </a> */}
          {/* </div> */}
          {/* <div className="flex items-center justify-end md:flex-1 lg:w-0">
            {isAdminWallet(publicKey) && (
              <span className="mr-4 text-sm font-medium text-gray-500">Admin</span>
            )}
            <WalletMultiButton className="!bg-blue-500 hover:!bg-blue-600" />
          </div> */}
        {/* </div>
      </div> */}
    </header>
  );
};

export default Header;






src/components/Layout.js




import React from 'react';
import { useWallet } from '@solana/wallet-adapter-react';
import { isAdminWallet } from '../utils/admin-check';
import Navbar from './Navbar';
import AdminSidebar from './AdminSidebar';
import Footer from './Footer';

const Layout = ({ children }) => {
  const { publicKey } = useWallet();
  const isAdmin = isAdminWallet(publicKey);

  return (
    <div className="min-h-screen flex">
      {isAdmin && <AdminSidebar />}
      <div className="flex-1 flex flex-col">
        <Navbar />
        <main className="flex-1 p-6 bg-gray-50">
          <div className={`mx-auto ${isAdmin ? 'max-w-7xl' : 'max-w-6xl'}`}>
            {children}
          </div>
        </main>
        <Footer />
      </div>
    </div>
  );
};

export default Layout;







src/components/Navbar.js





import React from 'react';
import { Link, useLocation } from 'react-router-dom';
import { WalletMultiButton } from '@solana/wallet-adapter-react-ui';

const Navbar = () => {
  const location = useLocation();

  const navItems = [
    { name: 'Dashboard', path: '/' },
    { name: 'ICO Details', path: '/ico-details' },
    { name: 'Buy Tokens', path: '/buy' },
    { name: 'Token Balance', path: '/balance' },
  ];

  const isActive = (path) => location.pathname === path;

  return (
    <nav className="bg-white shadow-sm">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="flex justify-between h-16">
          <div className="flex">
            <div className="flex-shrink-0 flex items-center">
              <Link to="/" className="text-2xl font-bold text-blue-600">
                Solana ICO
              </Link>
            </div>
            <div className="hidden sm:ml-6 sm:flex sm:space-x-8">
              {navItems.map((item) => (
                <Link
                  key={item.name}
                  to={item.path}
                  className={`${
                    isActive(item.path)
                      ? 'border-blue-500 text-gray-900'
                      : 'border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-700'
                  } inline-flex items-center px-1 pt-1 border-b-2 text-sm font-medium`}
                >
                  {item.name}
                </Link>
              ))}
            </div>
          </div>
          <div className="hidden sm:ml-6 sm:flex sm:items-center">
            <WalletMultiButton className="!bg-blue-500 hover:!bg-blue-600" />
          </div>
        </div>
      </div>
    </nav>
  );
};

export default Navbar;








src/components/Sidebar.js


import React from 'react';
import { Link, useLocation } from 'react-router-dom';
import { useWallet } from '@solana/wallet-adapter-react';
import { isAdminWallet } from '../utils/admin-check';
import { Home, CreditCard, Wallet, Users, Settings, Share2, Power, PlusCircle } from 'lucide-react';

const Sidebar = () => {
  const location = useLocation();
  const { publicKey } = useWallet();

  const navigation = [
    { name: 'Dashboard', href: '/', icon: Home },
    { name: 'Buy Tokens', href: '/buy', icon: CreditCard },
    { name: 'Token Balance', href: '/balance', icon: Wallet },
  ];

  const adminNavigation = [
    { name: 'Initialize ICO', href: '/initialize-ico', icon: PlusCircle },
    { name: 'Manage Investors', href: '/manage-investors', icon: Users },
    { name: 'Update Parameters', href: '/update-parameters', icon: Settings },
    { name: 'Distribute Tokens', href: '/distribute-tokens', icon: Share2 },
    { name: 'End ICO', href: '/end-ico', icon: Power },
  ];

  const isActive = (path) => location.pathname === path;

  return (
    <div className="hidden md:flex md:flex-col md:w-64 md:bg-white md:border-r">
      <div className="flex-1 flex flex-col overflow-y-auto">
        <nav className="flex-1 px-2 py-4 space-y-1">
          {navigation.map((item) => {
            const Icon = item.icon;
            return (
              <Link
                key={item.name}
                to={item.href}
                className={`${
                  isActive(item.href)
                    ? 'bg-blue-50 text-blue-600'
                    : 'text-gray-600 hover:bg-gray-50 hover:text-gray-900'
                } group flex items-center px-2 py-2 text-sm font-medium rounded-md`}
              >
                <Icon className={`${
                  isActive(item.href) ? 'text-blue-600' : 'text-gray-400 group-hover:text-gray-500'
                } mr-3 flex-shrink-0 h-6 w-6`} />
                {item.name}
              </Link>
            );
          })}

          {isAdminWallet(publicKey) && (
            <>
              <div className="relative">
                <div className="absolute inset-0 flex items-center" aria-hidden="true">
                  <div className="w-full border-t border-gray-300" />
                </div>
                <div className="relative flex justify-center">
                  <span className="px-2 bg-white text-sm text-gray-500">Admin</span>
                </div>
              </div>

              {adminNavigation.map((item) => {
                const Icon = item.icon;
                return (
                  <Link
                    key={item.name}
                    to={item.href}
                    className={`${
                      isActive(item.href)
                        ? 'bg-blue-50 text-blue-600'
                        : 'text-gray-600 hover:bg-gray-50 hover:text-gray-900'
                    } group flex items-center px-2 py-2 text-sm font-medium rounded-md`}
                  >
                    <Icon className={`${
                      isActive(item.href) ? 'text-blue-600' : 'text-gray-400 group-hover:text-gray-500'
                    } mr-3 flex-shrink-0 h-6 w-6`} />
                    {item.name}
                  </Link>
                );
              })}
            </>
          )}
        </nav>
      </div>
    </div>
  );
};

export default Sidebar;




src/utils/admin-check.js




import { PublicKey } from '@solana/web3.js';

export const isAdminWallet = (publicKey) => {
  if (!publicKey) return false;

  const adminPublicKeyString = process.env.REACT_APP_ADMIN_PUBLIC_KEY;
  if (!adminPublicKeyString) {
    console.error('Admin public key is not set in environment variables');
    return false;
  }

  try {
    const adminPublicKey = new PublicKey(adminPublicKeyString);
    return publicKey.equals(adminPublicKey);
  } catch (error) {
    console.error('Error creating PublicKey:', error);
    return false;
  }
};


src/utils/anchor-connection.js





import * as anchor from "@project-serum/anchor"
import { Connection, PublicKey } from "@solana/web3.js"
import icoIdl from "./idl/ico_program.json"
import stakingIdl from "./idl/staking_program.json"

export const getProgram = (connection, wallet) => {
  const provider = new anchor.AnchorProvider(connection, wallet, { preflightCommitment: "processed" })
  const programId = new PublicKey(process.env.REACT_APP_ICO_PROGRAM_ID)
  return new anchor.Program(icoIdl, programId, provider)
}

export const getStakingProgram = (connection, wallet) => {
  const provider = new anchor.AnchorProvider(connection, wallet, { preflightCommitment: "processed" })
  const programId = new PublicKey(process.env.REACT_APP_STAKING_PROGRAM_ID)
  return new anchor.Program(stakingIdl, programId, provider)
}

export const getConnection = () => {
  return new Connection(process.env.REACT_APP_RPC_ENDPOINT, "processed")
}







src/utils/constants.js




export const LAMPORTS_PER_SOL = 1000000000;

export const ICO_SEED = 'ico';
export const PURCHASE_SEED = 'purchase';
export const USER_TOKEN_ACCOUNT_SEED = 'user_token_account';

export const ROUND_TYPES = {
  SEED: 'Seed',
  PRE_ICO: 'PreICO',
  PUBLIC_ICO: 'PublicICO',
};

export const ICO_STATUS = {
  ACTIVE: 'Active',
  INACTIVE: 'Inactive',
};







src/utils/enum-helpers.js



import { ROUND_TYPES, ICO_STATUS } from './constants';

export const getRoundType = (roundTypeObj) => {
  const key = Object.keys(roundTypeObj)[0];
  return ROUND_TYPES[key.toUpperCase()] || 'Unknown';
};

export const getIcoStatus = (isActive) => {
  return isActive ? ICO_STATUS.ACTIVE : ICO_STATUS.INACTIVE;
};






src/utils/formatters.js




export const formatUnixTimestamp = (timestamp) => {
  const date = new Date(timestamp * 1000);
  return date.toLocaleString();
};

export const formatSol = (lamports) => {
  return (lamports / 1e9).toFixed(4);
};





src/utils/ico-instructions.js



import * as anchor from '@project-serum/anchor';
import { PublicKey } from '@solana/web3.js';
import { TOKEN_PROGRAM_ID } from '@solana/spl-token';
import { ICO_SEED, PURCHASE_SEED, USER_TOKEN_ACCOUNT_SEED } from './constants';

export const createInitializeIcoInstruction = (
  program,
  authority,
  tokenMint,
  totalSupply,
  seedPrice,
  preIcoPrice,
  publicPrice,
  startTime,
  duration,
  roundType
) => {
  return program.methods
    .initialize(
      totalSupply,
      seedPrice,
      preIcoPrice,
      publicPrice,
      startTime,
      duration,
      roundType
    )
    .accounts({
      icoAccount: PublicKey.findProgramAddressSync(
        [Buffer.from(ICO_SEED)],
        program.programId
      )[0],
      authority,
      tokenMint,
      systemProgram: anchor.web3.SystemProgram.programId,
    });
};

export const createBuyTokensInstruction = (
  program,
  buyer,
  amount,
  purchaseCounter
) => {
  return program.methods
    .buyTokens(amount)
    .accounts({
      buyer,
      icoAccount: PublicKey.findProgramAddressSync(
        [Buffer.from(ICO_SEED)],
        program.programId
      )[0],
      purchaseAccount: PublicKey.findProgramAddressSync(
        [
          Buffer.from(PURCHASE_SEED),
          buyer.toBuffer(),
          new anchor.BN(purchaseCounter).toArrayLike(Buffer, 'le', 8),
        ],
        program.programId
      )[0],
      treasuryWallet: program.provider.publicKey,
      tokenProgram: TOKEN_PROGRAM_ID,
      systemProgram: anchor.web3.SystemProgram.programId,
    });
};

export const createDistributeTokensInstruction = (
  program,
  authority,
  buyer,
  purchaseAccountPubkey
) => {
  return program.methods
    .distributeTokens()
    .accounts({
      authority,
      icoAccount: PublicKey.findProgramAddressSync(
        [Buffer.from(ICO_SEED)],
        program.programId
      )[0],
      purchaseAccount: purchaseAccountPubkey,
      buyer,
      userTokenAccount: PublicKey.findProgramAddressSync(
        [Buffer.from(USER_TOKEN_ACCOUNT_SEED), buyer.toBuffer()],
        program.programId
      )[0],
      tokenProgram: TOKEN_PROGRAM_ID,
      systemProgram: anchor.web3.SystemProgram.programId,
    });
};

export const createUpdateRoundInstruction = (
  program,
  authority,
  newRoundType
) => {
  return program.methods
    .updateRound(newRoundType)
    .accounts({
      icoAccount: PublicKey.findProgramAddressSync(
        [Buffer.from(ICO_SEED)],
        program.programId
      )[0],
      authority,
    });
};

export const createEndIcoInstruction = (program, authority) => {
  return program.methods
    .endIco()
    .accounts({
      icoAccount: PublicKey.findProgramAddressSync(
        [Buffer.from(ICO_SEED)],
        program.programId
      )[0],
      authority,
    });
};






src/App.js



"use client"

import { useMemo } from "react"
import { BrowserRouter as Router, Route, Routes } from "react-router-dom"
import { ConnectionProvider, WalletProvider } from "@solana/wallet-adapter-react"
import { WalletAdapterNetwork } from "@solana/wallet-adapter-base"
import { PhantomWalletAdapter, SolflareWalletAdapter, TorusWalletAdapter } from "@solana/wallet-adapter-wallets"
import { WalletModalProvider } from "@solana/wallet-adapter-react-ui"
import { clusterApiUrl } from "@solana/web3.js"

import Layout from "./components/Layout"
import { AdminRoute } from "./components/AdminRoute"

// Pages
import Dashboard from "./pages/Dashboard"
import IcoDetails from "./pages/IcoDetails"
import BuyTokens from "./pages/BuyTokens"
import TokenBalance from "./pages/TokenBalance"
import InitializeIco from "./pages/InitializeIco"
import ManageInvestors from "./pages/ManageInvestors"
import UpdateRound from "./pages/UpdateRound"
import UpdateParameters from "./pages/UpdateIcoParameters"
import DistributeTokens from "./pages/DistributeTokens"
import EndIco from "./pages/EndIco"
import IcoAnalytics from "./pages/IcoAnalytics"
import Staking from "./pages/Staking"
import StakingAdmin from "./pages/StakingAdmin"

import "@solana/wallet-adapter-react-ui/styles.css"
import "./index.css"

function App() {
  // Use devnet for development
  const network = WalletAdapterNetwork.Devnet
  const endpoint = useMemo(() => clusterApiUrl(network), [network])

  const wallets = useMemo(() => [new PhantomWalletAdapter(), new SolflareWalletAdapter(), new TorusWalletAdapter()], [])

  return (
    <ConnectionProvider endpoint={endpoint}>
      <WalletProvider wallets={wallets} autoConnect>
        <WalletModalProvider>
          <Router>
            <Layout>
              <Routes>
                {/* Public Routes */}
                <Route path="/" element={<Dashboard />} />
                <Route path="/ico-details" element={<IcoDetails />} />
                <Route path="/buy" element={<BuyTokens />} />
                <Route path="/balance" element={<TokenBalance />} />
                <Route path="/staking" element={<Staking />} />

                {/* Admin Routes */}
                <Route path="/admin">
                  <Route
                    path="initialize-ico"
                    element={
                      <AdminRoute>
                        <InitializeIco />
                      </AdminRoute>
                    }
                  />
                  <Route
                    path="manage-investors"
                    element={
                      <AdminRoute>
                        <ManageInvestors />
                      </AdminRoute>
                    }
                  />
                  <Route
                    path="update-round"
                    element={
                      <AdminRoute>
                        <UpdateRound />
                      </AdminRoute>
                    }
                  />
                  <Route
                    path="update-parameters"
                    element={
                      <AdminRoute>
                        <UpdateParameters />
                      </AdminRoute>
                    }
                  />
                  <Route
                    path="distribute-tokens"
                    element={
                      <AdminRoute>
                        <DistributeTokens />
                      </AdminRoute>
                    }
                  />
                  <Route
                    path="analytics"
                    element={
                      <AdminRoute>
                        <IcoAnalytics />
                      </AdminRoute>
                    }
                  />
                  <Route
                    path="end-ico"
                    element={
                      <AdminRoute>
                        <EndIco />
                      </AdminRoute>
                    }
                  />
                  <Route
                    path="staking"
                    element={
                      <AdminRoute>
                        <StakingAdmin />
                      </AdminRoute>
                    }
                  />
                </Route>
              </Routes>
            </Layout>
          </Router>
        </WalletModalProvider>
      </WalletProvider>
    </ConnectionProvider>
  )
}

export default App









src/index.js




import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';
import { Buffer } from 'buffer';

window.Buffer = Buffer;

ReactDOM.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
  document.getElementById('root')
);







.env 


REACT_APP_ICO_PROGRAM_ID=FyCz92Au4vcsanwaJZ8PrykVf6oPgreoYKmCque5Qq45
REACT_APP_STAKING_PROGRAM_ID=BU1moyj3dVEVhi2GwyDLqG9gt2fD47XToqSRNNuc7U1b
REACT_APP_ADMIN_WALLET_ADDRESS=DYkCAokwibanNxMvixmoZFQDwayGDJWfJ9moZjDRpUvW
REACT_APP_TOKEN_MINT_ADDRESS=7GYz5XMx5BQrMtexJZrrJQM1WfhHnWAmf8Snhaqqmf3U
REACT_APP_OWNER_ADDRESS=DYkCAokwibanNxMvixmoZFQDwayGDJWfJ9moZjDRpUvW
REACT_APP_NETWORK=devnet
REACT_APP_ADMIN_PUBLIC_KEY=DYkCAokwibanNxMvixmoZFQDwayGDJWfJ9moZjDRpUvW
REACT_APP_RPC_ENDPOINT=https://api.devnet.solana.com




BTW my current owner wallet address is    "DYkCAokwibanNxMvixmoZFQDwayGDJWfJ9moZjDRpUvW"



So this is the full reactjs file based on the Solana Smart contract (which I share previously), Now create a standard Backend for the entire project in nodejs fully and properly mention everything like db, controller, src, router and others which is mostly needed for that project(include .env) with the proper integration with UI also

so based on my input first read carefully full code and then generate the full backend with integration with UI also and generate the full files with proper standard structure




So this are my all major files i created currently, and I also provide smart contract, now read the smart contract fully first then manage my entire reactjs files fully with maintaining the path,

and regenerate the full files and tell me the smart contract changes process also if needed (like what is buyer field should be in buytoken, IcoAccount, authority, treasureWallet, tokenAccount, buyerTokenAccount,tokenProgram and systemProgram in the input field)

after carefully read the smart contract modify the current reactJs files and regenerate the full files all without any missing (I also changes some functionality in my current smart contract and paste fully here, base on this smart contract create a full reactjs ICO project with standard UI and without errro and also tell me where should i add programID, contract Address, Token address, token Account and other things)

BTW i already deployed the smart contract fully in solpg(a browzer IDE) and have programID and idl.json file, so no need to generate that files just tell me the location

and remember base on the smart contract generate the all files fully and maintain in .js instead of .tsx and generate all files fully with the proper structure maintain

pub enum RoundType {
    SeedRound,
    PreICO,
    PublicICO,
}

and here total smart contract has 3 phase, so maintain the phase by first for "SeedRound", then complete "PreIco", and after that complete publicICO" phase and then generate the code fully

So this are my all major files and I also provide smart contract also, now read the smart contract and all react js file carefully and then solve the BuyTokenPage error and others files also if needed changes the others files also

and regenerate the full files and tell me the smart contract changes process also if needed (like what is buyer field should be in buytoken, IcoAccount, authority, treasureWallet, tokenAccount, buyerTokenAccount,tokenProgram and systemProgram in the input field)


Here Ico contarct is not working, From UI(Admin oprtion) i can`t initialize the ICO, its is showing "Assertion failed" error, First fix this issue after fully reading the project

and in staking portion also not working, means after initialize in beta.solpg(online ide) still not showing any staking value and others error still facing, Fix the issue fully all and then regenerate the particular file after modification particular part


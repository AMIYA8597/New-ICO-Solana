use anchor_lang::prelude::*;
use anchor_spl::associated_token::AssociatedToken;
use anchor_spl::{
    associated_token::get_associated_token_address,
    token::{self, Mint, TokenAccount},
};
 
declare_id!("GmLfd5j41fTbgL9G3C58Q4xUHbwmyXKfEE22dJg9s9QY");
 
#[program]
pub mod advanced_ico_program {
    use super::*;
 
    pub fn initialize(
        ctx: Context<Initialize>,
        total_supply: u64,
        token_price: u64,
        start_time: i64,
        duration: i64,
        round_type: RoundType,
    ) -> Result<()> {
        let ico = &mut ctx.accounts.ico_account;
        ico.authority = ctx.accounts.authority.key();
        ico.token_mint = ctx.accounts.token_mint.key();
        ico.total_supply = total_supply;
        ico.token_price = token_price;
        ico.start_time = start_time;
        ico.duration = duration;
        ico.tokens_sold = 0;
        ico.is_active = true;
        ico.round_type = round_type;
        ico.seed_investors = Vec::new();
        ico.total_investors = 0;
        ico.purchase_counter = 0;
 
        Ok(())
    }
 
    pub fn add_seed_investor(ctx: Context<AddSeedInvestor>, investor: Pubkey) -> Result<()> {
        let ico = &mut ctx.accounts.ico_account;
        require!(
            ctx.accounts.authority.key() == ico.authority,
            IcoError::Unauthorized
        );
        require!(
            !ico.seed_investors.contains(&investor),
            IcoError::InvestorAlreadyExists
        );
 
        ico.seed_investors.push(investor);
        Ok(())
    }
 
    pub fn remove_seed_investor(ctx: Context<RemoveSeedInvestor>, investor: Pubkey) -> Result<()> {
        let ico = &mut ctx.accounts.ico_account;
        require!(
            ctx.accounts.authority.key() == ico.authority,
            IcoError::Unauthorized
        );
        if let Some(index) = ico.seed_investors.iter().position(|&x| x == investor) {
            ico.seed_investors.remove(index);
        }
        Ok(())
    }
 
    pub fn update_ico_parameters(
        ctx: Context<UpdateIcoParameters>,
        total_supply: Option<u64>,
        token_price: Option<u64>,
        start_time: Option<i64>,
        duration: Option<i64>,
        round_type: Option<RoundType>,
    ) -> Result<()> {
        let ico = &mut ctx.accounts.ico_account;
        require!(
            ctx.accounts.authority.key() == ico.authority,
            IcoError::Unauthorized
        );
 
        if let Some(supply) = total_supply {
            ico.total_supply = supply;
        }
        if let Some(price) = token_price {
            ico.token_price = price;
        }
        if let Some(start) = start_time {
            ico.start_time = start;
        }
        if let Some(dur) = duration {
            ico.duration = dur;
        }
        if let Some(round) = round_type {
            ico.round_type = round;
        }
        Ok(())
    }
 
    pub fn buy_tokens(ctx: Context<BuyTokens>, amount: u64) -> Result<()> {
        let current_time = Clock::get()?.unix_timestamp;
        let ico = &mut ctx.accounts.ico_account;
 
        require!(
            ico.is_active
                && current_time >= ico.start_time
                && current_time < ico.start_time + ico.duration,
            IcoError::IcoNotActive
        );
 
        if ico.round_type == RoundType::SeedRound {
            require!(
                ico.seed_investors.contains(&ctx.accounts.buyer.key()),
                IcoError::NotWhitelisted
            );
        }
 
        require!(
            ico.tokens_sold + amount <= ico.total_supply,
            IcoError::InsufficientTokens
        );
 
        let total_cost = amount
            .checked_mul(ico.token_price)
            .ok_or(IcoError::MathOverflow)?;
 
        // Transfer payment
        let transfer_context = CpiContext::new(
            ctx.accounts.system_program.to_account_info(),
            anchor_lang::system_program::Transfer {
                from: ctx.accounts.buyer.to_account_info(),
                to: ctx.accounts.treasury_wallet.to_account_info(),
            },
        );
        anchor_lang::system_program::transfer(transfer_context, total_cost)?;
 
        // Initialize purchase account
        let purchase = &mut ctx.accounts.purchase_account;
        purchase.buyer = ctx.accounts.buyer.key();
        purchase.amount = amount;
        purchase.is_distributed = false;
        purchase.timestamp = current_time;
        purchase.ico = ico.key();
        ico.purchase_counter = ico
            .purchase_counter
            .checked_add(1)
            .ok_or(IcoError::MathOverflow)?;
 
        // Update ICO stats
        ico.tokens_sold = ico
            .tokens_sold
            .checked_add(amount)
            .ok_or(IcoError::MathOverflow)?;
 
        ico.total_investors = ico
            .total_investors
            .checked_add(1)
            .ok_or(IcoError::MathOverflow)?;
 
        emit!(TokenPurchaseEvent {
            buyer: ctx.accounts.buyer.key(),
            amount,
            price: ico.token_price,
            timestamp: current_time,
        });
 
        Ok(())
    }
 
    pub fn distribute_tokens(ctx: Context<DistributeTokens>) -> Result<()> {
        let ico = &ctx.accounts.ico_account;
        let purchase = &mut ctx.accounts.purchase_account;
 
        require!(!purchase.is_distributed, IcoError::AlreadyDistributed);
        // require!(!ico.is_active, IcoError::IcoStillActive);
 
        // Transfer tokens
        let transfer_ctx = CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            token::Transfer {
                from: ctx.accounts.treasury_token_account.to_account_info(),
                to: ctx.accounts.buyer_token_account.to_account_info(),
                authority: ctx.accounts.authority.to_account_info(),
            },
        );
 
        token::transfer(transfer_ctx, purchase.amount)?;
 
        // Mark as distributed
        purchase.is_distributed = true;
 
        emit!(PurchaseEvent {
            buyer: purchase.buyer,
            amount: purchase.amount,
            is_distributed: true,
        });/*  */
 
        Ok(())
    }
 
    pub fn end_ico(ctx: Context<EndIco>) -> Result<()> {
        let ico = &mut ctx.accounts.ico_account;
        let current_time = Clock::get()?.unix_timestamp;
        require!(
            current_time >= ico.start_time + ico.duration,
            IcoError::IcoStillActive
        );
        ico.is_active = false;
        Ok(())
    }
 
    pub fn get_seed_investors(ctx: Context<GetSeedInvestors>) -> Result<()> {
        let ico = &ctx.accounts.ico_account;
        msg!("Number of seed investors: {}", ico.seed_investors.len());
        for (index, investor) in ico.seed_investors.iter().enumerate() {
            msg!("Seed Investor {}: {}", index + 1, investor);
        }
        Ok(())
    }
}
 
#[derive(AnchorSerialize, AnchorDeserialize, Clone, PartialEq)]
pub enum RoundType {
    SeedRound,
    PreICO,
    PublicICO,
}
 
impl Default for RoundType {
    fn default() -> Self {
        RoundType::SeedRound
    }
}
 
#[event]
pub struct TokenPurchaseEvent {
    pub buyer: Pubkey,
    pub amount: u64,
    pub price: u64,
    pub timestamp: i64,
}
 
#[event]
pub struct PurchaseEvent {
    pub buyer: Pubkey,
    pub amount: u64,
    pub is_distributed: bool,
}
 
#[account]
#[derive(Default)]
pub struct IcoAccount {
    pub authority: Pubkey,           // 32
    pub token_mint: Pubkey,          // 32
    pub total_supply: u64,           // 8
    pub token_price: u64,            // 8
    pub tokens_sold: u64,            // 8
    pub start_time: i64,             // 8
    pub duration: i64,               // 8
    pub is_active: bool,             // 1
    pub round_type: RoundType,       // 1
    pub seed_investors: Vec<Pubkey>, // 4 + (32 * n)
    pub total_investors: u64,        // 8
    pub purchase_counter: u64,
}
 
#[account]
pub struct PurchaseAccount {
    pub buyer: Pubkey,        // 32
    pub amount: u64,          // 8
    pub is_distributed: bool, // 1
    pub timestamp: i64,       // 8
    pub ico: Pubkey,          // 32 (reference to parent ICO)
}
 
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,
 
    #[account(
        init,
        payer = authority,
        space = 8 +    // discriminator
            32 +       // authority
            32 +       // token_mint
            8 +        // total_supply
            8 +        // token_price
            8 +        // tokens_sold
            8 +        // start_time
            8 +        // duration
            1 +        // is_active
            1 +        // round_type
            4 + (32 * 100) + // seed_investors vector with max 100 investors
            8 +
            8,         // total_investors
        seeds = [b"ico"],
        bump
    )]
    pub ico_account: Account<'info, IcoAccount>,
 
    #[account(mut)]
    pub token_mint: Account<'info, Mint>,
    pub system_program: Program<'info, System>,
}
 
#[derive(Accounts)]
pub struct BuyTokens<'info> {
    #[account(mut)]
    pub buyer: Signer<'info>,
 
    #[account(mut, seeds = [b"ico"], bump)]
    pub ico_account: Account<'info, IcoAccount>,
 
    #[account(
        init,
        payer = buyer,
        space = 8 + 32 + 8 + 1 + 8 + 32, // discriminator + fields
        seeds = [b"purchase",buyer.key().as_ref(),&ico_account.purchase_counter.to_le_bytes()],
        bump
    )]
    pub purchase_account: Account<'info, PurchaseAccount>,
 
    #[account(mut)]
    pub treasury_wallet: SystemAccount<'info>,
 
    pub token_program: Program<'info, token::Token>,
    pub system_program: Program<'info, System>,
}
 
#[derive(Accounts)]
pub struct DistributeTokens<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,
 
    #[account(
        mut,
        seeds = [b"ico"],
        bump,
        has_one = authority
    )]
    pub ico_account: Account<'info, IcoAccount>,
 
    #[account(
        mut,
        seeds = [b"purchase",  purchase_account.buyer.as_ref()],
        bump,
        constraint = !purchase_account.is_distributed @ IcoError::AlreadyDistributed,
        constraint = purchase_account.ico == ico_account.key() @ IcoError::InvalidPurchase
    )]
    pub purchase_account: Account<'info, PurchaseAccount>,
 
    #[account(
        mut,
        constraint = treasury_token_account.owner == authority.key() @ IcoError::Unauthorized,
        constraint = treasury_token_account.mint == ico_account.token_mint @ IcoError::InvalidTokenMint
    )]
    pub treasury_token_account: Account<'info, TokenAccount>,
 
    #[account(mut)]
    /// CHECK: Account checked in token transfer
    pub buyer_token_account: UncheckedAccount<'info>,
 
    pub token_program: Program<'info, token::Token>,
    pub system_program: Program<'info, System>,
}
 
#[derive(Accounts)]
pub struct UpdateIcoParameters<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,
    #[account(mut, seeds = [b"ico"], bump)]
    pub ico_account: Account<'info, IcoAccount>,
}
 
#[derive(Accounts)]
pub struct EndIco<'info> {
    #[account(mut, seeds = [b"ico"], bump)]
    pub ico_account: Account<'info, IcoAccount>,
}
 
#[derive(Accounts)]
pub struct AddSeedInvestor<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,
    #[account(mut, seeds = [b"ico"], bump)]
    pub ico_account: Account<'info, IcoAccount>,
}
 
#[derive(Accounts)]
pub struct RemoveSeedInvestor<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,
    #[account(mut, seeds = [b"ico"], bump)]
    pub ico_account: Account<'info, IcoAccount>,
}
 
#[derive(Accounts)]
pub struct GetSeedInvestors<'info> {
    #[account(seeds = [b"ico"], bump)]
    pub ico_account: Account<'info, IcoAccount>,
}
 
#[error_code]
pub enum IcoError {
    #[msg("ICO is not currently active")]
    IcoNotActive,
    #[msg("Insufficient tokens remaining")]
    InsufficientTokens,
    #[msg("ICO is still active")]
    IcoStillActive,
    #[msg("You are not authorized to perform this action")]
    Unauthorized,
    #[msg("Purchase not found")]
    PurchaseNotFound,
    #[msg("Mathematical overflow occurred")]
    MathOverflow,
    #[msg("Investor is not whitelisted for the seed round")]
    NotWhitelisted,
    #[msg("Tokens already distributed for this purchase")]
    AlreadyDistributed,
    #[msg("Invalid purchase account")]
    InvalidPurchase,
    #[msg("Invalid token mint")]
    InvalidTokenMint,
    #[msg("Investor is already in the seed investors list")]
    InvestorAlreadyExists,
}






Based on the smart contract i create this files in my reactjs project



src/pages/BuyTokens.js



import React, { useState, useEffect } from 'react';
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { PublicKey } from '@solana/web3.js';
import { getProgram } from '../utils/anchor-connection';
import * as anchor from '@project-serum/anchor';
import { TOKEN_PROGRAM_ID, getAssociatedTokenAddress } from '@solana/spl-token';
import { formatSol } from '../utils/formatters';

const BuyTokens = () => {
  const { connection } = useConnection();
  const wallet = useWallet();
  const [amount, setAmount] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');
  const [icoData, setIcoData] = useState(null);

  useEffect(() => {
    fetchIcoData();
  }, [connection, wallet.publicKey]);

  const fetchIcoData = async () => {

    if (!wallet.publicKey) return;
    
    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from('ico')],
        program.programId
      );
      const data = await program.account.icoAccount.fetch(icoAccount);
      setIcoData(data);
    } catch (err) {
      console.error('Error fetching ICO data:', err);
      setError('Failed to fetch ICO data. Please try again later.');
    }
  };

  const handleBuyTokens = async (e) => {
    e.preventDefault();
    if (!wallet.publicKey || !wallet.signTransaction || !icoData) return;

    setLoading(true);
    setError('');
    setSuccess('');

    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from('ico')],
        program.programId
      );

      const mint = icoData.tokenMint;

      const treasuryWallet = icoData.authority;

      const buyerTokenAccount = await getAssociatedTokenAddress(mint, wallet.publicKey);

      const treasuryTokenAccount = await getAssociatedTokenAddress(mint, treasuryWallet);

      const [purchaseAccount] = await PublicKey.findProgramAddress(
        [Buffer.from('purchase'), wallet.publicKey.toBuffer()],
        program.programId
      );

      const tx = await program.methods
        .buyTokens(new anchor.BN(amount))
        .accounts({
          buyer: wallet.publicKey,
          icoAccount,
          purchaseAccount,
          buyerTokenAccount,
          treasuryTokenAccount,
          treasuryWallet,
          tokenMint: mint,
          tokenProgram: TOKEN_PROGRAM_ID,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .rpc();

      setSuccess(`Tokens purchased successfully! Transaction ID: ${tx.substring(0, 8)}...`);
      fetchIcoData(); // Refresh ICO data after successful purchase
    } catch (err) {
      console.error('Error buying tokens:', err);
      if (err.message.includes('custom program error: 0x0')) {
        setError('Token purchase failed. You may have already purchased tokens or there might be an issue with the ICO contract.');
      } else {
        setError('Token purchase failed. Please try again later.');
      }
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="max-w-lg mx-auto">
      <div className="bg-white shadow-lg rounded-lg p-6">
        <h2 className="text-2xl font-bold mb-6 text-gray-800">Buy Tokens</h2>
        <form onSubmit={handleBuyTokens} className="space-y-4">
          <div>
            <label htmlFor="amount" className="block text-sm font-medium text-gray-700 mb-1">
              Amount of tokens to buy (in SOL):
            </label>
            <input
              type="number"
              id="amount"
              value={amount}
              onChange={(e) => setAmount(e.target.value)}
              className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-sky-500 focus:border-sky-500"
              required
              min="0"
              step="0.000000001"
            />
          </div>
          <button
            type="submit"
            disabled={loading || !wallet.publicKey}
            className="w-full bg-sky-600 text-white py-2 px-4 rounded-md hover:bg-sky-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-sky-500 disabled:opacity-50 disabled:cursor-not-allowed transition duration-200"
          >
            {loading ? 'Processing...' : 'Buy Tokens'}
          </button>
        </form>
        {error && (
          <div className="mt-4 p-4 bg-red-100 border border-red-400 text-red-700 rounded-md text-sm">
            {error}
          </div>
        )}
        {success && (
          <div className="mt-4 p-4 bg-green-100 border border-green-400 text-green-700 rounded-md text-sm">
            {success}
          </div>
        )}
        {icoData && (
          <div className="mt-6 p-4 bg-gray-100 rounded-md">
            <h3 className="text-lg font-semibold mb-2 text-gray-800">Current ICO Status</h3>
            <p className="text-sm text-gray-600"><strong>Token Price:</strong> {formatSol(icoData.tokenPrice)} SOL</p>
            <p className="text-sm text-gray-600"><strong>Tokens Available:</strong> {formatSol(icoData.totalSupply - icoData.tokensSold)} SOL</p>
            <div className="mt-2">
              <div className="relative pt-1">
                <div className="flex mb-2 items-center justify-between">
                  <div>
                    <span className="text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full text-sky-600 bg-sky-200">
                      {((Number(icoData.tokensSold) / Number(icoData.totalSupply)) * 100).toFixed(2)}% Sold
                    </span>
                  </div>
                </div>
                <div className="overflow-hidden h-2 mb-4 text-xs flex rounded bg-sky-200">
                  <div
                    style={{ width: `${(Number(icoData.tokensSold) / Number(icoData.totalSupply)) * 100}%` }}
                    className="shadow-none flex flex-col text-center whitespace-nowrap text-white justify-center bg-sky-500"
                  ></div>
                </div>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default BuyTokens;






src/pages/Dashboard.js


import React, { useState, useEffect } from 'react';
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { PublicKey } from '@solana/web3.js';
import { getProgram } from '../utils/anchor-connection';
import { formatUnixTimestamp, formatLamports } from '../utils/formatters';

const Dashboard = () => {
  const { connection } = useConnection();
  const wallet = useWallet();
  const [icoData, setIcoData] = useState(null);
  const [timeLeft, setTimeLeft] = useState(null);

  useEffect(() => {
    if (wallet.publicKey) {
      fetchIcoData();
    }
  }, [connection, wallet.publicKey]);

  useEffect(() => {
    if (icoData) {
      const timer = setInterval(() => {
        const now = Math.floor(Date.now() / 1000);
        const endTime = Number(icoData.startTime) + Number(icoData.duration);
        const remaining = endTime - now;
        
        if (remaining <= 0) {
          clearInterval(timer);
          setTimeLeft("ICO Ended");
        } else {
          const days = Math.floor(remaining / 86400);
          const hours = Math.floor((remaining % 86400) / 3600);
          const minutes = Math.floor((remaining % 3600) / 60);
          const seconds = remaining % 60;
          setTimeLeft(`${days}d ${hours}h ${minutes}m ${seconds}s`);
        }
      }, 1000);

      return () => clearInterval(timer);
    }
  }, [icoData]);

  const fetchIcoData = async () => {
    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from("ico")],
        program.programId
      );
      const data = await program.account.icoAccount.fetch(icoAccount);
      setIcoData(data);
    } catch (err) {
      console.error('Error:', err);
    }
  };

  if (!wallet.publicKey) {
    return (
      <div className="text-center py-12">
        <h2 className="text-2xl font-semibold mb-4">Welcome to Solana ICO Dashboard</h2>
        <p className="text-gray-600">Please connect your wallet to view ICO details.</p>
      </div>
    );
  }

  if (!icoData) {
    return (
      <div className="text-center py-12">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-purple-600 mx-auto"></div>
        <p className="mt-4 text-gray-600">Loading ICO details...</p>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <h1 className="text-3xl font-bold mb-6">ICO Dashboard</h1>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div className="card bg-gradient-to-br from-sky-700 to-sky-800 text-white">
          <h2 className="text-xl font-semibold mb-2">Total Supply</h2>
          <p className="text-3xl font-bold">{formatLamports(icoData.totalSupply)}</p>
          <p className="mt-2 text-sm">Round Type: {Object.keys(icoData.roundType)[0]}</p>
        </div>
        <div className="card bg-gradient-to-br from-slate-500 to-slate-600 text-white">
          <h2 className="text-xl font-semibold mb-2">Tokens Sold</h2>
          <p className="text-3xl font-bold">{formatLamports(icoData.tokensSold)}</p>
          <p className="mt-2 text-sm">
            {((Number(icoData.tokensSold) / Number(icoData.totalSupply)) * 100).toFixed(2)}% of total supply
          </p>
        </div>
      </div>

      <div className="card">
        <h2 className="text-2xl font-semibold mb-4">Sale Progress</h2>
        <div className="relative pt-1">
          <div className="flex mb-2 items-center justify-between">
            <div>
              <span className="text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full text-sky-600 bg-sky-200">
                {((Number(icoData.tokensSold) / Number(icoData.totalSupply)) * 100).toFixed(2)}%
              </span>
            </div>
            <div className="text-right">
              <span className="text-xs font-semibold inline-block text-sky-600">
                {formatLamports(icoData.tokensSold)} / {formatLamports(icoData.totalSupply)}
              </span>
            </div>
          </div>
          <div className="overflow-hidden h-2 mb-4 text-xs flex rounded bg-sky-200">
            <div
              style={{ width: `${(Number(icoData.tokensSold) / Number(icoData.totalSupply)) * 100}%` }}
              className="shadow-none flex flex-col text-center whitespace-nowrap text-white justify-center bg-sky-500"
            ></div>
          </div>
        </div>
      </div>

      <div className="card">
        <h2 className="text-2xl font-semibold mb-4">ICO Details</h2>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <p className="text-sm font-medium text-gray-500">Token Price</p>
            <p className="text-lg font-semibold">{formatLamports(icoData.tokenPrice)} SOL</p>
          </div>
          <div>
            <p className="text-sm font-medium text-gray-500">Start Time</p>
            <p className="text-lg font-semibold">{formatUnixTimestamp(icoData.startTime)}</p>
          </div>
          <div>
            <p className="text-sm font-medium text-gray-500">End Time</p>
            <p className="text-lg font-semibold">
              {formatUnixTimestamp(Number(icoData.startTime) + Number(icoData.duration))}
            </p>
          </div>
          <div>
            <p className="text-sm font-medium text-gray-500">Time Remaining</p>
            <p className="text-lg font-semibold">{timeLeft}</p>
          </div>
          <div>
            <p className="text-sm font-medium text-gray-500">Status</p>
            <p className="text-lg font-semibold">
              {icoData.isActive ? (
                <span className="text-green-500">Active</span>
              ) : (
                <span className="text-red-500">Inactive</span>
              )}
            </p>
          </div>
        </div>
      </div>
    </div>
  );
};

export default Dashboard;






src/pages/DistributeToken.js



import React, { useState, useEffect } from 'react';
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { PublicKey } from '@solana/web3.js';
import { getProgram } from '../utils/anchor-connection';
import { lamportsToSol } from '../utils/formatters';
import { distributeTokens } from '../utils/ico-instructions';

const DistributeTokens = () => {
  const { connection } = useConnection();
  const wallet = useWallet();
  const [purchases, setPurchases] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');

  useEffect(() => {
    if (wallet.publicKey) {
      fetchPurchases();
    }
  }, [connection, wallet.publicKey]);

  const fetchPurchases = async () => {
    setIsLoading(true);
    setError('');
    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from("ico")],
        program.programId
      );
      const icoData = await program.account.icoAccount.fetch(icoAccount);

      // Fetch all purchase accounts
      const purchaseAccounts = await program.account.purchaseAccount.all();
      
      setPurchases(purchaseAccounts.map(account => ({
        buyer: account.account.buyer.toString(),
        amount: account.account.amount,
        isDistributed: account.account.isDistributed,
        timestamp: account.account.timestamp,
      })));
    } catch (err) {
      console.error('Error:', err);
      setError('Failed to fetch purchases');
    } finally {
      setIsLoading(false);
    }
  };

  const handleDistribute = async (buyer) => {
    setError('');
    setSuccess('');
    setIsLoading(true);
    try {
      const program = getProgram(connection, wallet);
      const [purchaseAccount] = await PublicKey.findProgramAddress(
        [Buffer.from("purchase"), new PublicKey(buyer).toBuffer()],
        program.programId
      );
      
      await distributeTokens(connection, wallet, purchaseAccount);
      setSuccess(`Tokens distributed successfully to ${buyer}`);
      fetchPurchases(); // Refresh purchase data after distribution
    } catch (err) {
      console.error('Error:', err);
      setError(err.message);
    } finally {
      setIsLoading(false);
    }
  };

  if (!wallet.publicKey) {
    return (
      <div className="text-center py-12">
        <h2 className="text-2xl font-semibold mb-4">Distribute Tokens</h2>
        <p className="text-gray-600">Please connect your wallet to distribute tokens.</p>
      </div>
    );
  }

  return (
    <div className="max-w-4xl mx-auto">
      <h1 className="text-3xl font-bold mb-6">Distribute Tokens</h1>
      <div className="bg-white rounded-lg shadow-md overflow-hidden">
        <h2 className="text-xl font-semibold p-6 bg-gray-50 border-b">Token Purchases</h2>
        {isLoading ? (
          <div className="text-center py-12">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary-600 mx-auto"></div>
            <p className="mt-4 text-gray-600">Loading purchases...</p>
          </div>
        ) : (
          <div className="overflow-x-auto">
            <table className="min-w-full divide-y divide-gray-200">
              <thead className="bg-gray-50">
                <tr>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Buyer</th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Amount</th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Actions</th>
                </tr>
              </thead>
              <tbody className="bg-white divide-y divide-gray-200">
                {purchases.map((purchase) => (
                  <tr key={purchase.buyer}>
                    <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">{purchase.buyer}</td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">{lamportsToSol(purchase.amount).toFixed(4)} SOL</td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                      {purchase.isDistributed ? (
                        <span className="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-green-100 text-green-800">
                          Distributed
                        </span>
                      ) : (
                        <span className="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-yellow-100 text-yellow-800">
                          Pending
                        </span>
                      )}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm font-medium">
                      {!purchase.isDistributed && (
                        <button
                          onClick={() => handleDistribute(purchase.buyer)}
                          className="text-primary-600 hover:text-primary-900"
                          disabled={isLoading}
                        >
                          Distribute
                        </button>
                      )}
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )}
      </div>
      {error && <p className="mt-4 text-red-600">{error}</p>}
      {success && <p className="mt-4 text-green-600">{success}</p>}
    </div>
  );
};

export default DistributeTokens;









src/pages/EndIco.js



import React, { useState, useEffect } from 'react';
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { PublicKey } from '@solana/web3.js';
import { getProgram } from '../utils/anchor-connection';
import { lamportsToSol } from '../utils/formatters';
import { endIco } from '../utils/ico-instructions';

const EndIco = () => {
  const { connection } = useConnection();
  const wallet = useWallet();
  const [icoData, setIcoData] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');

  useEffect(() => {
    if (wallet.publicKey) {
      fetchIcoData();
    }
  }, [connection, wallet.publicKey]);

  const fetchIcoData = async () => {
    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from("ico")],
        program.programId
      );
      const data = await program.account.icoAccount.fetch(icoAccount);
      setIcoData(data);
    } catch (err) {
      console.error('Error:', err);
      setError('Failed to fetch ICO data');
    } finally {
      setIsLoading(false);
    }
  };

  const handleEndIco = async () => {
    setError('');
    setSuccess('');
    setIsLoading(true);
    try {
      await endIco(connection, wallet);
      setSuccess('ICO ended successfully');
      fetchIcoData(); // Refresh ICO data after ending
    } catch (err) {
      console.error('Error:', err);
      setError(err.message);
    } finally {
      setIsLoading(false);
    }
  };

  if (!wallet.publicKey) {
    return (
      <div className="text-center py-12">
        <h2 className="text-2xl font-semibold mb-4">End ICO</h2>
        <p className="text-gray-600">Please connect your wallet to end the ICO.</p>
      </div>
    );
  }

  return (
    <div className="max-w-2xl mx-auto">
      <h1 className="text-3xl font-bold mb-6">End ICO</h1>
      <div className="bg-white rounded-lg shadow-md p-6">
        {isLoading ? (
          <div className="text-center py-12">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary-600 mx-auto"></div>
            <p className="mt-4 text-gray-600">Loading ICO data...</p>
          </div>
        ) : (
          <>
            <div className="mb-6">
              <h2 className="text-xl font-semibold mb-4">ICO Status</h2>
              <p className="text-lg">
                Status: {' '}
                {icoData?.isActive ? (
                  <span className="text-green-600 font-semibold">Active</span>
                ) : (
                  <span className="text-red-600 font-semibold">Inactive</span>
                )}
              </p>
              <p className="text-lg mt-2">
                Tokens Sold: {lamportsToSol(icoData?.tokensSold).toFixed(4)} SOL
              </p>
              <p className="text-lg mt-2">
                Total Raised: {lamportsToSol(icoData?.totalSupply).toFixed(4)} SOL
              </p>
            </div>
            {icoData?.isActive && (
              <div className="mt-6">
                <button
                  onClick={handleEndIco}
                  className="w-full bg-red-600 text-white py-2 px-4 rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 disabled:opacity-50"
                  disabled={isLoading}
                >
                  {isLoading ? 'Ending ICO...' : 'End ICO'}
                </button>
                <p className="mt-2 text-sm text-gray-600">
                  Warning: This action is irreversible. Make sure you want to end the ICO before proceeding.
                </p>
              </div>
            )}
            {!icoData?.isActive && (
              <p className="text-lg font-semibold text-center">The ICO has already ended.</p>
            )}
          </>
        )}
        {error && <p className="mt-4 text-red-600">{error}</p>}
        {success && <p className="mt-4 text-green-600">{success}</p>}
      </div>
    </div>
  );
};

export default EndIco;








src/pages/InitializeIco.js



import React, { useState } from 'react';
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { PublicKey } from '@solana/web3.js';
import { getProgram } from '../utils/anchor-connection';
import * as anchor from '@project-serum/anchor';

import { Buffer } from "buffer";

Buffer.from("anything", "base64");
window.Buffer = window.Buffer || require("buffer").Buffer;


const InitializeIco = () => {
  const { connection } = useConnection();
  const wallet = useWallet();
  const [totalSupply, setTotalSupply] = useState('');
  const [tokenPrice, setTokenPrice] = useState('');
  const [startTime, setStartTime] = useState('');
  const [duration, setDuration] = useState('');
  const [roundType, setRoundType] = useState('SeedRound');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');

  const handleInitialize = async (e) => {
    e.preventDefault();
    if (!wallet.publicKey || !wallet.signTransaction) return;

    setLoading(true);
    setError('');
    setSuccess('');

    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from('ico')],
        program.programId
      );

      const mint = new PublicKey(process.env.REACT_APP_TOKEN_MINT_ADDRESS);

      const tx = await program.methods
        .initialize(
          new anchor.BN(totalSupply),
          new anchor.BN(tokenPrice),
          new anchor.BN(Math.floor(new Date(startTime).getTime() / 1000)),
          new anchor.BN(parseInt(duration) * 24 * 60 * 60),
          { [roundType]: {} }
        )
        .accounts({
          authority: wallet.publicKey,
          icoAccount,
          tokenMint: mint,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .rpc();

      setSuccess(`ICO initialized successfully! TxID: ${tx}`);
    } catch (err) {
      console.error('Error initializing ICO:', err);
      setError(`Error: ${err.message}`);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="container mx-auto px-4 py-8">
      <h2 className="text-2xl font-bold mb-6">Initialize ICO</h2>
      <form onSubmit={handleInitialize} className="space-y-4">
        <div>
          <label htmlFor="totalSupply" className="block text-sm font-medium text-gray-700">Total Supply:</label>
          <input
            type="number"
            id="totalSupply"
            value={totalSupply}
            onChange={(e) => setTotalSupply(e.target.value)}
            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2"
            required
          />
        </div>
        <div>
          <label htmlFor="tokenPrice" className="block text-sm font-medium text-gray-700">Token Price (in lamports):</label>
          <input
            type="number"
            id="tokenPrice"
            value={tokenPrice}
            onChange={(e) => setTokenPrice(e.target.value)}
            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2"
            required
          />
        </div>
        <div>
          <label htmlFor="startTime" className="block text-sm font-medium text-gray-700">Start Time:</label>
          <input
            type="datetime-local"
            id="startTime"
            value={startTime}
            onChange={(e) => setStartTime(e.target.value)}
            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2"
            required
          />
        </div>
        <div>
          <label htmlFor="duration" className="block text-sm font-medium text-gray-700">Duration (in days):</label>
          <input
            type="number"
            id="duration"
            value={duration}
            onChange={(e) => setDuration(e.target.value)}
            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2"
            required
          />
        </div>
        <div>
          <label htmlFor="roundType" className="block text-sm font-medium text-gray-700">Round Type:</label>
          <select
            id="roundType"
            value={roundType}
            onChange={(e) => setRoundType(e.target.value)}
            className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2"
            required
          >
            <option value="SeedRound">Seed Round</option>
            <option value="PreICO">Pre-ICO</option>
            <option value="PublicICO">Public ICO</option>
          </select>
        </div>
        <button
          type="submit"
          disabled={loading}
          className="w-full bg-blue-500 text-white py-2 px-4 rounded-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:opacity-50"
        >
          {loading ? 'Initializing...' : 'Initialize ICO'}
        </button>
      </form>
      {error && <div className="mt-4 p-4 bg-red-100 border border-red-400 text-red-700 rounded">{error}</div>}
      {success && <div className="mt-4 p-4 bg-green-100 border border-green-400 text-green-700 rounded">{success}</div>}
    </div>
  );
};

export default InitializeIco;






src/pages/ManageInvestors.js



import React, { useState, useEffect } from 'react';
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { PublicKey } from '@solana/web3.js';
import { getProgram } from '../utils/anchor-connection';

const ManageInvestors = () => {
  const { connection } = useConnection();
  const wallet = useWallet();
  const [investors, setInvestors] = useState([]);
  const [newInvestor, setNewInvestor] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');

  useEffect(() => {
    fetchSeedInvestors();
  }, [connection, wallet.publicKey]);

  const fetchSeedInvestors = async () => {
    if (!wallet.publicKey) return;
    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from("ico")],
        program.programId
      );
      const icoData = await program.account.icoAccount.fetch(icoAccount);
      setInvestors(icoData.seedInvestors.map(investor => investor.toBase58()));
    } catch (err) {
      console.error('Error fetching seed investors:', err);
      setError('Failed to fetch seed investors');
    }
  };

  const handleAddInvestor = async (e) => {
    e.preventDefault();
    if (!wallet.publicKey || !wallet.signTransaction) return;

    setLoading(true);
    setError('');
    setSuccess('');

    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from("ico")],
        program.programId
      );

      await program.methods
        .addSeedInvestor(new PublicKey(newInvestor))
        .accounts({
          authority: wallet.publicKey,
          icoAccount,
        })
        .rpc();

      setSuccess(`Investor ${newInvestor} added successfully!`);
      setNewInvestor('');
      fetchSeedInvestors();
    } catch (err) {
      console.error('Error adding seed investor:', err);
      setError(`Error: ${err.message}`);
    } finally {
      setLoading(false);
    }
  };

  const handleRemoveInvestor = async (investorToRemove) => {
    if (!wallet.publicKey || !wallet.signTransaction) return;

    setLoading(true);
    setError('');
    setSuccess('');

    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from("ico")],
        program.programId
      );

      await program.methods
        .removeSeedInvestor(new PublicKey(investorToRemove))
        .accounts({
          authority: wallet.publicKey,
          icoAccount,
        })
        .rpc();

      setSuccess(`Investor ${investorToRemove} removed successfully!`);
      fetchSeedInvestors();
    } catch (err) {
      console.error('Error removing seed investor:', err);
      setError(`Error: ${err.message}`);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="max-w-2xl mx-auto">
      <div className="bg-white shadow-md rounded-lg overflow-hidden">
        <div className="px-6 py-4">
          <h2 className="text-2xl font-bold text-gray-800 mb-4">Manage Seed Investors</h2>
          <form onSubmit={handleAddInvestor} className="mb-6">
            <div className="flex space-x-2">
              <input
                type="text"
                value={newInvestor}
                onChange={(e) => setNewInvestor(e.target.value)}
                placeholder="Enter Solana address"
                className="flex-grow px-3 py-2 placeholder-gray-400 border rounded-lg focus:outline-none focus:ring-2 focus:ring-sky-600 focus:border-transparent"
                required
              />
              <button
                type="submit"
                disabled={loading}
                className="bg-sky-600 hover:bg-sky-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline transition duration-150 ease-in-out"
              >
                {loading ? 'Adding...' : 'Add Investor'}
              </button>
            </div>
          </form>
          {error && (
            <div className="mb-4 p-4 bg-red-100 border border-red-400 text-red-700 rounded-md text-sm">
              {error}
            </div>
          )}
          {success && (
            <div className="mb-4 p-4 bg-green-100 border border-green-400 text-green-700 rounded-md text-sm">
              {success}
            </div>
          )}
          <h3 className="text-xl font-semibold mb-4">Current Seed Investors</h3>
          <ul className="space-y-2">
            {investors.map((investor, index) => (
              <li key={index} className="flex justify-between items-center bg-gray-100 p-3 rounded-lg">
                <span className="text-sm font-mono text-gray-600">{investor}</span>
                <button
                  onClick={() => handleRemoveInvestor(investor)}
                  disabled={loading}
                  className="bg-red-500 hover:bg-red-600 text-white font-bold py-1 px-3 rounded text-xs focus:outline-none focus:shadow-outline transition duration-150 ease-in-out"
                >
                  Remove
                </button>
              </li>
            ))}
          </ul>
        </div>
      </div>
    </div>
  );
};
export default ManageInvestors;






src/pages/TokenBalance.js



import React, { useState, useEffect } from 'react';
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { PublicKey } from '@solana/web3.js';
import {
  TOKEN_PROGRAM_ID,
  getAssociatedTokenAddress,
  getAccount,
} from '@solana/spl-token';
import { formatSol } from '../utils/formatters';
import { getProgram } from '../utils/anchor-connection';

import { Buffer } from "buffer";

Buffer.from("anything", "base64");
window.Buffer = window.Buffer || require("buffer").Buffer;


const TokenBalance = () => {
  const { connection } = useConnection();
  const wallet = useWallet();
  const [balance, setBalance] = useState(null);
  const [purchaseAmount, setPurchaseAmount] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');

  useEffect(() => {
    fetchTokenBalance();
  }, [connection, wallet.publicKey]);

  const fetchTokenBalance = async () => {
    if (!wallet.publicKey) return;
    setLoading(true);
    setError('');
    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from("ico")],
        program.programId
      );
      const icoData = await program.account.icoAccount.fetch(icoAccount);
      const mint = icoData.tokenMint;

      const tokenAccount = await getAssociatedTokenAddress(mint, wallet.publicKey);
      try {
        const accountInfo = await getAccount(connection, tokenAccount);
        setBalance(accountInfo.amount.toString());
      } catch (err) {
        console.log('No token account found, balance is 0');
        setBalance('0');
      }

      const [purchaseAccount] = await PublicKey.findProgramAddress(
        [Buffer.from("purchase"), wallet.publicKey.toBuffer()],
        program.programId
      );
      try {
        const purchaseData = await program.account.purchaseAccount.fetch(purchaseAccount);
        setPurchaseAmount(purchaseData.amount.toString());
      } catch (err) {
        console.log('No purchase found for this wallet');
        setPurchaseAmount('0');
      }
    } catch (err) {
      console.error('Error fetching token balance:', err);
      setError('Failed to fetch token balance');
    } finally {
      setLoading(false);
    }
  };

  if (loading) return (
    <div className="flex justify-center items-center h-64">
      <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-indigo-500"></div>
    </div>
  );

  if (error) return (
    <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative" role="alert">
      <strong className="font-bold">Error:</strong>
      <span className="block sm:inline"> {error}</span>
    </div>
  );

  return (
    <div className="max-w-lg mx-auto">
      <div className="bg-white shadow-md rounded-lg overflow-hidden">
        <div className="px-6 py-4">
          <h2 className="text-2xl font-bold text-gray-800 mb-4">Your Token Balance</h2>
          <div className="space-y-4">
            <div className="bg-indigo-100 rounded-lg p-4">
              <p className="text-sm font-medium text-indigo-600">Current Balance:</p>
              <p className="text-3xl font-bold text-indigo-800">{formatSol(balance)} SOL</p>
            </div>
            <div className="bg-green-100 rounded-lg p-4">
              <p className="text-sm font-medium text-green-600">Total Purchased:</p>
              <p className="text-3xl font-bold text-green-800">{formatSol(purchaseAmount)} SOL</p>
            </div>
          </div>
        </div>
        <div className="px-6 py-4 bg-gray-50">
          <button
            onClick={fetchTokenBalance}
            className="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline transition duration-150 ease-in-out"
          >
            Refresh Balance
          </button>
        </div>
      </div>
    </div>
  );
};

export default TokenBalance;







src/pages/UpdateIcoParameter.js



import React, { useState, useEffect } from 'react';
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { PublicKey } from '@solana/web3.js';
import { getProgram } from '../utils/anchor-connection';
import * as anchor from '@project-serum/anchor';
import { getRoundTypeFromString, getRoundTypeString } from '../utils/enum-helpers';
import { formatUnixTimestamp, formatSol } from '../utils/formatters';

import { Buffer } from "buffer";

Buffer.from("anything", "base64");
window.Buffer = window.Buffer || require("buffer").Buffer;

const UpdateIcoParameters = () => {
  const { connection } = useConnection();
  const wallet = useWallet();
  const [totalSupply, setTotalSupply] = useState('');
  const [tokenPrice, setTokenPrice] = useState('');
  const [startTime, setStartTime] = useState('');
  const [duration, setDuration] = useState('');
  const [roundType, setRoundType] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');
  const [currentParameters, setCurrentParameters] = useState(null);

  useEffect(() => {
    fetchCurrentParameters();
  }, [connection, wallet.publicKey]);

  const fetchCurrentParameters = async () => {
    if (!wallet.publicKey) return;
    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from('ico')],
        program.programId
      );
      const icoData = await program.account.icoAccount.fetch(icoAccount);
      setCurrentParameters(icoData);
    } catch (err) {
      console.error('Error fetching current parameters:', err);
      setError('Failed to fetch current parameters');
    }
  };

  const handleUpdateParameters = async (e) => {
    e.preventDefault();
    if (!wallet.publicKey || !wallet.signTransaction) return;

    setLoading(true);
    setError('');
    setSuccess('');

    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from('ico')],
        program.programId
      );

      const totalSupplyBN = totalSupply ? new anchor.BN(totalSupply) : null;
      const tokenPriceBN = tokenPrice ? new anchor.BN(tokenPrice) : null;
      const startTimeBN = startTime 
        ? new anchor.BN(Math.floor(new Date(startTime).getTime() / 1000))
        : null;
      const durationBN = duration ? new anchor.BN(duration) : null;
      const roundTypeEnum = roundType ? getRoundTypeFromString(roundType) : null;

      const tx = await program.methods
        .updateIcoParameters(
          totalSupplyBN,
          tokenPriceBN,
          startTimeBN,
          durationBN,
          roundTypeEnum
        )
        .accounts({
          authority: wallet.publicKey,
          icoAccount,
        })
        .rpc();

      setSuccess(`ICO parameters updated successfully! TxID: ${tx}`);
      await fetchCurrentParameters();
      
      setTotalSupply('');
      setTokenPrice('');
      setStartTime('');
      setDuration('');
      setRoundType('');
    } catch (err) {
      console.error('Error updating ICO parameters:', err);
      setError(`Error: ${err.message}`);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="max-w-2xl mx-auto">
      <div className="bg-white shadow-md rounded-lg overflow-hidden">
        <div className="px-6 py-4">
          <h2 className="text-2xl font-bold text-gray-800 mb-6">Update ICO Parameters</h2>
          {currentParameters && (
            <div className="mb-6 p-4 bg-gray-100 rounded-lg">
              <h3 className="text-lg font-semibold mb-2">Current Parameters:</h3>
              <p><strong>Total Supply:</strong> {formatSol(currentParameters.totalSupply)} SOL</p>
              <p><strong>Token Price:</strong> {formatSol(currentParameters.tokenPrice)} SOL</p>
              <p><strong>Start Time:</strong> {formatUnixTimestamp(currentParameters.startTime)}</p>
              <p><strong>Duration:</strong> {currentParameters.duration.toString()} seconds</p>
              <p><strong>Round Type:</strong> {getRoundTypeString(currentParameters.roundType)}</p>
            </div>
          )}
          <form onSubmit={handleUpdateParameters} className="space-y-4">
            <div>
              <label htmlFor="totalSupply" className="block text-sm font-medium text-gray-700">
                Total Supply (in SOL):
              </label>
              <input
                type="text"
                id="totalSupply"
                value={totalSupply}
                onChange={(e) => setTotalSupply(e.target.value)}
                placeholder="Leave blank to keep current value"
                className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"
              />
            </div>
            <div>
              <label htmlFor="tokenPrice" className="block text-sm font-medium text-gray-700">
                Token Price (in SOL):
              </label>
              <input
                type="text"
                id="tokenPrice"
                value={tokenPrice}
                onChange={(e) => setTokenPrice(e.target.value)}
                placeholder="Leave blank to keep current value"
                className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"
              />
            </div>
            <div>
              <label htmlFor="startTime" className="block text-sm font-medium text-gray-700">
                Start Time:
              </label>
              <input
                type="datetime-local"
                id="startTime"
                value={startTime}
                onChange={(e) => setStartTime(e.target.value)}
                className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"
              />
            </div>
            <div>
              <label htmlFor="duration" className="block text-sm font-medium text-gray-700">
                Duration (in seconds):
              </label>
              <input
                type="number"
                id="duration"
                value={duration}
                onChange={(e) => setDuration(e.target.value)}
                placeholder="Leave blank to keep current value"
                className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"
              />
            </div>
            <div>
              <label htmlFor="roundType" className="block text-sm font-medium text-gray-700">
                Round Type:
              </label>
              <select
                id="roundType"
                value={roundType}
                onChange={(e) => setRoundType(e.target.value)}
                className="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"
              >
                <option value="">Select to change round type</option>
                <option value="SeedRound">Seed Round</option>
                <option value="PreICO">Pre-ICO</option>
                <option value="PublicICO">Public ICO</option>
              </select>
            </div>
            <button
              type="submit"
              disabled={loading}
              className="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline transition duration-150 ease-in-out"
            >
              {loading ? 'Updating...' : 'Update ICO Parameters'}
            </button>
          </form>
          {error && (
            <div className="mt-4 p-4 bg-red-100 border border-red-400 text-red-700 rounded-md text-sm">
              {error}
            </div>
          )}
          {success && (
            <div className="mt-4 p-4 bg-green-100 border border-green-400 text-green-700 rounded-md text-sm">
              {success}
            </div>
          )}
        </div>
      </div>
    </div>
  );
};
export default UpdateIcoParameters;




src/component/Footer.js


import React from 'react';

const Footer = () => {
  return (
    <footer className="bg-gray-800 text-white p-4">
      <div className="container mx-auto text-center">
        <p>&copy; 2023 Solana ICO. All rights reserved.</p>
      </div>
    </footer>
  );
};

export default Footer;






src/component/Header.js


import React from 'react';
import { Link } from 'react-router-dom';
import { WalletMultiButton } from '@solana/wallet-adapter-react-ui';

const Header = () => {
  return (
    <header className="bg-gray-800 text-white p-4">
      <div className="container mx-auto flex justify-between items-center">
        <div className="text-xl font-bold">
          <Link to="/">Solana ICO</Link>
        </div>
        <nav className="space-x-4">
          <Link to="/" className="hover:text-gray-300">Dashboard</Link>
          <Link to="/buy" className="hover:text-gray-300">Buy Tokens</Link>
          <Link to="/balance" className="hover:text-gray-300">Balance</Link>
          <WalletMultiButton className="bg-blue-500 hover:bg-blue-600" />
        </nav>
      </div>
    </header>
  );
};

export default Header;






src/components/IcoDetails.js


import React, { useState, useEffect } from 'react';
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { PublicKey } from '@solana/web3.js';
import { getProgram } from '../utils/anchor-connection';
import { formatUnixTimestamp, formatLamports } from '../utils/formatters';

const IcoDetails = () => {
  const { connection } = useConnection();
  const wallet = useWallet();
  const [icoDetails, setIcoDetails] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');

  useEffect(() => {
    fetchIcoDetails();
  }, [connection, wallet.publicKey]);

  const fetchIcoDetails = async () => {
    if (!wallet.publicKey) {
      setLoading(false);
      setError('Please connect your wallet to view ICO details.');
      return;
    }
    setLoading(true);
    setError('');
    try {
      const program = getProgram(connection, wallet);
      const [icoAccount] = await PublicKey.findProgramAddress(
        [Buffer.from("ico")],
        program.programId
      );
      const icoData = await program.account.icoAccount.fetch(icoAccount);
      setIcoDetails({
        authority: icoData.authority.toString(),
        tokenMint: icoData.tokenMint.toString(),
        totalSupply: icoData.totalSupply.toString(),
        tokenPrice: icoData.tokenPrice.toString(),
        tokensSold: icoData.tokensSold.toString(),
        startTime: formatUnixTimestamp(icoData.startTime),
        duration: icoData.duration.toString(),
        isActive: icoData.isActive,
        roundType: Object.keys(icoData.roundType)[0],
        seedInvestors: icoData.seedInvestors.map(investor => investor.toString()),
      });
    } catch (err) {
      console.error('Error fetching ICO details:', err);
      setError('Failed to fetch ICO details. Please ensure the ICO has been initialized and try again.');
    } finally {
      setLoading(false);
    }
  };

  if (loading) return <div className="text-center">Loading ICO details...</div>;
  if (error) return <div className="text-center text-red-500">{error}</div>;
  if (!icoDetails) return <div className="text-center">No ICO details available. The ICO may not have been initialized yet.</div>;

  return (
    <div className="bg-white shadow-md rounded-lg p-6 mb-8">
      <h2 className="text-2xl font-bold mb-4">ICO Details</h2>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <p><span className="font-semibold">Authority:</span> {icoDetails.authority}</p>
        <p><span className="font-semibold">Token Mint:</span> {icoDetails.tokenMint}</p>
        <p><span className="font-semibold">Total Supply:</span> {formatLamports(icoDetails.totalSupply)} tokens</p>
        <p><span className="font-semibold">Token Price:</span> {formatLamports(icoDetails.tokenPrice)} SOL</p>
        <p><span className="font-semibold">Tokens Sold:</span> {formatLamports(icoDetails.tokensSold)}</p>
        <p><span className="font-semibold">Start Time:</span> {icoDetails.startTime}</p>
        <p><span className="font-semibold">Duration:</span> {icoDetails.duration} seconds</p>
        <p><span className="font-semibold">Status:</span> {icoDetails.isActive ? 'Active' : 'Inactive'}</p>
        <p><span className="font-semibold">Round Type:</span> {icoDetails.roundType}</p>
        <p><span className="font-semibold">Number of Seed Investors:</span> {icoDetails.seedInvestors.length}</p>
      </div>
    </div>
  );
};

export default IcoDetails;




src/components/Layout.js


import React from 'react';
import Navbar from './Navbar';
import Sidebar from './Sidebar';

const Layout = ({ children }) => {
  return (
    <div className="flex h-screen bg-gray-100 font-sans">
      <Sidebar />
      <div className="flex flex-col flex-1 overflow-hidden">
        <Navbar />
        <main className="flex-1 overflow-x-hidden overflow-y-auto bg-gray-100">
          <div className="container mx-auto px-6 py-8">
            {children}
          </div>
        </main>
      </div>
    </div>
  );
};

export default Layout;






src/components/Navbar.js



import React from 'react';
import { Link } from 'react-router-dom';
import { WalletMultiButton } from '@solana/wallet-adapter-react-ui';

const Navbar = () => {
  return (
    <nav className="bg-sky-950 text-white p-4 shadow-md">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="flex justify-between items-center">
          <div className="flex items-center">
            
            {/* <img
              className="h-10 w-10 rounded-full"
              src="/placeholder.svg?height=40&width=40"
              alt="Logo"
            /> */}

            <img
              className="h-10 w-10 rounded-full"
              src="/JCK_and_JCKP.svg"
              alt="Logo"
              width="40"
              height="40"
            />

            <span className="ml-2 text-2xl font-semibold">Solana ICO Dashboard</span>
          </div>
          <div className="flex items-center space-x-4">
            <Link to="/buy" className="hover:text-gray-200">Buy Tokens</Link>
            <Link to="/balance" className="hover:text-gray-200">Token Balance</Link>
            <WalletMultiButton className="!bg-sky-700 hover:!bg-sky-800" />
          </div>
        </div>
      </div>
    </nav>
  );
};

export default Navbar;





src/components/Sidebar.js


import React from 'react';
import { Link, useLocation } from 'react-router-dom';
import { useWallet } from '@solana/wallet-adapter-react';
import { isAdminWallet } from '../utils/admin-check';

const Sidebar = () => {
  const location = useLocation();
  const { publicKey } = useWallet();

  const navigation = [
    { name: 'Dashboard', href: '/', icon: 'M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6' },
    { name: 'Buy Tokens', href: '/buy', icon: 'M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z' },
    { name: 'Token Balance', href: '/balance', icon: 'M9 7h6m0 10v-3m-3 3h.01M9 17h.01M9 14h.01M12 14h.01M15 11h.01M12 11h.01M9 11h.01M7 21h10a2 2 0 002-2V5a2 2 0 00-2-2H7a2 2 0 00-2 2v14a2 2 0 002 2z' },
  ];

  const adminNavigation = [
    { name: 'Manage Investors', href: '/manage-investors', icon: 'M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z' },
    { name: 'Update ICO Parameters', href: '/update-parameters', icon: 'M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z' },
    { name: 'Distribute Tokens', href: '/distribute-tokens', icon: 'M8 7h12m0 0l-4-4m4 4l-4 4m0 6H4m0 0l4 4m-4-4l4-4' },
    { name: 'End ICO', href: '/end-ico', icon: 'M13 10V3L4 14h7v7l9-11h-7z' },
  ];

  const NavItem = ({ item, isAdmin = false }) => (
    <Link
      to={item.href}
      className={`${
        location.pathname === item.href
          ? 'bg-primary-100 text-primary-900'
          : 'text-gray-600 hover:bg-primary-50 hover:text-primary-900'
      } group flex items-center px-2 py-2 text-sm font-medium rounded-md transition-colors duration-150 ease-in-out`}
    >
      <svg
        className={`${
          location.pathname === item.href ? 'text-primary-500' : 'text-gray-400 group-hover:text-primary-500'
        } mr-3 flex-shrink-0 h-6 w-6 transition-colors duration-150 ease-in-out`}
        xmlns="http://www.w3.org/2000/svg"
        fill="none"
        viewBox="0 0 24 24"
        stroke="currentColor"
        aria-hidden="true"
      >
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d={item.icon} />
      </svg>
      {item.name}
    </Link>
  );

  return (
    <div className="hidden md:flex md:flex-shrink-0">
      <div className="flex flex-col w-64">
        <div className="flex flex-col h-0 flex-1 bg-white border-r border-gray-200">
          <div className="flex-1 flex flex-col pt-5 pb-4 overflow-y-auto">
            <nav className="mt-5 flex-1 px-2 bg-white space-y-1">
              {navigation.map((item) => (
                <NavItem key={item.name} item={item} />
              ))}
              {isAdminWallet(publicKey) && (
                <>
                  <div className="mt-8 mb-2 px-3 text-xs font-semibold text-gray-500 uppercase tracking-wider">
                    Admin
                  </div>
                  {adminNavigation.map((item) => (
                    <NavItem key={item.name} item={item} isAdmin />
                  ))}
                </>
              )}
            </nav>
          </div>
        </div>
      </div>
    </div>
  );
};

export default Sidebar;




src/utils/admin-check.js


export const isAdminWallet = (publicKey) => {
  const adminAddress = process.env.REACT_APP_OWNER_ADDRESS;
  return publicKey && publicKey.toBase58() === adminAddress;
};





src/utils/anchor-connection.js


import { Connection, PublicKey } from '@solana/web3.js';
import { Program, AnchorProvider } from '@project-serum/anchor';
import idl from './ico-idl.json';

const programID = new PublicKey(process.env.REACT_APP_PROGRAM_ID);

export const getProgram = (connection, wallet) => {
  if (!connection || !wallet) {
    throw new Error('Connection and wallet are required to get the program');
  }
  
  const provider = new AnchorProvider(
    connection,
    wallet,
    AnchorProvider.defaultOptions()
  );
  
  return new Program(idl, programID, provider);
};





src/utils/enum-helpers.js


export const RoundType = {
  SeedRound: { seedRound: {} },
  PreICO: { preIco: {} },
  PublicICO: { publicIco: {} }
};

export const getRoundTypeFromString = (roundTypeStr) => {
  switch (roundTypeStr) {
    case 'SeedRound':
      return RoundType.SeedRound;
    case 'PreICO':
      return RoundType.PreICO;
    case 'PublicICO':
      return RoundType.PublicICO;
    default:
      return null;
  }
};

export const getRoundTypeString = (roundType) => {
  if (roundType.seedRound) return 'SeedRound';
  if (roundType.preIco) return 'PreICO';
  if (roundType.publicIco) return 'PublicICO';
  return 'Unknown';
};





src/utils/formatters.js


import { LAMPORTS_PER_SOL } from '@solana/web3.js';

export const lamportsToSol = (lamports) => {
  return lamports / LAMPORTS_PER_SOL;
};

export const solToLamports = (sol) => {
  return Math.floor(sol * LAMPORTS_PER_SOL);
};

export const formatUnixTimestamp = (timestamp) => {
  const date = new Date(timestamp * 1000);
  return date.toLocaleString();
};

export const formatLamports = (lamports) => {
  return (lamports / LAMPORTS_PER_SOL).toFixed(9);
};


export const formatSol = (lamports) => {
  return (lamports / LAMPORTS_PER_SOL).toFixed(4);
};





src/utils/ico-instructions.js



import { getProgram } from './anchor-connection';
import { PublicKey } from '@solana/web3.js';
import { TOKEN_PROGRAM_ID, ASSOCIATED_TOKEN_PROGRAM_ID } from '@solana/spl-token';

export const buyTokens = async (connection, wallet, amount) => {
  const program = getProgram(connection, wallet);
  const [icoAccount] = await PublicKey.findProgramAddress(
    [Buffer.from("ico")],
    program.programId
  );
  const [tokenAccount] = await PublicKey.findProgramAddress(
    [Buffer.from("token_account"), wallet.publicKey.toBuffer()],
    program.programId
  );

  await program.methods
    .buyTokens(amount)
    .accounts({
      ico: icoAccount,
      tokenAccount: tokenAccount,
      buyer: wallet.publicKey,
    })
    .rpc();
};

export const addToWhitelist = async (connection, wallet, investorPublicKey) => {
  const program = getProgram(connection, wallet);
  const [icoAccount] = await PublicKey.findProgramAddress(
    [Buffer.from("ico")],
    program.programId
  );

  await program.methods
    .addToWhitelist(investorPublicKey)
    .accounts({
      ico: icoAccount,
      authority: wallet.publicKey,
    })
    .rpc();
};

export const removeFromWhitelist = async (connection, wallet, investorPublicKey) => {
  const program = getProgram(connection, wallet);
  const [icoAccount] = await PublicKey.findProgramAddress(
    [Buffer.from("ico")],
    program.programId
  );

  await program.methods
    .removeFromWhitelist(investorPublicKey)
    .accounts({
      ico: icoAccount,
      authority: wallet.publicKey,
    })
    .rpc();
};

export const updateIcoParameters = async (connection, wallet, params) => {
  const program = getProgram(connection, wallet);
  const [icoAccount] = await PublicKey.findProgramAddress(
    [Buffer.from("ico")],
    program.programId
  );

  await program.methods
    .updateIcoParameters(params)
    .accounts({
      ico: icoAccount,
      authority: wallet.publicKey,
    })
    .rpc();
};

export const distributeTokens = async (connection, wallet, purchaseAccount) => {
  const program = getProgram(connection, wallet);
  const [icoAccount] = await PublicKey.findProgramAddress(
    [Buffer.from("ico")],
    program.programId
  );

  const [treasuryTokenAccount] = await PublicKey.findProgramAddress(
    [Buffer.from("treasury"), icoAccount.toBuffer()],
    program.programId
  );

  const purchase = await program.account.purchaseAccount.fetch(purchaseAccount);
  const buyerTokenAccount = await getAssociatedTokenAddress(
    program.programId,
    purchase.buyer
  );

  await program.methods
    .distributeTokens()
    .accounts({
      authority: wallet.publicKey,
      icoAccount: icoAccount,
      purchaseAccount: purchaseAccount,
      treasuryTokenAccount: treasuryTokenAccount,
      buyerTokenAccount: buyerTokenAccount,
      tokenProgram: TOKEN_PROGRAM_ID,
    })
    .rpc();
};

export const endIco = async (connection, wallet) => {
  const program = getProgram(connection, wallet);
  const [icoAccount] = await PublicKey.findProgramAddress(
    [Buffer.from("ico")],
    program.programId
  );

  await program.methods
    .endIco()
    .accounts({
      ico: icoAccount,
      authority: wallet.publicKey,
    })
    .rpc();
};

// Helper function to get associated token address
async function getAssociatedTokenAddress(mint, owner) {
  return (await PublicKey.findProgramAddress(
    [
      owner.toBuffer(),
      TOKEN_PROGRAM_ID.toBuffer(),
      mint.toBuffer(),
    ],
    ASSOCIATED_TOKEN_PROGRAM_ID
  ))[0];
}






src/App.js



import React, { useMemo } from 'react';
import { BrowserRouter as Router, Route, Routes, Navigate } from 'react-router-dom';
import { ConnectionProvider, WalletProvider } from '@solana/wallet-adapter-react';
import { WalletAdapterNetwork } from '@solana/wallet-adapter-base';
import { PhantomWalletAdapter } from '@solana/wallet-adapter-wallets';
import { WalletModalProvider } from '@solana/wallet-adapter-react-ui';
import { clusterApiUrl } from '@solana/web3.js';
import Layout from './components/Layout';
import Dashboard from './pages/Dashboard';
import BuyTokens from './pages/BuyTokens';
import TokenBalance from './pages/TokenBalance';
import ManageInvestors from './pages/ManageInvestors';
import UpdateIcoParameters from './pages/UpdateIcoParameters';
import DistributeTokens from './pages/DistributeTokens';
import EndIco from './pages/EndIco';
import { AdminRoute } from './components/AdminRoute';
import '@solana/wallet-adapter-react-ui/styles.css';
import './App.css';

function App() {
  const network = WalletAdapterNetwork.Devnet;
  const endpoint = useMemo(() => clusterApiUrl(network), [network]);
  const wallets = useMemo(() => [new PhantomWalletAdapter()], []);

  return (
    <ConnectionProvider endpoint={endpoint}>
      <WalletProvider wallets={wallets} autoConnect>
        <WalletModalProvider>
          <Router>
            <Layout>
              <Routes>
                <Route path="/" element={<Dashboard />} />
                <Route path="/buy" element={<BuyTokens />} />
                <Route path="/balance" element={<TokenBalance />} />
                <Route path="/manage-investors" element={<AdminRoute><ManageInvestors /></AdminRoute>} />
                <Route path="/update-parameters" element={<AdminRoute><UpdateIcoParameters /></AdminRoute>} />
                <Route path="/distribute-tokens" element={<AdminRoute><DistributeTokens /></AdminRoute>} />
                <Route path="/end-ico" element={<AdminRoute><EndIco /></AdminRoute>} />
              </Routes>
            </Layout>
          </Router>
        </WalletModalProvider>
      </WalletProvider>
    </ConnectionProvider>
  );
}

export default App;






src/index.js



import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
reportWebVitals();




.env 


REACT_APP_PROGRAM_ID=FyCz92Au4vcsanwaJZ8PrykVf6oPgreoYKmCque5Qq45
REACT_APP_TOKEN_MINT_ADDRESS=7GYz5XMx5BQrMtexJZrrJQM1WfhHnWAmf8Snhaqqmf3U
REACT_APP_OWNER_ADDRESS=DYkCAokwibanNxMvixmoZFQDwayGDJWfJ9moZjDRpUvW
REACT_APP_NETWORK=devnet




BTW my current owner wallet address is    "DYkCAokwibanNxMvixmoZFQDwayGDJWfJ9moZjDRpUvW"



So this is the full reactjs file based on the Solana Smart contract (which I share previously), Now create a standard Backend for the entire project in nodejs fully and properly mention everything like db, controller, src, router and others which is mostly needed for that project(include .env) with the proper integration with UI also

so based on my input first read carefully full code and then generate the full backend with integration with UI also and generate the full files with proper standard structure




So this are my all major files i created currently, and I also provide smart contract, now read the smart contract fully first then manage my entire reactjs files fully with maintaining the path,

and regenerate the full files and tell me the smart contract changes process also if needed (like what is buyer field should be in buytoken, IcoAccount, authority, treasureWallet, tokenAccount, buyerTokenAccount,tokenProgram and systemProgram in the input field)

after carefully read the smart contract modify the current reactJs files and regenerate the full files all without any missing (I also changes some functionality in my current smart contract and paste fully here, base on this smart contract create a full reactjs ICO project with standard UI and without errro and also tell me where should i add programID, contract Address, Token address, token Account and other things)

BTW i already deployed the smart contract fully in solpg(a browzer IDE) and have programID and idl.json file, so no need to generate that files just tell me the location

and remember base on the smart contract generate the all files fully and maintain in .js instead of .tsx and generate all files fully with the proper structure maintain

pub enum RoundType {
    SeedRound,
    PreICO,
    PublicICO,
}

and here total smart contract has 3 phase, so maintain the phase by first for "SeedRound", then complete "PreIco", and after that complete publicICO" phase and then generate the code fully

So this are my all major files and I also provide smart contract also, now read the smart contract and all react js file carefully and then solve the BuyTokenPage error and others files also if needed changes the others files also

and regenerate the full files and tell me the smart contract changes process also if needed (like what is buyer field should be in buytoken, IcoAccount, authority, treasureWallet, tokenAccount, buyerTokenAccount,tokenProgram and systemProgram in the input field)